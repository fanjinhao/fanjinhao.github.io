<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>给2020的一个词</title>
    <url>/2019/12/22/1121/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码无效, 请检查并重试" data-whm="这些内容无法验证，但您仍然可以查看"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Hey, 请输入密码" /><label>Hey, 请输入密码</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="5a01a96bddb473ef15aecdcbd30b8cfb261b6f98c912a1b6dc5f49f8a9d7c37d">5393d9cd48cf4ad629c25c2765d478ff918c3f927f5a06f7a62ff39ee7e52eb9960ab17082517bcf1273251c17a17227752e35f194019001feb2eaac48bda17e4cc7be558ea8a307405eeaffa4f10e0488190e361d6a9d1d84b150248f0a01760ca09d08b9d4009a90c5d4ee53c5fb3cc4ffd3516833d1b8dd169c3a69dd4c25c3ca3ad0cedbce7fe578919ea372c2b1d98fab59a5d908c7b986e67dc0906fef33e7674b83e15809b7aa176535bc9bae719a7fd255a9869082f4559336d51287aa3ea4959e085ed70313b01fa5beccc5515cddff58d41f979e99e64f67b53ba0fa59d767a809a56a2db0d46b233fd25fd3763283f88528d081e5a82eb5348223a7a2719892a4ca7407e92353a85d0107a5c5b1e92bbfcbd3ec7a39da04f30655538ddea8e697a7e69f279095826206bfe681f76c30e316d58b978e31861b60f89cd2d624e86d885176a49790c7d438cd3d984a0726d55ad25c9308fb9286782340fba0c73099916bd36424bd08a53cd9314d7cddaeaad03617f35595e66f86e7d9562c71214d65c78d6bd6022b8d892eb6f150fbbd55f7849b37a755cf98c9a4eaefbcbf70903f33dd5102a1f310efff30ee337ebd0df2aa391bfcfd3e93e989c13f9cde681a73572324e60a9e68ae7138e8e5580c5cd9321c34d595a301073817cc12e219fd02cfed6714f403c41209254a8289aa05c0cb18b97f34ca39f99287b509390c8af813ad4e4646f8d0c2fa7b27ba5d40c055b633fd202f51f0fe19064d583ac6de1c51ce4b7df88d752e66ff277fe29a290362220f829a177b568414d3e86f144562b019f6f445e9c9b882ed947916d2158b982060b53c906ecfb87058de4ac2350d9985ca9d7442179513c27539dcfb418c58895d6edf4649cc403ee0ef77f4d33b29734ad5ae52166342da0d9299b69c171accc33b57bafe4d043565e03aa65bc0b4c3ca30a6b5b93fda74b77672908947340d3b6c8c7e3527e84c09d2d2864a74f2b65799be6604a1464aca1a0e06e66f5d50af18463518fb2703b0c325dee7baae6835d1a11f2bfb8a3b308c4806b6a22bcbabdee3783a9a373b4d45582b7cbd9e922542389e2aaab17f844156f8f26293b4078ef29a6d63d914f01f73ea2e2dbcfae360e178f9fab6028f423ba6926c9f1d98a9d976ff339255d5c34ea99c360673838de9f4def474f0c8ce379399531c4ce99b7df7ea3bf6eedd2fcfd14d88fd5a3f6fa7bfce29c38db6aa7eeda059a7584ed3b87bff3b09faad41bea70320ef87bb7d6d1a20db81737c058fec29054fb92a238918f8c23ddec81e05669fbc8f4bdb24416f3759c88de604541c72d30d4369ef4023eb301d424f9c3e4763eed0efa9dd7dce8f9a6a8a4fe38cac57b6ae8914428bac2bf855a13316384a015c0a605f26a86bc022681f0ebb49f260428b53b6d544f04ba5405c70f085f909e29e931bf5fdfcffd3506c115109904fbd585e17e943898993137d50d6589dfce1f974adc9221df905427e809cda7e05d5b17c2ced17f25e60fa952e93a6cc8d9d77928ddaefbf50c1ea24312b8ee3f05e4d97fccbc854ab44886f0d5cbc416a033e5c1f67891308f35c1cd9229221a133f48e26ad95a176d395bda6fe984cf51c073158473250d0dcdba438b48b2ce41a89f0e5429e086be15f3cd05d76b5f85b98fa29c1f6109bc0a06cfc78dafeebfbb3696e40958a41a42917b9229fc597ac8be3962ed615abb531b66cc423842da2b8374d8eaaa062a627589b1358d39bdd18e2a5f3f41c9466e1a932e87fd4cd6d95a15f360935788ac6ba8805a41995dbd3e3a6d745937e5ec4de8fc24ac928179570e43507d03e3f1ab01a9f5451000b4831ec6ffd0c3cebdbfe0ca1dcf3f3f866be7d4bcb76b219a4012247b50ded34b42fbb727b78439637103f785a790872c98c96faf2fd8d16fe1b09323f3e456c511b7d1635fe251e2807c2edf2130ea125441b972969ff5f4fadb442e386324b1cf6fa917d65b0898879254a1d748b5d51bc43c981ddbc5836f05336ea91d0ee09bf3264470c495dbf0320c18c801b3a7151a1edf4a5459462</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>1009. 说反话 (20)</title>
    <url>/2015/07/11/1009-e8-af-b4-e5-8f-8d-e8-af-9d20/</url>
    <content><![CDATA[<h1 id="P1009-说反话-20"><a href="#P1009-说反话-20" class="headerlink" title="P1009 说反话 (20)"></a>P1009 说反话 (20)</h1><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>每个测试用例的输出占一行，输出倒序后的句子。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p><pre>Hello World Here I Come<br></pre></p>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><p><pre>Come I Here World Hello<br><a id="more"></a></pre></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">81</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, k;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    gets(str);</span><br><span class="line">    k = <span class="built_in">strlen</span>(str);</span><br><span class="line">    p = str + k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p == str )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">' '</span> &amp;&amp; *(p+<span class="number">1</span>) != <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *p = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s "</span>, p+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title>「转载」GCD 深入理解：第一部分</title>
    <url>/2021/05/07/2014-04-19-grand-central-dispatch-in-depth-part-1/</url>
    <content><![CDATA[<h1 id="GCD-深入理解：第一部分"><a href="#GCD-深入理解：第一部分" class="headerlink" title="GCD 深入理解：第一部分"></a>GCD 深入理解：第一部分</h1><p>本文翻译自 <a href="http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="noopener">http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1</a></p>
<p>原作者：<a href="http://www.raywenderlich.com/u/Lolgrep" target="_blank" rel="noopener">Derek Selander</a></p>
<p>译者：<a href="https://twitter.com/nixzhu" target="_blank" rel="noopener">@nixzhu</a></p>
<hr>
<a id="more"></a>
<p>虽然 GCD 已出现一段时间了，但不是每个人都明了其主要功能。可以理解，因为并发一直很棘手。GCD 提供基于 C 的 API ，它们就像一组棱角戳进 Objective-C 的平滑世界。我们将分两个部分的教程来深入学习 GCD 。</p>
<p>在这两部分的系列中，第一部分的将解释 GCD 是做什么的，并从许多基本的 GCD 函数中找出几个来展示。在<a href="https://github.com/nixzhu/dev-blog/blob/main/posts/2014-05-14-grand-central-dispatch-in-depth-part-2.md" target="_blank" rel="noopener">第二部分</a>，你将学到 GCD 提供的几个高级函数。</p>
<h2 id="什么是-GCD"><a href="#什么是-GCD" class="headerlink" title="什么是 GCD"></a>什么是 GCD</h2><p>GCD 是 <code>libdispatch</code> 的市场名称，而 libdispatch 作为 Apple 的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点：</p>
<ul>
<li>GCD 能将昂贵计算任务推迟在后台运行，以改善应用的响应性能。</li>
<li>GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，能帮助我们避开并发陷阱。</li>
<li>GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。</li>
</ul>
<p>本教程假设你对 Block 和 GCD 有基础了解。如果你对 GCD 完全陌生，先看看 <a href="http://www.raywenderlich.com/4295/multithreading-and-grand-central-dispatch-on-ios-for-beginners-tutorial" target="_blank" rel="noopener">iOS 上的多线程和 GCD 入门教程</a> 学习其要领。</p>
<h2 id="GCD-术语"><a href="#GCD-术语" class="headerlink" title="GCD 术语"></a>GCD 术语</h2><p>要理解 GCD ，你要先熟悉与线程和并发相关的几个概念。这两者都可能模糊和微妙，所以在开始 GCD 之前先简要地回顾一下它们。</p>
<h4 id="Serial-vs-Concurrent-串行-vs-并发"><a href="#Serial-vs-Concurrent-串行-vs-并发" class="headerlink" title="Serial vs. Concurrent 串行 vs. 并发"></a>Serial vs. Concurrent 串行 vs. 并发</h4><p>这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。</p>
<p>虽然这些术语被广泛使用，本教程中你可以将任务设定为一个 Objective-C 的 Block 。不明白什么是 Block ？看看 <a href="http://www.raywenderlich.com/9328/creating-a-diner-app-using-blocks-part-1" target="_blank" rel="noopener">iOS 5 教程中的如何使用 Block</a> 。实际上，你也可以在 GCD 上使用函数指针，但在大多数场景中，这实际上更难于使用。Block 就是更加容易些！</p>
<h4 id="Synchronous-vs-Asynchronous-同步-vs-异步"><a href="#Synchronous-vs-Asynchronous-同步-vs-异步" class="headerlink" title="Synchronous vs. Asynchronous 同步 vs. 异步"></a>Synchronous vs. Asynchronous 同步 vs. 异步</h4><p>在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个<em>同步</em>函数只在完成了它预定的任务后才返回。</p>
<p>一个<em>异步</em>函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。</p>
<p>注意——当你读到同步函数“阻塞（Block）”当前线程，或函数是一个“阻塞”函数或阻塞操作时，不要被搞糊涂了！动词“阻塞”描述了函数如何影响它所在的线程而与名词“代码块（Block）”没有关系。代码块描述了用 Objective-C 编写的一个匿名函数，它能定义一个任务并被提交到 GCD 。</p>
<p>译者注：中文不会有这个问题，“阻塞”和“代码块”是两个词。</p>
<h4 id="Critical-Section-临界区"><a href="#Critical-Section-临界区" class="headerlink" title="Critical Section 临界区"></a>Critical Section 临界区</h4><p>就是一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（译者注：它的值不再可信）。</p>
<h4 id="Race-Condition-竞态条件"><a href="#Race-Condition-竞态条件" class="headerlink" title="Race Condition 竞态条件"></a>Race Condition 竞态条件</h4><p>这种状况是指基于特定序列或时机的事件的软件系统以不受控制的方式运行的行为，例如程序的并发任务执行的确切顺序。竞态条件可导致无法预测的行为，而不能通过代码检查立即发现。</p>
<h4 id="Deadlock-死锁"><a href="#Deadlock-死锁" class="headerlink" title="Deadlock 死锁"></a>Deadlock 死锁</h4><p>两个（有时更多）东西——在大多数情况下，是线程——所谓的死锁是指它们都卡住了，并等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。</p>
<h4 id="Thread-Safe-线程安全"><a href="#Thread-Safe-线程安全" class="headerlink" title="Thread Safe 线程安全"></a>Thread Safe 线程安全</h4><p>线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃，等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是 <code>NSDictionary</code> 。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，<code>NSMutableDictionary</code> 就不是线程安全的，应该保证一次只能有一个线程访问它。</p>
<h4 id="Context-Switch-上下文切换"><a href="#Context-Switch-上下文切换" class="headerlink" title="Context Switch 上下文切换"></a>Context Switch 上下文切换</h4><p>一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。</p>
<h3 id="Concurrency-vs-Parallelism-并发与并行"><a href="#Concurrency-vs-Parallelism-并发与并行" class="headerlink" title="Concurrency vs Parallelism 并发与并行"></a>Concurrency vs Parallelism 并发与并行</h3><p>并发和并行通常被一起提到，所以值得花些时间解释它们之间的区别。</p>
<p>并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Concurrency_vs_Parallelism.png" alt="Concurrency_vs_Parallelism"></p>
<p>虽然你可以编写代码在 GCD 下并发执行，但 GCD 会决定有多少并行的需求。并行<em>要求</em>并发，但并发并不能<em>保证</em>并行。</p>
<p>更深入的观点是并发实际上是关于<em>构造</em>。当你在脑海中用 GCD 编写代码，你组织你的代码来暴露能同时运行的多个工作片段，以及不能同时运行的那些。如果你想深入此主题，看看 <a href="http://vimeo.com/49718712" target="_blank" rel="noopener">这个由 Rob Pike 做的精彩的讲座</a> 。</p>
<h3 id="Queues-队列"><a href="#Queues-队列" class="headerlink" title="Queues 队列"></a>Queues 队列</h3><p>GCD 提供有 <code>dispatch queues</code> 来处理代码块，这些队列管理你提供给 GCD 的任务并用 FIFO 顺序执行这些任务。这就保证了第一个被添加到队列里的任务会是队列中第一个开始的任务，而第二个被添加的任务将第二个开始，如此直到队列的终点。</p>
<p>所有的调度队列（dispatch queues）自身都是线程安全的，你能从多个线程并行的访问它们。当你了解了调度队列如何为你自己代码的不同部分提供线程安全后，GCD 的优点就是显而易见的。关于这一点的关键是选择正确<em>类型</em>的调度队列和正确的<em>调度函数</em>来提交你的工作。</p>
<p>在本节你会看到两种调度队列，都是由 GCD 提供的，然后看一些描述如何用调度函数添加工作到队列的例子。</p>
<h4 id="Serial-Queues-串行队列"><a href="#Serial-Queues-串行队列" class="headerlink" title="Serial Queues 串行队列"></a>Serial Queues 串行队列</h4><p>串行队列中的任务一次执行一个，每个任务只在前一个任务完成时才开始。而且，你不知道在一个 Block 结束和下一个开始之间的时间长度，如下图所示：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Serial-Queue.png" alt="Serial-Queue"></p>
<p>这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。</p>
<p>由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区。所以如果访问临界区的唯一方式是通过提交到调度队列的任务，那么你就不需要担心临界区的安全问题了。</p>
<h4 id="Concurrent-Queues-并发队列"><a href="#Concurrent-Queues-并发队列" class="headerlink" title="Concurrent Queues 并发队列"></a>Concurrent Queues 并发队列</h4><p>在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。</p>
<p>下图展示了一个示例任务执行计划，GCD 管理着四个并发任务：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Concurrent-Queue.png" alt="Concurrent-Queue"></p>
<p>注意 Block 1,2 和 3 都立马开始运行，一个接一个。在 Block 0 开始后，Block 1 等待了好一会儿才开始。同样， Block 3 在 Block 2 之后才开始，但它先于 Block 2 完成。</p>
<p>何时开始一个 Block 完全取决于 GCD 。如果一个 Block 的执行时间与另一个重叠，也是由 GCD 来决定是否将其运行在另一个不同的核心上，如果那个核心可用，否则就用上下文切换的方式来执行不同的 Block 。</p>
<p>有趣的是， GCD 提供给你至少五个特定的队列，可根据队列类型选择使用。</p>
<h4 id="Queue-Types-队列类型"><a href="#Queue-Types-队列类型" class="headerlink" title="Queue Types 队列类型"></a>Queue Types 队列类型</h4><p>首先，系统提供给你一个叫做 <code>主队列（main queue）</code> 的特殊队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。然而，它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。这个队列就是用于发生消息给 <code>UIView</code> 或发送通知的。</p>
<p>系统同时提供给你好几个并发队列。它们叫做 <code>全局调度队列（Global Dispatch Queues）</code> 。目前的四个全局队列有着不同的优先级：<code>background</code>、<code>low</code>、<code>default</code> 以及 <code>high</code>。要知道，Apple 的 API 也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务。</p>
<p>最后，你也可以创建自己的串行队列或并发队列。这就是说，至少有<em>五个</em>队列任你处置：主队列、四个全局调度队列，再加上任何你自己创建的队列。</p>
<p>以上是调度队列的大框架！</p>
<p>GCD 的“艺术”归结为选择合适的队列来调度函数以提交你的工作。体验这一点的最好方式是走一遍下边的列子，我们沿途会提供一些一般性的建议。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>既然本教程的目标是优化且安全的使用 GCD 调用来自不同线程的代码，那么你将从一个近乎完成的叫做 <code>GooglyPuff</code> 的项目入手。</p>
<p>GooglyPuff 是一个没有优化，线程不安全的应用，它使用 Core Image 的人脸检测 API 来覆盖一对曲棍球眼睛到被检测到的人脸上。对于基本的图像，可以从相机胶卷选择，或用预设好的 URL 从互联网下载。</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2014/01/GooglyPuff_Start_1.zip" target="_blank" rel="noopener">点击此处下载项目</a></p>
<p>完成项目下载之后，将其解压到某个方便的目录，再用 Xcode 打开它并编译运行。这个应用看起来如下图所示：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Workflow1.png" alt="Workflow"></p>
<p>注意当你选择 <code>Le Internet</code> 选项下载图片时，一个 <code>UIAlertView</code> 过早地弹出。你将在本系列教程地第二部分修复这个问题。</p>
<p>这个项目中有四个有趣的类：</p>
<ul>
<li>PhotoCollectionViewController：它是应用开始的第一个视图控制器。它用缩略图展示所有选定的照片。</li>
<li>PhotoDetailViewController：它执行添加曲棍球眼睛到图像上的逻辑，并用一个 UIScrollView 来显示结果图片。</li>
<li>Photo：这是一个类簇，它根据一个 <code>NSURL</code> 的实例或一个 <code>ALAsset</code> 的实例来实例化照片。这个类提供一个图像、缩略图以及从 URL 下载的状态。</li>
<li>PhotoManager：它管理所有 <code>Photo</code> 的实例.</li>
</ul>
<h2 id="用-dispatch-async-处理后台任务"><a href="#用-dispatch-async-处理后台任务" class="headerlink" title="用 dispatch_async 处理后台任务"></a>用 dispatch_async 处理后台任务</h2><p>回到应用并从你的相机胶卷添加一些照片或使用 <code>Le Internet</code> 选项下载一些。</p>
<p>注意在按下 <code>PhotoCollectionViewController</code> 中的一个 <code>UICollectionViewCell</code> 到生成一个新的 <code>PhotoDetailViewController</code> 之间花了多久时间；你会注意到一个明显的滞后，特别是在比较慢的设备上查看很大的图。</p>
<p>在重载 <code>UIViewController 的 viewDidLoad</code> 时容易加入太多杂乱的工作（too much clutter），这通常会引起视图控制器出现前更长的等待。如果可能，最好是卸下一些工作放到后台，如果它们不是绝对必须要运行在加载时间里。</p>
<p>这听起来像是 <code>dispatch_async</code> 能做的事情！</p>
<p>打开 <code>PhotoDetailViewController</code> 并用下面的实现替换 <code>viewDidLoad</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSAssert(_image, @&quot;Image not set; required to use view controller&quot;);</span><br><span class="line">    self.photoImageView.image = _image;</span><br><span class="line"></span><br><span class="line">    //Resize if neccessary to ensure it&apos;s not pixelated</span><br><span class="line">    if (_image.size.height &lt;= self.photoImageView.bounds.size.height &amp;&amp;</span><br><span class="line">        _image.size.width &lt;= self.photoImageView.bounds.size.width) &#123;</span><br><span class="line">        [self.photoImageView setContentMode:UIViewContentModeCenter];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; // 1</span><br><span class="line">        UIImage *overlayImage = [self faceOverlayImageFromImage:_image];</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123; // 2</span><br><span class="line">            [self fadeInNewImage:overlayImage]; // 3</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来说明上面的新代码所做的事：</p>
<ol>
<li>你首先将工作从主线程移到全局线程。因为这是一个 <code>dispatch_async()</code> ，Block 会被异步地提交，意味着调用线程地执行将会继续。这就使得 <code>viewDidLoad</code> 更早地在主线程完成，让加载过程感觉起来更加快速。同时，一个人脸检测过程会启动并将在稍后完成。</li>
<li>在这里，人脸检测过程完成，并生成了一个新的图像。既然你要使用此新图像更新你的 <code>UIImageView</code> ，那么你就添加一个新的 Block 到主线程。记住——你必须总是在主线程访问 UIKit 的类。</li>
<li>最后，你用 <code>fadeInNewImage:</code> 更新 UI ，它执行一个淡入过程切换到新的曲棍球眼睛图像。</li>
</ol>
<p>编译并运行你的应用；选择一个图像然后你会注意到视图控制器加载明显变快，曲棍球眼睛稍微在之后就加上了。这给应用带来了不错的效果，和之前的显示差别巨大。</p>
<p>进一步，如果你试着加载一个超大的图像，应用不会在加载视图控制器上“挂住”，这就使得应用具有很好伸缩性。</p>
<p>正如之前提到的， <code>dispatch_async</code> 添加一个 Block 到队列就立即返回了。任务会在之后由 GCD 决定执行。当你需要在后台执行一个基于网络或 CPU 紧张的任务时就使用 <code>dispatch_async</code> ，这样就不会阻塞当前线程。</p>
<p>下面是一个关于在 <code>dispatch_async</code> 上如何以及何时使用不同的队列类型的快速指导：</p>
<ul>
<li>自定义串行队列：当你想串行执行后台任务并追踪它时就是一个好选择。这消除了资源争用，因为你知道一次只有一个任务在执行。注意若你需要来自某个方法的数据，你必须内联另一个 Block 来找回它或考虑使用 <code>dispatch_sync</code>。</li>
<li>主队列（串行）：这是在一个并发队列上完成任务后更新 UI 的共同选择。要这样做，你将在一个 Block 内部编写另一个 Block 。以及，如果你在主队列调用 <code>dispatch_async</code> 到主队列，你能确保这个新任务将在当前方法完成后的某个时间执行。</li>
<li>并发队列：这是在后台执行非 UI 工作的共同选择。</li>
</ul>
<h2 id="使用-dispatch-after-延后工作"><a href="#使用-dispatch-after-延后工作" class="headerlink" title="使用 dispatch_after 延后工作"></a>使用 dispatch_after 延后工作</h2><p>稍微考虑一下应用的 UX 。是否用户第一次打开应用时会困惑于不知道做什么？你是这样吗？ :]</p>
<p>如果用户的 <code>PhotoManager</code> 里还没有任何照片，那么显示一个提示会是个好主意！然而，你同样要考虑用户的眼睛会如何在主屏幕上浏览：如果你太快的显示一个提示，他们的眼睛还徘徊在视图的其它部分上，他们很可能会错过它。</p>
<p>显示提示之前延迟一秒钟就足够捕捉到用户的注意，他们此时已经第一次看过了应用。</p>
<p>添加如下代码到到 PhotoCollectionViewController.m 中 showOrHideNavPrompt 的废止实现里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)showOrHideNavPrompt</span><br><span class="line">&#123;</span><br><span class="line">    NSUInteger count = [[PhotoManager sharedManager] photos].count;</span><br><span class="line">    double delayInSeconds = 1.0;</span><br><span class="line">    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1</span><br><span class="line">    dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; // 2</span><br><span class="line">        if (!count) &#123;</span><br><span class="line">            [self.navigationItem setPrompt:@&quot;Add photos with faces to Googlyify them!&quot;];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [self.navigationItem setPrompt:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>showOrHideNavPrompt 在 viewDidLoad 中执行，以及 UICollectionView 被重新加载的任何时候。按照注释数字顺序看看：</p>
<ol>
<li>你声明了一个变量指定要延迟的时长。</li>
<li>然后等待 <code>delayInSeconds</code> 给定的时长，再异步地添加一个 Block 到主线程。</li>
</ol>
<p>编译并运行应用。应该有一个轻微地延迟，这有助于抓住用户的注意力并展示所要做的事情。</p>
<p><code>dispatch_after</code> 工作起来就像一个延迟版的 <code>dispatch_async</code> 。你依然不能控制实际的执行时间，且一旦 <code>dispatch_after</code> 返回也就不能再取消它。</p>
<p>不知道何时适合使用 <code>dispatch_after</code> ？</p>
<ul>
<li>自定义串行队列：在一个自定义串行队列上使用 <code>dispatch_after</code> 要小心。你最好坚持使用主队列。</li>
<li>主队列（串行）：是使用 <code>dispatch_after</code> 的好选择；Xcode 提供了一个不错的自动完成模版。</li>
<li>并发队列：在并发队列上使用 <code>dispatch_after</code> 也要小心；你会这样做就比较罕见。还是在主队列做这些操作吧。</li>
</ul>
<h2 id="让你的单例线程安全"><a href="#让你的单例线程安全" class="headerlink" title="让你的单例线程安全"></a>让你的单例线程安全</h2><p>单例，不论喜欢还是讨厌，它们在 iOS 上的流行情况就像网上的猫。 :]</p>
<p>一个常见的担忧是它们常常不是线程安全的。这个担忧十分合理，基于它们的用途：单例常常被多个控制器同时访问。</p>
<p>单例的线程担忧范围从初始化开始，到信息的读和写。<code>PhotoManager</code> 类被实现为单例——它在目前的状态下就会被这些问题所困扰。要看看事情如何很快地失去控制，你将在单例实例上创建一个控制好的竞态条件。</p>
<p>导航到 <code>PhotoManager.m</code> 并找到 <code>sharedManager</code> ；它看起来如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    static PhotoManager *sharedPhotoManager = nil;</span><br><span class="line">    if (!sharedPhotoManager) &#123;</span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init];</span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedPhotoManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前状态下，代码相当简单；你创建了一个单例并初始化一个叫做 <code>photosArray</code> 的 <code>NSMutableArray</code> 属性。</p>
<p>然而，<code>if</code> 条件分支不是<a href="http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1#Terminology" target="_blank" rel="noopener">线程安全</a>的；如果你多次调用这个方法，有一个可能性是在某个线程（就叫它线程 A）上进入 <code>if</code> 语句块并可能在 <code>sharedPhotoManager</code> 被分配内存前发生一个上下文切换。然后另一个线程（线程 B）可能进入 <code>if</code> ，分配单例实例的内存，然后退出。</p>
<p>当系统上下文切换回线程 A，你会分配另外一个单例实例的内存，然后退出。在那个时间点，你有了两个单例的实例——很明显这不是你想要的（译者注：这还能叫单例吗？）！</p>
<p>要强制这个（竞态）条件发生，替换 <code>PhotoManager.m</code> 中的 <code>sharedManager</code> 为下面的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    static PhotoManager *sharedPhotoManager = nil;</span><br><span class="line">    if (!sharedPhotoManager) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init];</span><br><span class="line">        NSLog(@&quot;Singleton has memory address at: %@&quot;, sharedPhotoManager);</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedPhotoManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中你用 <code>NSThread 的 sleepForTimeInterval:</code> 类方法来强制发生一个上下文切换。</p>
<p>打开 <code>AppDelegate.m</code> 并添加如下代码到 <code>application:didFinishLaunchingWithOptions:</code> 的最开始处：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">    [PhotoManager sharedManager];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">    [PhotoManager sharedManager];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里创建了多个异步并发调用来实例化单例，然后引发上面描述的竞态条件。</p>
<p>编译并运行项目；查看控制台输出，你会看到多个单例被实例化，如下所示：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/NSLog-Race-Condition.png" alt="NSLog-Race-Condition"></p>
<p>注意到这里有好几行显示着不同地址的单例实例。这明显违背了单例的目的，对吧？:]</p>
<p>这个输出向你展示了临界区被执行多次，而它只应该执行一次。现在，固然是你自己强制这样的状况发生，但你可以想像一下这个状况会怎样在无意间发生。</p>
<blockquote>
<p>注意：基于其它你无法控制的系统事件，NSLog 的数量有时会显示多个。线程问题极其难以调试，因为它们往往难以重现。</p>
</blockquote>
<p>要纠正这个状况，实例化代码应该只执行一次，并阻塞其它实例在 <code>if</code> 条件的临界区运行。这刚好就是 <code>dispatch_once</code> 能做的事。</p>
<p>在单例初始化方法中用 <code>dispatch_once</code> 取代 <code>if</code> 条件判断，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    static PhotoManager *sharedPhotoManager = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init];</span><br><span class="line">        NSLog(@&quot;Singleton has memory address at: %@&quot;, sharedPhotoManager);</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [NSMutableArray array];</span><br><span class="line">    &#125;);</span><br><span class="line">    return sharedPhotoManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行你的应用；查看控制台输出，你会看到有且仅有一个单例的实例——这就是你对单例的期望！:]</p>
<p>现在你已经明白了防止竞态条件的重要性，从 <code>AppDelegate.m</code> 中移除 <code>dispatch_async</code> 语句，并用下面的实现替换 <code>PhotoManager</code> 单例的初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    static PhotoManager *sharedPhotoManager = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init];</span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [NSMutableArray array];</span><br><span class="line">    &#125;);</span><br><span class="line">    return sharedPhotoManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_once()</code> 以线程安全的方式执行且仅执行其代码块一次。试图访问临界区（即传递给 <code>dispatch_once</code> 的代码）的不同的线程会在临界区已有一个线程的情况下被阻塞，直到临界区完成为止。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Highlander_dispatch_once.png" alt="Highlander_dispatch_once"></p>
<p>需要记住的是，这只是让访问共享实例线程安全。它绝对没有让类本身线程安全。类中可能还有其它竞态条件，例如任何操纵内部数据的情况。这些需要用其它方式来保证线程安全，例如同步访问数据，你将在下面几个小节看到。</p>
<h2 id="处理读者与写者问题"><a href="#处理读者与写者问题" class="headerlink" title="处理读者与写者问题"></a>处理读者与写者问题</h2><p>线程安全实例不是处理单例时的唯一问题。如果单例属性表示一个可变对象，那么你就需要考虑是否那个对象自身线程安全。</p>
<p>如果问题中的这个对象是一个 Foundation 容器类，那么答案是——“很可能不安全”！Apple 维护一个<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html" target="_blank" rel="noopener">有用且有些心寒的列表</a>，众多的 Foundation 类都不是线程安全的。 <code>NSMutableArray</code>，已用于你的单例，正在那个列表里休息。</p>
<p>虽然许多线程可以同时读取 <code>NSMutableArray</code> 的一个实例而不会产生问题，但当一个线程正在读取时让另外一个线程修改数组就是不安全的。你的单例在目前的状况下不能预防这种情况的发生。</p>
<p>要分析这个问题，看看 <code>PhotoManager.m</code> 中的 <code>addPhoto:</code>，转载如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addPhoto:(Photo *)photo</span><br><span class="line">&#123;</span><br><span class="line">    if (photo) &#123;</span><br><span class="line">        [_photosArray addObject:photo];</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [self postContentAddedNotification];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个<code>写</code>方法，它修改一个私有可变数组对象。</p>
<p>现在看看 <code>photos</code> ，转载如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)photos</span><br><span class="line">&#123;</span><br><span class="line">  return [NSArray arrayWithArray:_photosArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是所谓的<code>读</code>方法，它读取可变数组。它为调用者生成一个不可变的拷贝，防止调用者不当地改变数组，但这不能提供任何保护来对抗当一个线程调用读方法 <code>photos</code> 的同时另一个线程调用写方法 <code>addPhoto:</code> 。</p>
<p>这就是软件开发中经典的<code>读者写者问题</code>。GCD 通过用 <code>dispatch barriers</code> 创建一个<code>读者写者锁</code> 提供了一个优雅的解决方案。</p>
<p>Dispatch barriers 是一组函数，在并发队列上工作时扮演一个串行式的瓶颈。使用 GCD 的障碍（barrier）API 确保提交的 Block 在那个特定时间上是指定队列上唯一被执行的条目。这就意味着所有的先于调度障碍提交到队列的条目必能在这个 Block 执行前完成。</p>
<p>当这个 Block 的时机到达，调度障碍执行这个 Block 并确保在那个时间里队列不会执行任何其它 Block 。一旦完成，队列就返回到它默认的实现状态。 GCD 提供了同步和异步两种障碍函数。</p>
<p>下图显示了障碍函数对多个异步队列的影响：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Dispatch-Barrier.png" alt="Dispatch-Barrier"></p>
<p>注意到正常部分的操作就如同一个正常的并发队列。但当障碍执行时，它本质上就如同一个串行队列。也就是，障碍是唯一在执行的事物。在障碍完成后，队列回到一个正常并发队列的样子。</p>
<p>下面是你何时会——和不会——使用障碍函数的情况：</p>
<ul>
<li>自定义串行队列：一个很坏的选择；障碍不会有任何帮助，因为不管怎样，一个串行队列一次都只执行一个操作。</li>
<li>全局并发队列：要小心；这可能不是最好的主意，因为其它系统可能在使用队列而且你不能垄断它们只为你自己的目的。</li>
<li>自定义并发队列：这对于原子或临界区代码来说是极佳的选择。任何你在设置或实例化的需要线程安全的事物都是使用障碍的最佳候选。</li>
</ul>
<p>由于上面唯一像样的选择是自定义并发队列，你将创建一个你自己的队列去处理你的障碍函数并分开读和写函数。且这个并发队列将允许多个多操作同时进行。</p>
<p>打开 <code>PhotoManager.m</code>，添加如下私有属性到类扩展中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface PhotoManager ()</span><br><span class="line">@property (nonatomic,strong,readonly) NSMutableArray *photosArray;</span><br><span class="line">@property (nonatomic, strong) dispatch_queue_t concurrentPhotoQueue; ///&lt; Add this</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>找到 <code>addPhoto:</code> 并用下面的实现替换它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addPhoto:(Photo *)photo</span><br><span class="line">&#123;</span><br><span class="line">    if (photo) &#123; // 1</span><br><span class="line">        dispatch_barrier_async(self.concurrentPhotoQueue, ^&#123; // 2</span><br><span class="line">            [_photosArray addObject:photo]; // 3</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123; // 4</span><br><span class="line">                [self postContentAddedNotification];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你新写的函数是这样工作的：</p>
<ol>
<li>在执行下面所有的工作前检查是否有合法的相片。</li>
<li>添加写操作到你的自定义队列。当临界区在稍后执行时，这将是你队列中唯一执行的条目。</li>
<li>这是添加对象到数组的实际代码。由于它是一个障碍 Block ，这个 Block 永远不会同时和其它 Block 一起在 concurrentPhotoQueue 中执行。</li>
<li>最后你发送一个通知说明完成了添加图片。这个通知将在主线程被发送因为它将会做一些 UI 工作，所以在此为了通知，你异步地调度另一个任务到主线程。</li>
</ol>
<p>这就处理了写操作，但你还需要实现 <code>photos</code> 读方法并实例化 <code>concurrentPhotoQueue</code> 。</p>
<p>在写者打扰的情况下，要确保线程安全，你需要在 <code>concurrentPhotoQueue</code> 队列上执行读操作。既然你需要从函数返回，你就不能异步调度到队列，因为那样在读者函数返回之前不一定运行。</p>
<p>在这种情况下，<code>dispatch_sync</code> 就是一个绝好的候选。</p>
<p><code>dispatch_sync()</code> 同步地提交工作并在返回前等待它完成。使用 <code>dispatch_sync</code> 跟踪你的调度障碍工作，或者当你需要等待操作完成后才能使用 Block 处理过的数据。如果你使用第二种情况做事，你将不时看到一个 <code>__block</code> 变量写在 <code>dispatch_sync</code> 范围之外，以便返回时在 <code>dispatch_sync</code> 使用处理过的对象。</p>
<p>但你需要很小心。想像如果你调用 <code>dispatch_sync</code> 并放在你已运行着的当前队列。这会导致死锁，因为调用会一直等待直到 Block 完成，但 Block 不能完成（它甚至不会开始！），直到当前已经存在的任务完成，而当前任务无法完成！这将迫使你自觉于你正从哪个队列调用——以及你正在传递进入哪个队列。</p>
<p>下面是一个快速总览，关于在何时以及何处使用 <code>dispatch_sync</code> ：</p>
<ul>
<li>自定义串行队列：在这个状况下要非常小心！如果你正运行在一个队列并调用 <code>dispatch_sync</code> 放在同一个队列，那你就百分百地创建了一个死锁。</li>
<li>主队列（串行）：同上面的理由一样，必须非常小心！这个状况同样有潜在的导致死锁的情况。</li>
<li>并发队列：这才是做同步工作的好选择，不论是通过调度障碍，或者需要等待一个任务完成才能执行进一步处理的情况。</li>
</ul>
<p>继续在 <code>PhotoManager.m</code> 上工作，用下面的实现替换 <code>photos</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)photos</span><br><span class="line">&#123;</span><br><span class="line">    __block NSArray *array; // 1</span><br><span class="line">    dispatch_sync(self.concurrentPhotoQueue, ^&#123; // 2</span><br><span class="line">        array = [NSArray arrayWithArray:_photosArray]; // 3</span><br><span class="line">    &#125;);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是你的读函数。按顺序看看编过号的注释，有这些：</p>
<ol>
<li><code>__block</code> 关键字允许对象在 Block 内可变。没有它，<code>array</code> 在 Block 内部就只是只读的，你的代码甚至不能通过编译。</li>
<li>在 <code>concurrentPhotoQueue</code> 上同步调度来执行读操作。</li>
<li>将相片数组存储在 <code>array</code> 内并返回它。</li>
</ol>
<p>最后，你需要实例化你的 <code>concurrentPhotoQueue</code> 属性。修改 <code>sharedManager</code> 以便像下面这样初始化队列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    static PhotoManager *sharedPhotoManager = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init];</span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">        // ADD THIS:</span><br><span class="line">        sharedPhotoManager-&gt;_concurrentPhotoQueue = dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,</span><br><span class="line">                                                    DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return sharedPhotoManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用 <code>dispatch_queue_create</code> 初始化 <code>concurrentPhotoQueue</code> 为一个并发队列。第一个参数是反向 DNS 样式命名惯例；确保它是描述性的，将有助于调试。第二个参数指定你的队列是串行还是并发。</p>
<blockquote>
<p>注意：当你在网上搜索例子时，你会经常看人们传递 <code>0</code> 或者 <code>NULL</code> 给 <code>dispatch_queue_create</code> 的第二个参数。这是一个创建串行队列的过时方式；明确你的参数总是更好。</p>
</blockquote>
<p>恭喜——你的 <code>PhotoManager</code> 单例现在是线程安全的了。不论你在何处或怎样读或写你的照片，你都有这样的自信，即它将以安全的方式完成，不会出现任何惊吓。</p>
<h2 id="A-Visual-Review-of-Queueing-以动画回顾队列"><a href="#A-Visual-Review-of-Queueing-以动画回顾队列" class="headerlink" title="A Visual Review of Queueing 以动画回顾队列"></a>A Visual Review of Queueing 以动画回顾队列</h2><p>依然没有 100% 地掌握 GCD 的要领？确保你可以使用 GCD 函数轻松地创建简单的例子，使用断点和 <code>NSLog</code> 语句保证自己明白当下发生的情况。</p>
<p>我在下面提供了两个 GIF 动画来帮助你巩固对 <code>dispatch_async</code> 和 <code>dispatch_sync</code> 的理解。包含在每个 GIF 中的代码可以提供视觉辅助；仔细注意 GIF 左边显示代码断点的每一步，以及右边相关队列的状态。</p>
<h3 id="dispatch-sync-回顾"><a href="#dispatch-sync-回顾" class="headerlink" title="dispatch_sync 回顾"></a>dispatch_sync 回顾</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">  dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">      NSLog(@&quot;First Log&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;Second Log&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/dispatch_sync_in_action.gif" alt="dispatch_sync_in_action"></p>
<p>下面是图中几个步骤的说明：</p>
<ol>
<li>主队列一路按顺序执行任务——接着是一个实例化 <code>UIViewController</code> 的任务，其中包含了 <code>viewDidLoad</code> 。</li>
<li><code>viewDidLoad</code> 在主线程执行。</li>
<li>主线程目前在 <code>viewDidLoad</code> 内，正要到达 <code>dispatch_sync</code> 。</li>
<li><code>dispatch_sync</code> Block 被添加到一个全局队列中，将在稍后执行。进程将在主线程挂起直到该 Block 完成。同时，全局队列并发处理任务；要记得 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。</li>
<li>全局队列处理 <code>dispatch_sync</code> Block 加入之前已经出现在队列中的任务。</li>
<li>终于，轮到 <code>dispatch_sync</code> Block 。</li>
<li>这个 Block 完成，因此主线程上的任务可以恢复。</li>
<li><code>viewDidLoad</code> 方法完成，主队列继续处理其他任务。</li>
</ol>
<p><code>dispatch_sync</code> 添加任务到一个队列并等待直到任务完成。<code>dispatch_async</code> 做类似的事情，但不同之处是它不会等待任务的完成，而是立即继续“调用线程”的其它任务。</p>
<h3 id="dispatch-async-回顾"><a href="#dispatch-async-回顾" class="headerlink" title="dispatch_async 回顾"></a>dispatch_async 回顾</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">      NSLog(@&quot;First Log&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;Second Log&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/dispatch_async_in_action.gif" alt="dispatch_async_in_action"></p>
<ol>
<li>主队列一路按顺序执行任务——接着是一个实例化 <code>UIViewController</code> 的任务，其中包含了 <code>viewDidLoad</code> 。</li>
<li><code>viewDidLoad</code> 在主线程执行。</li>
<li>主线程目前在 <code>viewDidLoad</code> 内，正要到达 <code>dispatch_async</code> 。</li>
<li><code>dispatch_async</code> Block 被添加到一个全局队列中，将在稍后执行。</li>
<li><code>viewDidLoad</code> 在添加 <code>dispatch_async</code> 到全局队列后继续进行，主线程把注意力转向剩下的任务。同时，全局队列并发地处理它未完成地任务。记住 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。</li>
<li>添加到 <code>dispatch_async</code> 的代码块开始执行。</li>
<li><code>dispatch_async</code> Block 完成，两个 <code>NSLog</code> 语句将它们的输出放在控制台上。</li>
</ol>
<p>在这个特定的实例中，第二个 <code>NSLog</code> 语句执行，跟着是第一个 <code>NSLog</code> 语句。并不总是这样——着取决于给定时刻硬件正在做的事情，而且你无法控制或知晓哪个语句会先执行。“第一个” <code>NSLog</code> 在某些调用情况下会第一个执行。</p>
<h2 id="下一步怎么走？"><a href="#下一步怎么走？" class="headerlink" title="下一步怎么走？"></a>下一步怎么走？</h2><p>在本教程中，你学习了如何让你的代码线程安全，以及在执行 CPU 密集型任务时如何保持主线程的响应性。</p>
<p>你可以下载<a href="https://koenig-media.raywenderlich.com/uploads/2014/01/GooglyPuff_End_1.zip" target="_blank" rel="noopener"> GooglyPuff 项目</a>，它包含了目前所有本教程中编写的实现。在本教程的<a href="https://github.com/nixzhu/dev-blog/blob/main/posts/2014-05-14-grand-central-dispatch-in-depth-part-2.md" target="_blank" rel="noopener">第二部分</a>，你将继续改进这个项目。</p>
<p>如果你计划优化你自己的应用，那你应该用 <code>Instruments</code> 中的 <code>Time Profile</code> 模版分析你的工作。对这个工具的使用超出了本教程的范围，你可以看看 <a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" target="_blank" rel="noopener">如何使用 Instruments</a> 来得到一个很好的概述。</p>
<p>同时请确保在真实设备上分析，而在模拟器上测试会对程序速度产生非常不准确的印象。</p>
<p>在教程的下一部分，你将更加深入到 GCD 的 API 中，做一些更 Cool 的东西。</p>
<p>如果你有任何问题或评论，可自由地加入下方的讨论！</p>
<hr>
<p>欢迎转载，但请一定注明出处！ <a href="https://github.com/nixzhu/dev-blog" target="_blank" rel="noopener">https://github.com/nixzhu/dev-blog</a></p>
]]></content>
      <categories>
        <category>转载</category>
        <category>翻译</category>
        <category>GCD</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>翻译</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>「转载」GCD 深入理解：第二部分</title>
    <url>/2021/05/07/2014-05-14-grand-central-dispatch-in-depth-part-2/</url>
    <content><![CDATA[<h1 id="GCD-深入理解：第二部分"><a href="#GCD-深入理解：第二部分" class="headerlink" title="GCD 深入理解：第二部分"></a>GCD 深入理解：第二部分</h1><p>本文翻译自 <a href="http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2" target="_blank" rel="noopener">http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2</a></p>
<p>原作者：<a href="http://www.raywenderlich.com/u/Lolgrep" target="_blank" rel="noopener">Derek Selander</a></p>
<p>译者：<a href="http://weibo.com/riven0951" target="_blank" rel="noopener">Riven</a>、<a href="https://twitter.com/nixzhu" target="_blank" rel="noopener">@nixzhu</a></p>
<p>前半部分由 Riven 翻译，但他由于太忙而搁置，后由 NIX 整理校对并翻译后半部分。</p>
<hr>
<a id="more"></a>
<p>欢迎来到 GCD 深入理解系列教程的第二部分（也是最后一部分）。</p>
<p>在本系列的<a href="https://github.com/nixzhu/dev-blog/blob/main/posts/2014-04-19-grand-central-dispatch-in-depth-part-1.md" target="_blank" rel="noopener">第一部分</a>中，你已经学到超过你想像的关于并发、线程以及 GCD 如何工作的知识。通过在初始化时利用 <code>dispatch_once</code>，你创建了一个线程安全的 <code>PhotoManager</code> 单例，而且你通过使用 <code>dispatch_barrier_async</code> 和 <code>dispatch_sync</code> 的组合使得对 <code>Photos</code> 数组的读取和写入都变得线程安全了。</p>
<p>除了上面这些，你还通过利用 <code>dispatch_after</code> 来延迟显示提示信息，以及利用 <code>dispatch_async</code> 将 CPU 密集型任务从 ViewController 的初始化过程中剥离出来异步执行，达到了增强应用的用户体验的目的。</p>
<p>如果你一直跟着第一部分的教程在写代码，那你可以继续你的工程。但如果你没有完成第一部分的工作，或者不想重用你的工程，你可以<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_End_1.zip" target="_blank" rel="noopener">下载第一部分最终的代码</a>。</p>
<p>那就让我们来更深入地探索 GCD 吧！</p>
<h2 id="纠正过早弹出的提示"><a href="#纠正过早弹出的提示" class="headerlink" title="纠正过早弹出的提示"></a>纠正过早弹出的提示</h2><p>你可能已经注意到当你尝试用 Le Internet 选项来添加图片时，一个 <code>UIAlertView</code> 会在图片下载完成之前就弹出，如下如所示：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM.png" alt="Premature Completion Block"></p>
<p>问题的症结在 PhotoManagers 的 <code>downloadPhotoWithCompletionBlock:</code> 里，它目前的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    __block NSError *error;</span><br><span class="line"></span><br><span class="line">    for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSURL *url;</span><br><span class="line">        switch (i) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                  if (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;];</span><br><span class="line"></span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionBlock) &#123;</span><br><span class="line">        completionBlock(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法的最后你调用了 <code>completionBlock</code> ——因为此时你假设所有的照片都已下载完成。但很不幸，此时并不能保证所有的下载都已完成。</p>
<p><code>Photo</code> 类的实例方法用某个 URL 开始下载某个文件并立即返回，但此时下载并未完成。换句话说，当 <code>downloadPhotoWithCompletionBlock:</code> 在其末尾调用 <code>completionBlock</code> 时，它就假设了它自己所使用的方法全都是同步的，而且每个方法都完成了它们的工作。</p>
<p>然而，<code>-[Photo initWithURL:withCompletionBlock:]</code> 是异步执行的，会立即返回——所以这种方式行不通。</p>
<p>因此，只有在所有的图像下载任务都调用了它们自己的 Completion Block 之后，<code>downloadPhotoWithCompletionBlock:</code> 才能调用它自己的 <code>completionBlock</code> 。问题是：你该如何监控并发的异步事件？你不知道它们何时完成，而且它们完成的顺序完全是不确定的。</p>
<p>或许你可以写一些比较 Hacky 的代码，用多个布尔值来记录每个下载的完成情况，但这样做就缺失了扩展性，而且说实话，代码会很难看。</p>
<p>幸运的是， 解决这种对多个异步任务的完成进行监控的问题，恰好就是设计 dispatch_group 的目的。</p>
<h3 id="Dispatch-Groups（调度组）"><a href="#Dispatch-Groups（调度组）" class="headerlink" title="Dispatch Groups（调度组）"></a>Dispatch Groups（调度组）</h3><p>Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个 <code>dispatch_group_t</code> 的实例来记下这些不同的任务。</p>
<p>当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。</p>
<p>第一种是 <code>dispatch_group_wait</code> ，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的。</p>
<p>打开 PhotoManager.m，用下列实现替换 <code>downloadPhotosWithCompletionBlock:</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; // 1</span><br><span class="line"></span><br><span class="line">        __block NSError *error;</span><br><span class="line">        dispatch_group_t downloadGroup = dispatch_group_create(); // 2</span><br><span class="line"></span><br><span class="line">        for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            NSURL *url;</span><br><span class="line">            switch (i) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                    break;</span><br><span class="line">                case 1:</span><br><span class="line">                    url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_group_enter(downloadGroup); // 3</span><br><span class="line">            Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                                  withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                      if (_error) &#123;</span><br><span class="line">                                          error = _error;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                      dispatch_group_leave(downloadGroup); // 4</span><br><span class="line">                                  &#125;];</span><br><span class="line"></span><br><span class="line">            [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); // 5</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123; // 6</span><br><span class="line">            if (completionBlock) &#123; // 7</span><br><span class="line">                completionBlock(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照注释的顺序，你会看到：</p>
<ol>
<li>因为你在使用的是同步的 <code>dispatch_group_wait</code> ，它会阻塞当前线程，所以你要用 <code>dispatch_async</code> 将整个方法放入后台队列以避免阻塞主线程。</li>
<li>创建一个新的 Dispatch Group，它的作用就像一个用于未完成任务的计数器。</li>
<li><code>dispatch_group_enter</code> 手动通知 Dispatch Group 任务已经开始。你必须保证 <code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code> 成对出现，否则你可能会遇到诡异的崩溃问题。</li>
<li>手动通知 Group 它的工作已经完成。再次说明，你必须要确保进入 Group 的次数和离开 Group 的次数相等。</li>
<li><code>dispatch_group_wait</code> 会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值。你可以对此返回值做条件判断以确定是否超出等待周期；然而，你在这里用 <code>DISPATCH_TIME_FOREVER</code> 让它永远等待。它的意思，勿庸置疑就是，永－远－等－待！这样很好，因为图片的创建工作总是会完成的。</li>
<li>此时此刻，你已经确保了，要么所有的图片任务都已完成，要么发生了超时。然后，你在主线程上运行 <code>completionBlock</code> 回调。这会将工作放到主线程上，并在稍后执行。</li>
<li>最后，检查 <code>completionBlock</code> 是否为 nil，如果不是，那就运行它。</li>
</ol>
<p>编译并运行你的应用，尝试下载多个图片，观察你的应用是在何时运行 completionBlock 的。</p>
<blockquote>
<p>注意：如果你是在真机上运行应用，而且网络活动发生得太快以致难以观察 completionBlock 被调用的时刻，那么你可以在 Settings 应用里的开发者相关部分里打开一些网络设置，以确保代码按照我们所期望的那样工作。只需去往 Network Link Conditioner 区，开启它，再选择一个 Profile，“Very Bad Network” 就不错。</p>
</blockquote>
<p>如果你是在模拟器里运行应用，你可以使用 <a href="http://nshipster.com/network-link-conditioner/" target="_blank" rel="noopener">来自 GitHub 的 Network Link Conditioner</a> 来改变网络速度。它会成为你工具箱中的一个好工具，因为它强制你研究你的应用在连接速度并非最佳的情况下会变成什么样。</p>
<p>目前为止的解决方案还不错，但是总体来说，如果可能，最好还是要避免阻塞线程。你的下一个任务是重写一些方法，以便当所有下载任务完成时能异步通知你。</p>
<p>在我们转向另外一种使用 Dispatch Group 的方式之前，先看一个简要的概述，关于何时以及怎样使用有着不同的队列类型的 Dispatch Group ：</p>
<ul>
<li>自定义串行队列：它很适合当一组任务完成时发出通知。</li>
<li>主队列（串行）：它也很适合这样的情况。但如果你要同步地等待所有工作地完成，那你就不应该使用它，因为你不能阻塞主线程。然而，异步模型是一个很有吸引力的能用于在几个较长任务（例如网络调用）完成后更新 UI 的方式。</li>
<li>并发队列：它也很适合 Dispatch Group 和完成时通知。</li>
</ul>
<h3 id="Dispatch-Group，第二种方式"><a href="#Dispatch-Group，第二种方式" class="headerlink" title="Dispatch Group，第二种方式"></a>Dispatch Group，第二种方式</h3><p>上面的一切都很好，但在另一个队列上异步调度然后使用 dispatch_group_wait 来阻塞实在显得有些笨拙。是的，还有另一种方式……</p>
<p>在 PhotoManager.m 中找到 <code>downloadPhotosWithCompletionBlock:</code> 方法，用下面的实现替换它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    // 1</span><br><span class="line">    __block NSError *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">    for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSURL *url;</span><br><span class="line">        switch (i) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_group_enter(downloadGroup); // 2</span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                  if (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup); // 3</span><br><span class="line">                              &#125;];</span><br><span class="line"></span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; // 4</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面解释新的异步方法如何工作：</p>
<ol>
<li>在新的实现里，因为你没有阻塞主线程，所以你并不需要将方法包裹在 <code>async</code> 调用中。</li>
<li>同样的 <code>enter</code> 方法，没做任何修改。</li>
<li>同样的 <code>leave</code> 方法，也没做任何修改。</li>
<li><code>dispatch_group_notify</code> 以异步的方式工作。当 Dispatch Group 中没有任何任务时，它就会执行其代码，那么 <code>completionBlock</code> 便会运行。你还指定了运行 <code>completionBlock</code> 的队列，此处，主队列就是你所需要的。</li>
</ol>
<p>对于这个特定的工作，上面的处理明显更清晰，而且也不会阻塞任何线程。</p>
<h2 id="太多并发带来的风险"><a href="#太多并发带来的风险" class="headerlink" title="太多并发带来的风险"></a>太多并发带来的风险</h2><p>既然你的工具箱里有了这些新工具，你大概做任何事情都想使用它们，对吧？</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Thread_All_The_Code_Meme.jpg" alt="Thread_All_The_Code_Meme"></p>
<p>看看 PhotoManager 中的 <code>downloadPhotosWithCompletionBlock</code> 方法。你可能已经注意到这里的 <code>for</code> 循环，它迭代三次，下载三个不同的图片。你的任务是尝试让 <code>for</code> 循环并发运行，以提高其速度。</p>
<p><code>dispatch_apply</code> 刚好可用于这个任务。</p>
<p><code>dispatch_apply</code> 表现得就像一个 <code>for</code> 循环，但它能并发地执行不同的迭代。这个函数是同步的，所以和普通的 <code>for</code> 循环一样，它只会在所有工作都完成后才会返回。</p>
<p>当在 Block 内计算任何给定数量的工作的最佳迭代数量时，必须要小心，因为过多的迭代和每个迭代只有少量的工作会导致大量开销以致它能抵消任何因并发带来的收益。而被称为<code>跨越式（striding）</code>的技术可以在此帮到你，即通过在每个迭代里多做几个不同的工作。</p>
<blockquote>
<p>译者注：大概就能减少并发数量吧，作者是提醒大家注意并发的开销，记在心里！</p>
</blockquote>
<p>那何时才适合用 <code>dispatch_apply</code> 呢？</p>
<ul>
<li>自定义串行队列：串行队列会完全抵消 <code>dispatch_apply</code> 的功能；你还不如直接使用普通的 <code>for</code> 循环。</li>
<li>主队列（串行）：与上面一样，在串行队列上不适合使用 <code>dispatch_apply</code> 。还是用普通的 <code>for</code> 循环吧。</li>
<li>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</li>
</ul>
<p>回到 <code>downloadPhotosWithCompletionBlock:</code> 并用下列实现替换它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    __block NSError *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">    dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) &#123;</span><br><span class="line"></span><br><span class="line">        NSURL *url;</span><br><span class="line">        switch (i) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_group_enter(downloadGroup);</span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                  if (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup);</span><br><span class="line">                              &#125;];</span><br><span class="line"></span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你的循环现在是并行运行的了；在上面的代码中，在调用 <code>dispatch_apply</code> 时，你用第一次参数指明了迭代的次数，用第二个参数指定了任务运行的队列，而第三个参数是一个 Block。</p>
<p>要知道虽然你有代码保证添加相片时线程安全，但图片的顺序却可能不同，这取决于线程完成的顺序。</p>
<p>编译并运行，然后从 “Le Internet” 添加一些照片。注意到区别了吗？</p>
<p>在真机上运行新代码会稍微更快的得到结果。但我们所做的这些提速工作真的值得吗？</p>
<p>实际上，在这个例子里并不值得。下面是原因：</p>
<ul>
<li>你创建并行运行线程而付出的开销，很可能比直接使用 <code>for</code> 循环要多。若你要以合适的步长迭代非常大的集合，那才应该考虑使用 <code>dispatch_apply</code>。</li>
<li>你用于创建应用的时间是有限的——除非实在太糟糕否则不要浪费时间去提前优化代码。如果你要优化什么，那去优化那些明显值得你付出时间的部分。你可以通过在 Instruments 里分析你的应用，找出最长运行时间的方法。看看 <a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" target="_blank" rel="noopener">如何在 Xcode 中使用 Instruments</a> 可以学到更多相关知识。</li>
<li>通常情况下，优化代码会让你的代码更加复杂，不利于你自己和其他开发者阅读。请确保添加的复杂性能换来足够多的好处。</li>
</ul>
<p>记住，不要在优化上太疯狂。你只会让你自己和后来者更难以读懂你的代码。</p>
<h2 id="GCD-的其他趣味"><a href="#GCD-的其他趣味" class="headerlink" title="GCD 的其他趣味"></a>GCD 的其他趣味</h2><p>等一下！还有更多！有一些额外的函数在不同的道路上走得更远。虽然你不会太频繁地使用这些工具，但在对的情况下，它们可以提供极大的帮助。</p>
<h3 id="阻塞——正确的方式"><a href="#阻塞——正确的方式" class="headerlink" title="阻塞——正确的方式"></a>阻塞——正确的方式</h3><p>这可能听起来像是个疯狂的想法，但你知道 Xcode 已有了测试功能吗？:] 我知道，虽然有时候我喜欢假装它不存在，但在代码里构建复杂关系时编写和运行测试非常重要。</p>
<p>Xcode 里的测试在 <code>XCTestCase</code> 的子类上执行，并运行任何方法签名以 <code>test</code> 开头的方法。测试在主线程运行，所以你可以假设所有测试都是串行发生的。</p>
<p>当一个给定的测试方法运行完成，XCTest 方法将考虑此测试已结束，并进入下一个测试。这意味着任何来自前一个测试的异步代码会在下一个测试运行时继续运行。</p>
<p>网络代码通常是异步的，因此你不能在执行网络获取时阻塞主线程。也就是说，整个测试会在测试方法完成之后结束，这会让对网络代码的测试变得很困难。也就是，除非你在测试方法内部阻塞主线程直到网络代码完成。</p>
<blockquote>
<p>注意：有一些人会说，这种类型的测试不属于集成测试的首选集（Preferred Set）。一些人会赞同，一些人不会。但如果你想做，那就去做。</p>
</blockquote>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Gandalf_Semaphore.png" alt="Gandalf_Semaphore"></p>
<p>导航到 GooglyPuffTests.m 并查看 <code>downloadImageURLWithString:</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)downloadImageURLWithString:(NSString *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    __block BOOL isFinishedDownloading = NO;</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(UIImage *image, NSError *error) &#123;</span><br><span class="line">                                 if (error) &#123;</span><br><span class="line">                                     XCTFail(@&quot;%@ failed. %@&quot;, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 isFinishedDownloading = YES;</span><br><span class="line">                             &#125;];</span><br><span class="line"></span><br><span class="line">    while (!isFinishedDownloading) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种测试异步网络代码的幼稚方式。 While 循环在函数的最后一直等待，直到 <code>isFinishedDownloading</code> 布尔值变成 True，它只会在 Completion Block 里发生。让我们看看这样做有什么影响。</p>
<p>通过在 Xcode 中点击 Product / Test 运行你的测试，如果你使用默认的键绑定，也可以使用快捷键 ⌘+U 来运行你的测试。</p>
<p>在测试运行时，注意 Xcode debug 导航栏里的 CPU 使用率。这个设计不当的实现就是一个基本的 <a href="http://en.wikipedia.org/wiki/Spinlock" target="_blank" rel="noopener">自旋锁</a> 。它很不实用，因为你在 While 循环里浪费了珍贵的 CPU 周期；而且它也几乎没有扩展性。</p>
<blockquote>
<p>译者注：所谓自旋锁，就是某个线程一直抢占着 CPU 不断检查以等到它需要的情况出现。因为现代操作系统都是可以并发运行多个线程的，所以它所等待的那个线程也有机会被调度执行，这样它所需要的情况早晚会出现。</p>
</blockquote>
<p>你可能需要使用前面提到的 Network Link Conditioner ，已便清楚地看到这个问题。如果你的网络太快，那么自旋只会在很短的时间里发生，难以观察。</p>
<blockquote>
<p>译者注：作者反复提到网速太快，而我们还需要对付 GFW，简直泪流满面！</p>
</blockquote>
<p>你需要一个更优雅、可扩展的解决方案来阻塞线程直到资源可用。欢迎来到信号量。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra 介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。</p>
<p>如果你想学到更多关于信号量的知识，看看这个链接<a href="http://greenteapress.com/semaphores/" target="_blank" rel="noopener">它更细致地讨论了信号量理论</a>。如果你是学术型，那可以看一个软件开发中经典的<a href="http://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">哲学家进餐问题</a>，它需要使用信号量来解决。</p>
<p>信号量让你控制多个消费者对有限数量资源的访问。举例来说，如果你创建了一个有着两个资源的信号量，那同时最多只能有两个线程可以访问临界区。其他想使用资源的线程必须在一个…你猜到了吗？…FIFO 队列里等待。</p>
<p>让我们来使用信号量吧！</p>
<p>打开 GooglyPuffTests.m 并用下列实现替换 <code>downloadImageURLWithString:</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)downloadImageURLWithString:(NSString *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    // 1</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(UIImage *image, NSError *error) &#123;</span><br><span class="line">                                 if (error) &#123;</span><br><span class="line">                                     XCTFail(@&quot;%@ failed. %@&quot;, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line"></span><br><span class="line">                                 // 2</span><br><span class="line">                                 dispatch_semaphore_signal(semaphore);</span><br><span class="line">                             &#125;];</span><br><span class="line"></span><br><span class="line">    // 3</span><br><span class="line">    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);</span><br><span class="line">    if (dispatch_semaphore_wait(semaphore, timeoutTime)) &#123;</span><br><span class="line">        XCTFail(@&quot;%@ timed out&quot;, URLString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来说明你代码中的信号量是如何工作的：</p>
<ol>
<li>创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为 0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。</li>
<li>在 Completion Block 里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。</li>
<li>这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过 10 秒钟就会返回——一个平衡点！</li>
</ol>
<p>再次运行测试。只要你有一个正常工作的网络连接，这个测试就会马上成功。请特别注意 CPU 的使用率，与之前使用自旋锁的实现作个对比。</p>
<p>关闭你的网络链接再运行测试；如果你在真机上运行，就打开飞行模式。如果你的在模拟器里运行，你可以直接断开 Mac 的网络链接。测试会在 10 秒后失败。这很棒，它真的能按照预想的那样工作！</p>
<p>还有一些琐碎的测试，但如果你与一个服务器组协同工作，那么这些基本的测试能够防止其他人就最新的网络问题对你说三道四。</p>
<h3 id="使用-Dispatch-Source"><a href="#使用-Dispatch-Source" class="headerlink" title="使用 Dispatch Source"></a>使用 Dispatch Source</h3><p>GCD 的一个特别有趣的特性是 Dispatch Source，它基本上就是一个低级函数的 grab-bag ，能帮助你去响应或监测 Unix 信号、文件描述符、Mach 端口、VFS 节点，以及其它晦涩的东西。所有这些都超出了本教程讨论的范围，但你可以通过实现一个 Dispatch Source 对象并以一个相当奇特的方式来使用它来品尝那些晦涩的东西。</p>
<p>第一次使用 Dispatch Source 可能会迷失在如何使用一个源，所以你需要知晓的第一件事是 <code>dispatch_source_create</code> 如何工作。下面是创建一个源的函数原型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_source_t dispatch_source_create(</span><br><span class="line">   dispatch_source_type_t type,</span><br><span class="line">   uintptr_t handle,</span><br><span class="line">   unsigned long mask,</span><br><span class="line">   dispatch_queue_t queue);</span><br></pre></td></tr></table></figure>
<p>第一个参数是 <code>dispatch_source_type_t</code> 。这是最重要的参数，因为它决定了 handle 和 mask 参数将会是什么。你可以查看 <a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/constant_group/Dispatch_Source_Type_Constants" target="_blank" rel="noopener">Xcode 文档</a> 得到哪些选项可用于每个 <code>dispatch_source_type_t</code> 参数。</p>
<p>下面你将监控 <code>DISPATCH_SOURCE_TYPE_SIGNAL</code> 。如<a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/c/macro/DISPATCH_SOURCE_TYPE_SIGNAL&quot;" target="_blank" rel="noopener">文档所显示的</a>：</p>
<p>一个监控当前进程信号的 Dispatch Source。 handle 是信号编号，mask 未使用（传 0 即可）。</p>
<p>这些 Unix 信号组成的列表可在头文件 <a href="http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/signal.h" target="_blank" rel="noopener">signal.h</a> 中找到。在其顶部有一堆 <code>#define</code> 语句。你将监控此信号列表中的 <code>SIGSTOP</code> 信号。这个信号将会在进程接收到一个无法回避的暂停指令时被发出。在你用 LLDB 调试器调试应用时你使用的也是这个信号。</p>
<p>去往 PhotoCollectionViewController.m 并添加如下代码到 <code>viewDidLoad</code> 的顶部，就在 <code>[super viewDidLoad]</code> 下面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">  // 1</span><br><span class="line">  #if DEBUG</span><br><span class="line">      // 2</span><br><span class="line">      dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">      // 3</span><br><span class="line">      static dispatch_source_t source = nil;</span><br><span class="line"></span><br><span class="line">      // 4</span><br><span class="line">      __typeof(self) __weak weakSelf = self;</span><br><span class="line"></span><br><span class="line">      // 5</span><br><span class="line">      static dispatch_once_t onceToken;</span><br><span class="line">      dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">          // 6</span><br><span class="line">          source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, queue);</span><br><span class="line"></span><br><span class="line">          // 7</span><br><span class="line">          if (source)</span><br><span class="line">          &#123;</span><br><span class="line">              // 8</span><br><span class="line">              dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">                  // 9</span><br><span class="line">                  NSLog(@&quot;Hi, I am: %@&quot;, weakSelf);</span><br><span class="line">              &#125;);</span><br><span class="line">              dispatch_resume(source); // 10</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  #endif</span><br><span class="line"></span><br><span class="line">  // The other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码有点儿复杂，所以跟着注释一步步走，看看到底发生了什么：</p>
<ol>
<li>最好是在 DEBUG 模式下编译这些代码，因为这会给“有关方面（Interested Parties）”很多关于你应用的洞察。 :]</li>
<li>Just to mix things up，你创建了一个 <code>dispatch_queue_t</code> 实例变量而不是在参数上直接使用函数。当代码变长，分拆有助于可读性。</li>
<li>你需要 <code>source</code> 在方法范围之外也可被访问，所以你使用了一个 static 变量。</li>
<li>使用 <code>weakSelf</code> 以确保不会出现保留环（Retain Cycle）。这对 <code>PhotoCollectionViewController</code> 来说不是完全必要的，因为它会在应用的整个生命期里保持活跃。然而，如果你有任何其它会消失的类，这就能确保不会出现保留环而造成内存泄漏。</li>
<li>使用 <code>dispatch_once</code> 确保只会执行一次 Dispatch Source 的设置。</li>
<li>初始化 <code>source</code> 变量。你指明了你对信号监控感兴趣并提供了 <code>SIGSTOP</code> 信号作为第二个参数。进一步，你使用主队列处理接收到的事件——很快你就好发现为何要这样做。</li>
<li>如果你提供的参数不合格，那么 Dispatch Source 对象不会被创建。也就是说，在你开始在其上工作之前，你需要确保已有了一个有效的 Dispatch Source 。</li>
<li>当你收到你所监控的信号时，<code>dispatch_source_set_event_handler</code> 就会执行。之后你可以在其 Block 里设置合适的逻辑处理器（Logic Handler）。</li>
<li>一个基本的 <code>NSLog</code> 语句，它将对象打印到控制台。</li>
<li>默认的，所有源都初始为暂停状态。如果你要开始监控事件，你必须告诉源对象恢复活跃状态。</li>
</ol>
<p>编译并运行应用；在调试器里暂停并立即恢复应用，查看控制台，你会看到这个来自黑暗艺术的函数确实可以工作。你看到的大概如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2014-03-29 17:41:30.610 GooglyPuff[8181:60b] Hi, I am:</span><br></pre></td></tr></table></figure>
<p>你的应用现在具有调试感知了！这真是超级棒，但在真实世界里该如何使用它呢？</p>
<p>你可以用它去调试一个对象并在任何你想恢复应用的时候显示数据；你同样能给你的应用加上自定义的安全逻辑以便在恶意攻击者将一个调试器连接到你的应用上时保护它自己（或用户的数据）。</p>
<blockquote>
<p>译者注：好像挺有用！</p>
</blockquote>
<p>一个有趣的主意是，使用此方式的作为一个堆栈追踪工具去找到你想在调试器里操纵的对象。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/What_Meme.jpg" alt="What_Meme"></p>
<p>稍微想想这个情况。当你意外地停止调试器，你几乎从来都不会在所需的栈帧上。现在你可以在任何时候停止调试器并在你所需的地方执行代码。如果你想在你的应用的某一点执行的代码非常难以从调试器访问的话，这会非常有用。有机会试试吧！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/I_See_What_You_Did_Meme.png" alt="I_See_What_You_Did_Meme"></p>
<p>将一个断点放在你刚添加在 viewDidLoad 里的事件处理器的 <code>NSLog</code> 语句上。在调试器里暂停，然后再次开始；应用会到达你添加的断点。现在你深入到你的 PhotoCollectionViewController 方法深处。你可以访问 PhotoCollectionViewController 的实例得到你关心的内容。非常方便！</p>
<blockquote>
<p>注意：如果你还没有注意到在调试器里的是哪个线程，那现在就看看它们。主线程总是第一个被 libdispatch 跟随，它是 GCD 的坐标，作为第二个线程。之后，线程计数和剩余线程取决于硬件在应用到达断点时正在做的事情。</p>
</blockquote>
<p>在调试器里，键入命令：<code>po [[weakSelf navigationItem] setPrompt:@&quot;WOOT!&quot;]</code></p>
<p>然后恢复应用的执行。你会看到如下内容：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Dispatch_Sources_Xcode_Breakpoint_Console.png" alt="Dispatch_Sources_Xcode_Breakpoint_Console"></p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/Dispatch_Sources_Debugger_Updating_UI.png" alt="Dispatch_Sources_Debugger_Updating_UI"></p>
<p>使用这个方法，你可以更新 UI、查询类的属性，甚至是执行方法——所有这一切都不需要重启应用并到达某个特定的工作状态。相当优美吧！</p>
<blockquote>
<p>译者注：发挥这一点，是可以做出一些调试库的吧？</p>
</blockquote>
<h2 id="之后又该往何处去？"><a href="#之后又该往何处去？" class="headerlink" title="之后又该往何处去？"></a>之后又该往何处去？</h2><p>你可以<a href="https://koenig-media.raywenderlich.com/uploads/2014/01/GooglyPuff-Final.zip" target="_blank" rel="noopener">在此下载最终的项目</a>。</p>
<p>我讨厌再次提及此主题，但你真的要看看 <a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" target="_blank" rel="noopener">如何使用 Instruments</a> 教程。如果你计划优化你的应用，那你一定要学会使用它。请注意 Instruments 擅长于分析相对执行：比较哪些区域的代码相对于其它区域的代码花费了更长的时间。如果你尝试计算出某个方法实际的执行时间，那你可能需要拿出更多的自酿的解决方案（Home-brewed Solution）。</p>
<p>同样请看看 <a href="http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues" target="_blank" rel="noopener">如何使用 NSOperations 和 NSOperationQueues</a> 吧，它们是建立在 GCD 之上的并发技术。大体来说，如果你在写简单的用过就忘的任务，那它们就是使用 GCD 的最佳实践，。NSOperations 提供更好的控制、处理大量并发操作的实现，以及一个以速度为代价的更加面向对象的范例。</p>
<p>记住，除非你有特别的原因要往下流走（译者的玩笑：即使用低级别 API），否则永远应尝试并坚持使用高级的 API。如果你想学到更多或想做某些非常非常“有趣”的事情，那你就应该冒险进入 Apple 的黑暗艺术。</p>
<p>祝你好运，玩得开心！有任何问题或反馈请在下方的讨论区贴出！</p>
<hr>
<p>欢迎转载，但请一定注明出处：<a href="https://github.com/nixzhu/dev-blog" target="_blank" rel="noopener">https://github.com/nixzhu/dev-blog</a> ！</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>翻译</category>
        <category>GCD</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>翻译</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>「转载」能偶尔用上的 awk</title>
    <url>/2021/05/07/2016-08-11-awk/</url>
    <content><![CDATA[<h1 id="能偶尔用上的-awk"><a href="#能偶尔用上的-awk" class="headerlink" title="能偶尔用上的 awk"></a>能偶尔用上的 awk</h1><p>英雄总有用武之地。</p>
<blockquote>
<p>原文：<a href="https://github.com/nixzhu/dev-blog/blob/main/posts/2016-08-11-awk.md" target="_blank" rel="noopener">能偶尔用上的 awk</a><br>作者：<a href="https://twitter.com/nixzhu" target="_blank" rel="noopener">@nixzhu</a></p>
</blockquote>
<hr>
<a id="more"></a>
<p>对于 app 内的图片，我们可用其名字获取：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"test_image"</span>)</span><br></pre></td></tr></table></figure>
<p>但这样并不安全，我们可能拼错图片的名字，图片本身也可能被删除。而如果我们要在多处使用同一张图片，就更要时时小心。</p>
<p>我们可以用一个 UIImage 的扩展来消除我们的担忧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> xxx_testImage: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIImage</span>(named: <span class="string">"test_image"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们使用时，只需：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>.xxx_testImage</span><br></pre></td></tr></table></figure>
<p>这样在输入时，除了编辑器会提供自动补全外，编译器也能保证我们不会输入不存在的图片名。</p>
<p>但我们还不能保证图片不会被从我们的 app 工程里删除，所以我们应该加一个测试，保证每次测试运行时，app 所需要的所有图片都能正常访问。</p>
<p>这些都不是问题，问题是，我们可能并没有一开始就考虑这个问题，因此，app 已经累计了很多图片，手动生成这个 extension 实在没有乐趣，自然，轮到脚本登场。（我知道有人会推荐 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a>，不过它做了太多事，对本地化字符串的生成还不太好，也依赖 CocoaPod，所有并不太喜欢）</p>
<p>我们打开终端，先进入 app 的 Images.xcassets 目录里：<code>ls -l</code>，输出类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total 8</span><br><span class="line">drwxr-xr-x  22 nix  staff  748 12 16  2015 AppIcon.appiconset</span><br><span class="line">-rw-r--r--   1 nix  staff   62  5  5 17:06 Contents.json</span><br><span class="line">drwxr-xr-x   4 nix  staff  136  4  3  2015 bubble_body.imageset</span><br><span class="line">drwxr-xr-x   4 nix  staff  136  4  3  2015 bubble_left_tail.imageset</span><br><span class="line">drwxr-xr-x   4 nix  staff  136  4  3  2015 bubble_right_tail.imageset</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可见，只有<code>imageset</code>后缀的才是正常的图片，因此我们 grep 过滤一下：<code>ls -l | grep imageset</code>，输出类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x   4 nix  staff  136  4  3  2015 bubble_body.imageset</span><br><span class="line">drwxr-xr-x   4 nix  staff  136  4  3  2015 bubble_left_tail.imageset</span><br><span class="line">drwxr-xr-x   4 nix  staff  136  4  3  2015 bubble_right_tail.imageset</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意上面命令中的<code>|</code>为管道，它的作用是将其左边命令的输出作为右边命令的输入。</p>
<p>然后就轮到 awk 出场：<code>ls -l | grep imageset ｜ awk &#39;{print $9}&#39;</code>，将第 9 列切割出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bubble_body.imageset</span><br><span class="line">bubble_left_tail.imageset</span><br><span class="line">bubble_right_tail.imageset</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意 awk 默认使用空白符作为分隔符，<code>$9</code> 表示第 9 列。</p>
<p>我们离得到图片名字列表又近了一步，继续 awk：<code>ls -l | grep imageset | awk &#39;{print $9}&#39; | awk -F&quot;.&quot; &#39;{print $1}&#39;</code>。</p>
<p>这次我们增加了<code>awk -F&quot;.&quot; &#39;{print $1}&#39;</code>，awk 默认用空白符做分割符，但这一句里我们指定用<code>.</code>做分割符，然后输出第一列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bubble_body</span><br><span class="line">bubble_left_tail</span><br><span class="line">bubble_right_tail</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样我们就得到图片名字列表了。接下来我们想把图片名字做一个变换，️以符合 Swift 命名规范，例如将<code>bubble_body</code>变成<code>bubbleBody</code>。</p>
<p>因此，继续追加一个 awk 命令：<code>ls -l | grep imageset | awk &#39;{print $9}&#39; | awk -F&quot;.&quot; &#39;{print $1}&#39; | awk -F&quot;_&quot; &#39;{out=&quot;&quot;;for(i=1;i&lt;=NF;i++){if(i==1){out=$i}else{out=out&quot;&quot;toupper(substr($i,1,1))substr($i,2)}};print out}&#39;</code></p>
<p>这次比较复杂，先指定用<code>_</code>做分割符；然后定义了一个变量<code>out=&quot;&quot;</code>，看起来就是个空字符串；之后进入循环，以<code>i</code>为变量；其中<code>NF</code>是 awk 的内置变量，表示当前行的“列数”，这里我们用<code>_</code>做分割符，因此第一行有两列，NF 就为 2，第二行有三列，N F 就等于 3，awk 是一行一行地处理输入的，所以每一行的 NF 可以不同；在 for 循环的循环体里（注意大括号），我们先判断 i 是否为 1，是 1 的话就直接赋值给 out，否则就将其第一个字母变为大写再追加到 out 后面，这里的代码比较难看，<code>toupper(substr($i,1,1))</code>中的 substr 从第 i 列取出第一个字符然后用 toupper 变为大写，接着<code>substr($i,2)</code>表示剩下的字符串，前面的<code>out=out&quot;&quot;...</code>表示给 out 追加一个空白字符和之后的大写字母和剩下的字符串，这样就实现了首字母大写的功能。</p>
<p>这很麻烦，但我不知道 awk 里是否有更方便的函数，但这里的代码能很工作，于是生成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bubbleBody</span><br><span class="line">bubbleLeftTail</span><br><span class="line">bubbleRightTail</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>为了之后的代码生成，我们需要没有改变前的名字，因此再修改一下上面的命令：<br><code>ls -l | grep imageset | awk &#39;{print $9}&#39; | awk -F&quot;.&quot; &#39;{print $1}&#39; | awk -F&quot;_&quot; &#39;{out=$0&quot; &quot;;for(i=1;i&lt;=NF;i++){if(i==1){out=$i}else{out=out&quot;&quot;toupper(substr($i,1,1))substr($i,2)}};print out}&#39;</code></p>
<p>只有一点改变，初始化 out 时用了 $0（当前行） 和一个空格，得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bubble_body bubbleBody</span><br><span class="line">bubble_left_tail bubbleLeftTail</span><br><span class="line">bubble_right_tail bubbleRightTail</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最后终于轮到代码生成了，依然再加一段 awk：<code>ls -l | grep imageset | awk &#39;{print $9}&#39; | awk -F&quot;.&quot; &#39;{print $1}&#39; | awk -F&quot;_&quot; &#39;{out=$0&quot; &quot;;for(i=1;i&lt;=NF;i++){if(i==1){out=$i}else{out=out&quot;&quot;toupper(substr($i,1,1))substr($i,2)}};print out}&#39; | awk &#39;{print &quot;static var xxx_&quot;$2&quot;: UIImage {\n\treturn UIImage(named: \&quot;&quot;$1&quot;\&quot;)!\n}\n&quot;}&#39;</code></p>
<p>可得到：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> xxx_bubbleBody: <span class="type">UIImage</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(named: <span class="string">"bubble_body"</span>)!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> xxx_bubbleLeftTail: <span class="type">UIImage</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(named: <span class="string">"bubble_left_tail"</span>)!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> xxx_bubbleRightTail: <span class="type">UIImage</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(named: <span class="string">"bubble_right_tail"</span>)!</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们的目的就基本达到。毫不夸张地说，我们只用“一句代码”就搞定了。</p>
<p>然后就是搜索项目代码中使用 UIImage 的代码，将它们替换为更安全的用法，并写一个测试，在测试里访问所有的图片，当然，测试代码也可用类似上面的脚本去生成。</p>
<p>我并非 awk 专家，不过我建议所有程序员都学习 grep、awk 以及本文并未提及的 sed 这三个文本处理工具。不用很熟悉，知道它们如何工作即可，用时再查手册。</p>
<p>最终的脚本大概如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate UIImage extension for images assets</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: ./ios_static_images.sh path_to_images_assets"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$1</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: ./ios_static_images.sh path_to_images_assets"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"extension UIImage &#123;"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">ls -l <span class="variable">$1</span> | \</span><br><span class="line">grep imageset | \</span><br><span class="line">awk <span class="string">'&#123; print $9; &#125;'</span> | \</span><br><span class="line">awk -F<span class="string">"."</span> <span class="string">'&#123; print $1; &#125;'</span> | \</span><br><span class="line">awk -F<span class="string">"_"</span> <span class="string">'&#123; \</span></span><br><span class="line"><span class="string">    out = $0" "; \</span></span><br><span class="line"><span class="string">    for (i = 1; i &lt;= NF; i++) &#123; \</span></span><br><span class="line"><span class="string">        if (i == 1) &#123; \</span></span><br><span class="line"><span class="string">            out = out $i; \</span></span><br><span class="line"><span class="string">        &#125; else &#123; \</span></span><br><span class="line"><span class="string">            out = out toupper(substr($i,1,1)) substr($i,2); \</span></span><br><span class="line"><span class="string">        &#125; \</span></span><br><span class="line"><span class="string">    &#125;; \</span></span><br><span class="line"><span class="string">    print out \</span></span><br><span class="line"><span class="string">&#125;'</span> | \</span><br><span class="line">awk <span class="string">'&#123; \</span></span><br><span class="line"><span class="string">    print "    static var xxx_" $2 ": UIImage &#123;"; \</span></span><br><span class="line"><span class="string">    print "        return UIImage(named: \"" $1 "\")!"; \</span></span><br><span class="line"><span class="string">    print "    &#125;\n"; \</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&#125;"</span></span><br></pre></td></tr></table></figure>
<hr>
<p>欢迎转载，但请一定注明出处！ <a href="https://github.com/nixzhu/dev-blog" target="_blank" rel="noopener">https://github.com/nixzhu/dev-blog</a></p>
]]></content>
      <categories>
        <category>转载</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>「转载」用 Swift 实现轻量的属性监听系统</title>
    <url>/2021/05/07/2015-04-30-property-listener/</url>
    <content><![CDATA[<h1 id="用-Swift-实现轻量的属性监听系统"><a href="#用-Swift-实现轻量的属性监听系统" class="headerlink" title="用 Swift 实现轻量的属性监听系统"></a>用 Swift 实现轻量的属性监听系统</h1><blockquote>
<p>原文：<a href="https://github.com/nixzhu/dev-blog/blob/main/posts/2015-04-30-property-listener.md" target="_blank" rel="noopener">用 Swift 实现轻量的属性监听系统</a></p>
</blockquote>
<p>本文的主要目的是解决客户端开发中对“模型的一处修改，UI 要多处更新”的问题。当然，我们要知晓解决方案的细节和思考过程，以及看到其能达到的效果。我们会用到函数式编程的思想，以及伟大的“泛型”。请相信我，我们并非为了使用新技术而使用新技术。如果一个问题有更好的方法去解决，那为何不替换掉旧方法呢？</p>
<p>作者：<a href="https://twitter.com/nixzhu" target="_blank" rel="noopener">@nixzhu</a></p>
<hr>
<a id="more"></a>
<p>假如你正在写的 App 是有用户系统的，也就是用户需要管理自己的信息，如修改名字、头发颜色之类的。</p>
<p>单独拿名字来说，除开在修改界面，可能在系统的其他界面也会使用到它，这就涉及到在更新名字后再更新其他界面的问题。</p>
<p>你的第一直觉是什么呢？多半是使用通知，也就是 NSNotification。这是一种很好的办法，虽然逻辑松散，写起来有些麻烦。比如要定义一个通知名，发送通知，各界面都监听通知再处理，等等。</p>
<p>例如，对于如下 3 个界面，都有显示名字。通过 push，用户可以在第 3 个界面里修改名字，这就需要更新这 3 个界面的名字，不然用户 pop 返回时就会觉得奇怪。</p>
<p><img src="https://github.com/nixzhu/dev-blog/raw/master/images/property_listener_ui.png" alt="UI"></p>
<p>假如我们的名字放在一个叫做 UserInfo 的类里（访问和修改都使用单例），如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">UserInfo</span>()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">NameChanged</span> = <span class="string">"UserInfo.Notification.NameChanged"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"NIX"</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="type">NSNotificationCenter</span>.defaultCenter().postNotificationName(<span class="type">Notification</span>.<span class="type">NameChanged</span>, object: name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时我们定义了一个通知。在 name 被改变后就发出这个通知，并把 name 传出去。</p>
<p>三个界面分别为 FirstViewController、SecondViewController、ThirdViewController，都有一个 button 在正中间。其中前两个负责 push，最后一个点击后可以改名字。因此，对于 FirstViewController 来说：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> nameButton: <span class="type">UIButton!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        title = <span class="string">"First"</span></span><br><span class="line"></span><br><span class="line">        nameButton.setTitle(<span class="type">UserInfo</span>.sharedInstance.name, forState: .<span class="type">Normal</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="string">"updateUI:"</span>, name: <span class="type">UserInfo</span>.<span class="type">Notification</span>.<span class="type">NameChanged</span>, object: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUI</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> name = notification.object <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">            nameButton.setTitle(name, forState: .<span class="type">Normal</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了加载时设置 button 之外，我们还要监听通知，并在 name 被改变时更新 button 的 title。</p>
<p>SecondViewController 的代码类似 FirstViewController，不赘述。</p>
<p>对于 ThirdViewController，除了设置和通知外，还有一个 button 的 target-action 方法用于修改名字，也很简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">changeName</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="string">"Change name"</span>, message: <span class="literal">nil</span>, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line"></span><br><span class="line">    alertController.addTextFieldWithConfigurationHandler &#123; (textField) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        textField.placeholder = <span class="keyword">self</span>.nameButton.titleLabel?.text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> action: <span class="type">UIAlertAction</span> = <span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>) &#123; action -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> textField = alertController.textFields?.first <span class="keyword">as</span>? <span class="type">UITextField</span> &#123;</span><br><span class="line">            <span class="type">UserInfo</span>.sharedInstance.name = textField.text <span class="comment">// 更新名字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    alertController.addAction(action)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.presentViewController(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似乎并不麻烦，看起来也算合理，那上面这样写有什么问题？我想答案是太重复。为了减少重复，我们来增加自己的知识，让脑神经稍微痛苦一点，好形成一些新的联结或破坏一些旧的联结。</p>
<p>我们可以传递闭包给 UserInfo，它将闭包存储起来，并在 name 被改变时调用这些闭包，这样闭包里的操作就会被执行了。自然，我们要在闭包里更新 UI。</p>
<p>这样，新的 UserInfo 如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">UserInfo</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">NameListener</span> = <span class="type">String</span> -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nameListeners = [<span class="type">NameListener</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">bindNameListener</span>(<span class="title">nameListener</span>: <span class="title">NameListener</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.sharedInstance.nameListeners.append(nameListener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">bindAndFireNameListener</span>(<span class="title">nameListener</span>: <span class="title">NameListener</span>) </span>&#123;</span><br><span class="line">        bindNameListener(nameListener)</span><br><span class="line"></span><br><span class="line">        nameListener(<span class="keyword">self</span>.sharedInstance.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"NIX"</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            nameListeners.<span class="built_in">map</span> &#123; $<span class="number">0</span>(<span class="keyword">self</span>.name) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们删除了通知相关的代码，定义了 NameListener，增加了一个 nameListeners 用于保存监听者闭包，并实现两个类方法 <code>bindNameListener</code> 和 <code>bindAndFireNameListener</code> 来保存（并触发）监听者闭包。而在 name 的 didSet 里，我们只需要调用每个闭包即可，这里用了 map，也很直观。</p>
<p>那么 FirstViewController 的代码就简化为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> nameButton: <span class="type">UIButton!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        title = <span class="string">"First"</span></span><br><span class="line"></span><br><span class="line">        <span class="type">UserInfo</span>.bindAndFireNameListener &#123; name <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.nameButton.setTitle(name, forState: .<span class="type">Normal</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们删除了通知相关的代码和 <code>updateUI</code> 方法，只需要将我们更新 UI 的闭包绑定到 UserInfo 即可。因为我们也需要初始设置 button，所以用了 <code>bindAndFireNameListener</code>。</p>
<p>SecondViewController 和 ThirdViewController 的修改类似 FirstViewController，不赘述。</p>
<p>这样一来，设置 UI 的操作和更新 UI 的操作就被很好地“融合”到一起了。代码比第一版的的逻辑性更强，VC 也更简单。</p>
<p>但是还有一个问题， UserInfo 里的 nameListeners 数组可能会越来越长，比如用户不断地 push/pop。虽然在有限的时间里，nameListeners 的数量不会变的非常大，程序的性能可以接受，但这毕竟是一种浪费（内存和 CPU 时间）。我们再来解决这个问题。</p>
<p>问题关键是我们的闭包并没有名字，我们无法将其找出并删除。例如对于 SecondViewController 来说，第一次进入它时，bindAndFireNameListener 执行了一次，如果 pop 再 push，它又执行了一次。那么，第一次被绑定的闭包其实没有任何用处了，因为第二次看到的 VC 是新生成的。如果我们能为闭包取名字，我们就能在第二次进入时用新的闭包替换旧的闭包，从而保证 nameListeners 的数量不会无限制的增长，也就不会浪费内存和 CPU 了。</p>
<p>为了限制 nameListeners 的无限制增长，我们可以将 nameListeners 改成 nameListenerSet，类型从 Array 改成 Set，这样绑定时就能保证其中“同一个地方添加的闭包”最多只有一个。但很不幸，我们无法将闭包 NameListener 放入 Set，因为闭包无法实现 Hashable 协议，而这正是使用 Set 所需要的。</p>
<p>似乎陷入困境了！</p>
<p>不要恐慌。虽然一个单纯的闭包无法实现 Hashable，但我们可以将其再封装一次，例如放入一个 struct 里，我们再让 struct 实现 Hashable 协议。前面刚提到过，闭包无法实现 Hashable，那么我们必然要在 struct 放入另外一个可以 Hashable 的属性来帮助我们的 struct 实现 Hashable。也就是：为闭包取一个名字。因此，我们新的 UserInfo 如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: UserInfo.NameListener, rhs: UserInfo.NameListener)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name == rhs.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">UserInfo</span>()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NameListener</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">typealias</span> <span class="type">Action</span> = <span class="type">String</span> -&gt; <span class="type">Void</span></span><br><span class="line">        <span class="keyword">let</span> action: <span class="type">Action</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name.hashValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nameListenerSet = <span class="type">Set</span>&lt;<span class="type">NameListener</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">bindNameListener</span>(<span class="title">name</span>: <span class="title">String</span>, <span class="title">action</span>: <span class="title">NameListener</span>.<span class="title">Action</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> nameListener = <span class="type">NameListener</span>(name: name, action: action)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.sharedInstance.nameListenerSet.insert(nameListener) <span class="comment">// TODO：需要处理同名替换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">bindAndFireNameListener</span>(<span class="title">name</span>: <span class="title">String</span>, <span class="title">action</span>: <span class="title">NameListener</span>.<span class="title">Action</span>) </span>&#123;</span><br><span class="line">        bindNameListener(name, action: action)</span><br><span class="line"></span><br><span class="line">        action(<span class="keyword">self</span>.sharedInstance.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"NIX"</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> nameListener <span class="keyword">in</span> nameListenerSet &#123;</span><br><span class="line">                nameListener.action(name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们设计了一个新的 struct：NameListener，它有一个 name 表明它是谁，原来的闭包就变成了 action，也很合理。为了满足 Hashable 协议，我们用 name.hashValue 来作为 struct 的 hashValue。另外，因为 Hashable 继承于 Equatable，我们也要实现一个 <code>func ==</code>。</p>
<p>另外，为了 API 更好使用，我们将 <code>bindNameListener</code> 与 <code>bindAndFireNameListener</code> 改造为接受一个 name 和一个 action 作为参数，在方法内部才“合成”一个 nameListener，这样 API 在使用时看起来会更合理，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UserInfo</span>.bindAndFireNameListener(<span class="string">"FirstViewController.nameButton"</span>) &#123; name <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.nameButton.setTitle(name, forState: .<span class="type">Normal</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只在闭包前面增加了一个闭包的“名字”而已。</p>
<p>最后，UserInfo 的 name 的 didSet 里要稍微修改，因为是 Set，没法 map 了，那就改成最传统的循环吧。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>我们面临一个“一处修改，多处更新”的问题，起初时我们用通知来实现，并无不可。之后我们想要更合理（或者更酷）一些，于是利用 Swift 的闭包特性实现了一个监听者模式。最后，我们使用包装的办法，解决了监听者可能会无限制增长的问题。</p>
<p>而这一切的目的，都是为了让代码更有逻辑性，并减少 VC 的代码量。</p>
<p>最后的最后，UserInfo 里可能会包含其他类型的属性，例如 <code>var hairColor: UIColor</code>，如果它也面临“一处修改，多处更新”的问题，那么我们也需要实现一个 HairColorListener 吗？</p>
<p>也许我们该利用 Swift 的泛型编写一个更加合理的 Listener，你说对吧？</p>
<p>非最终的效果请查看并运行 Demo 代码：<a href="https://github.com/nixzhu/PropertyListenerDemo" target="_blank" rel="noopener">https://github.com/nixzhu/PropertyListenerDemo</a>。如果你愿意的话，可以查看 git 的各个 commit 以得到整个过程。</p>
<p>（最终的）更好的泛型实现在分支 <a href="https://github.com/nixzhu/PropertyListenerDemo/tree/generic" target="_blank" rel="noopener">generic</a> 里，它的关键就是利用泛型实现一个 <code>class Listenable&lt;T&gt;</code> 以对应任何类型的属性，它内部再实现监听系统即可。当然，我们也让监听者支持泛型（<code>struct Listener&lt;T&gt;</code>）以便执行 action 时可以传递任意类型的参数。还有少许细节不同，例如 UserInfo 里直接使用 static 变量更方便，不需要用一个单独的单例再访问其属性。</p>
<hr>
<p>欢迎转载，但请一定注明出处！ <a href="https://github.com/nixzhu/dev-blog" target="_blank" rel="noopener">https://github.com/nixzhu/dev-blog</a></p>
]]></content>
      <categories>
        <category>转载</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom利器-markdown图床搭建</title>
    <url>/2017/11/19/ImgStoService/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/05a2feada472159cfe5833ae921922c0.png" alt="Atom"></p>
<a id="more"></a>
<p>最近在用markdown粘贴图片总是很麻烦，要是直接能想word那样粘贴就好了，于是就用了Atom这款写代码的利器，配合插件markdown-assistant和qiniu-uploader，配置了七牛的图床，完美解决图片一键粘贴，还能适配https页面。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>Atom编辑器<ul>
<li>插件<code>markdown-assistant</code>，<code>qiniu-uploader</code></li>
</ul>
</li>
<li>七牛云账号</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>先在七牛云上注册账号，进入管理控制台，新建储存空间，要是用的是http协议的话可以直接使用，找到临时域名就好了。否则就用自己的域名，可以申请https访问<br>在七牛云个人面板中找到密钥管理找到如下<br><img src="https://cdn.fayne.cn/73ec87e054a7cedfa03ebacdc4dc60cb.png" alt="qiniu"><br>找到AK，SK并记录</p>
<p>在Atom中安装两个插件，在<code>markdown-assistant</code>中点击设置<br><img src="https://cdn.fayne.cn/f43d8b2ba6deabb95ea84d5007aedbaf.png" alt="markdown-setting"><br>在<code>qiniu-uploader</code>中设置<br><img src="https://cdn.fayne.cn/0d2fe8d5316be30ba404017271825502.png" alt="qiniu-setting"><br>其中AK，Sk即是在七牛云中的AK,SK，由于我是自定义域名，故设置的这个</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需要设置https支持，那么在七牛云上要自定义域名，这里用我自己域名实验，我用的是cdn.fayne.cn这个域名，首先申请这个域名的https的证书，证书都是很好申请的，一般都可以申请一年的使用期<br><img src="https://cdn.fayne.cn/eabe690a6066b92de70daaceea0745a4.png" alt="ssl"><br>进入七牛对象储存，绑定域名，<br><img src="https://cdn.fayne.cn/11683c2853343740da0f149eec65ce2f.png" alt="https"><br>配置完成后，等一段时间就好了</p>
<p>最后需要配置dns解析服务，在dns服务商配置即可，我的配置如下<br><img src="https://cdn.fayne.cn/4e6c3383e4d2b09933d59531a52504ba.png" alt="qiniu-dns"></p>
<p>最后在七牛云面板上看到成功即可<br><img src="https://cdn.fayne.cn/c67b75d72331fab431d25b46e180f5fd.png" alt="cdn"></p>
<blockquote>
<p>至此，一个方便快捷的编辑器就搭建完成了，只需要Ctrl+V就可粘贴图片了</p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Kingfisher加载多个Gif图，内存告警崩溃</title>
    <url>/2019/10/08/Kingfisher-crash/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/7271da405a68a7da7afbd7dba22e143c.png" alt="kingfisher"><br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用Kingfisher加载多个GIF图的时候，内存只增不减，最后导致告警退出</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>临时解决方案：设置cacheType为memory，有好的方案请留言，谢谢<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options: <span class="type">KingfisherOptionsInfo</span> = [.backgroundDecode, .fromMemoryCacheOrRefresh]</span><br><span class="line">kf.setImage(with: url,</span><br><span class="line">                        placeholder: placeholderImage,</span><br><span class="line">                        options: options,</span><br><span class="line">                        progressBlock: <span class="literal">nil</span>) &#123; (image, error, <span class="number">_</span>, url) <span class="keyword">in</span></span><br><span class="line">                            completion?(image, error)&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Kingfisher</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>A+B&#39;</title>
    <url>/2015/04/18/ab/</url>
    <content><![CDATA[<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">A+B’</span></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">0 &lt; =A,B &lt; =1e6</span></p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">输出答案</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">4 3
27 12
100 200</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">7
48
102</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Hint</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">B’就是B反过来啦</span></p>
<p><strong><span style="font-size:24px; color:#333399">Source</span></strong></p>
<p><strong><span style="font-size:24px; color:#333399"></span></strong><br><a id="more"></a></p>
<pre name="code" class="cpp">#include <stdio.h>
#include <stdlib.h>

int main()
{
   int a;
   int b,c,t;
   double s;
   while ( 2 == scanf("%d%d",&a,&b))
   {
       c = 0;
       s = 0;
       t = b;
       while (b)
       {
           b /= 10;
           c++;
       }
       while (c--)
       {
           s += t%10*pow(10.0,c);
           t /= 10;

       }
       printf("%.lf\n",s+a);
   }
    return 0;
}</stdlib.h></stdio.h></pre>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 &quot;Bird Cup&quot; ICPC7th@ahstu--“波导杯”安徽科技学院第七届程序设计大赛</title>
    <url>/2016/04/24/2016birdcupicpc7thahstu-e6-b3-a2-e5-af-bc-e6-9d-af-e5-ae-89-e5-be-bd-e7-a7-91-e6-8a-80-e5-ad-a6-e9-99-a2-e7-ac-ac-e4-b8-83-e5-b1-8a-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1/</url>
    <content><![CDATA[<h1 id="“波导杯”安徽科技学院第七届程序设计大赛"><a href="#“波导杯”安徽科技学院第七届程序设计大赛" class="headerlink" title="“波导杯”安徽科技学院第七届程序设计大赛"></a><strong>“波导杯”安徽科技学院第七届程序设计大赛</strong></h1><p>关于举办“波导杯”安徽科技学院第七届程序设计大赛通知</p>
<p>ACM 国际大学生程序设计竞赛 (International Collegiate Programming Contest）是由美国计算机协会（ACM）主办的一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的著名竞赛。2010年以来，我校参与了历届安徽省 ACM 程序设计竞赛，并取得了优异的成绩。为选拔校 ACM 参赛队员，将举办“波导杯” 安徽科技学院第七届计算机程序设计大赛，热忱欢迎广大程序设计爱好者踊跃参加。</p>
<p>主办方：安徽科技学院教务处、信息与网络工程学院</p>
<p>承办方：信息与网络工程学院</p>
<p>赞助方：宁波波导软件有限公司（独家赞助）</p>
<p>一、 比赛时间：2016 年 4 月23（周六）上午 8:00～12:00</p>
<p>二、比赛地点：计算机与网络实验中心（力行楼六楼）</p>
<p>三、比赛设奖：设一等奖8%、二等奖12%、三等奖15%。<br><a id="more"></a><br>六、竞赛相关：</p>
<p>竞赛语言：C/C++/JAVA 环境：DevCpp /CodeBlock /Eclipse</p>
<p>比赛试题：采用 ICPC 样式——赛题 8～10道</p>
<p>注意事项：</p>
<p>·  1. 练习比赛网站（安科 OJ）：<a href="http://183.167.205.82:8081/JudgeOnline/" target="_blank" rel="noopener">http://183.167.205.82:8081/JudgeOnline/</a></p>
<p>·  2. 计算机系 ACM/ICPC 学生活动室位于力行楼六楼，欢迎交流。</p>
<p>比赛 QQ 群：173592864（波导杯第七届校ACM赛）</p>
<h1 id="Dotaer-vs-Loler"><a href="#Dotaer-vs-Loler" class="headerlink" title="Dotaer vs Loler"></a>Dotaer vs Loler</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:170 Accepted:31</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>小杨是一名Dota资深玩家，和众多Dota玩家一样，他和周围一群LOL玩家在一起有一种自然的优越感，然而身边的刀友确一个个投入了撸狗的行列，直到现在周围再没了<br>一个同行。。。他很愤慨，于是有了下面这道题目：<br>两个分别只含有Dotaer和Loler中的字母的字符串，长度（&lt;10^6）,请你分别统计两个字符串中所含字母能够组成Dotaer和Loler的最大数量(不区分大小写），然后根<br>据两者的数量判断输赢，若Loler数量大于Dotaer数量的3倍，则Loler win，反之Dotaer win。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>每个输入包含多个测试用例，每个测试用包括两行，第一行为构成Dotaer的字符串，第二行为构成Loler的字符串。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每个测试用例输出三行，第一行为Dotaer数量，第二行为Loler数量，第三行为哪方win。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>otdarrreoddtooaaoooee
rolereoreolrereoreol
</code></pre><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>Dotaer: 2
Loler: 1
Dotaer win
</code></pre><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpc7th@ahstu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;Dota;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;LOL;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator d_it;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator l_it;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">change</span><span class="params">(<span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (a&lt;<span class="number">97</span>)?(a+<span class="number">32</span>):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(d_it=LOL.begin();d_it!=LOL.end();d_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;d_it-&gt;second&lt;&lt;<span class="string">" "</span>&lt;&lt;d_it-&gt;first&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dota</span><span class="params">(<span class="built_in">string</span> D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;D.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Dota[change(D[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line">    Dota[<span class="string">'d'</span>];Dota[<span class="string">'o'</span>];</span><br><span class="line">    Dota[<span class="string">'t'</span>];Dota[<span class="string">'a'</span>];</span><br><span class="line">    Dota[<span class="string">'e'</span>];Dota[<span class="string">'r'</span>];</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1000001</span>;</span><br><span class="line">   <span class="keyword">for</span>(d_it=Dota.begin();d_it!=Dota.end();d_it++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(m&gt;(d_it-&gt;second))</span><br><span class="line">        m=(d_it-&gt;second);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lol</span><span class="params">(<span class="built_in">string</span> L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LOL[change(L[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line">    LOL[<span class="string">'l'</span>]; LOL[<span class="string">'o'</span>];</span><br><span class="line">    LOL[<span class="string">'e'</span>]; LOL[<span class="string">'r'</span>];</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1000001</span>;</span><br><span class="line">    <span class="keyword">for</span>(l_it=LOL.begin();l_it!=LOL.end();l_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((l_it-&gt;first)!=<span class="string">'l'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m&gt;(l_it-&gt;second))</span><br><span class="line">                m=l_it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m&gt;(l_it-&gt;second)/<span class="number">2</span>)</span><br><span class="line">                m=(l_it-&gt;second)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("Dotaer vs Loler.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("Dotaer vs Loler.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">string</span> D,L;</span><br><span class="line">    <span class="keyword">int</span> D_num,L_num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;D&gt;&gt;L)</span><br><span class="line">    &#123;</span><br><span class="line">       D_num=dota(D);</span><br><span class="line">       L_num=lol(L);</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Dotaer: "</span>&lt;&lt;D_num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Loler: "</span>&lt;&lt;L_num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">if</span>(L_num&gt;<span class="number">3</span>*D_num)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Loler win"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Dotaer win"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       Dota.clear();</span><br><span class="line">       LOL.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="so-so-so-easy"><a href="#so-so-so-easy" class="headerlink" title="so so so easy"></a>so so so easy</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:46 Accepted:14</p>
<h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>为了避免打光头的情况出现，仁慈的老赵在每次比赛中总会想方设法的加水题进去，一个两个三个…..。<br>现有一个完全由被空格所分开的英文单词构成的字符串(单词数量&lt;=100)，请你数出每个单词是连续第几次出现。（例如 so so so easy 结果为 1 2 3 1）</p>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>每个输入包含多个测试用例，每个测试用例为一个完全由被空格所分开的英文单词构成的字符串。</p>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>对于每个测试用例，输出其每个单词是连续第几次出现。</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>so so so easy so so
</code></pre><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>1 2 3 1 1 2
</code></pre><h2 id="Source-1"><a href="#Source-1" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpc7th@ahstu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">easy</span><span class="params">(<span class="built_in">string</span> A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> flag;</span><br><span class="line">    <span class="built_in">string</span> B[<span class="number">100</span>];</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">sin</span><span class="params">(A)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;<span class="built_in">sin</span>&gt;&gt;B[i];i++);</span><br><span class="line">    flag=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(B[j]!=flag)</span><br><span class="line">        &#123;</span><br><span class="line">            num=<span class="number">1</span>;</span><br><span class="line">            flag=B[j];</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("so so so easy.in","r",stdin);</span></span><br><span class="line">   <span class="comment">// freopen("so so so easy.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">string</span> A;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,A))</span><br><span class="line">    &#123;</span><br><span class="line">        easy(A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:5 Accepted:0</p>
<h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>给定一个常数K以及一个单链表L，请编写程序将L中每K个结点反转。例如：给定L为1→2→3→4→5→6，K为3，则输出应该为3→2→1→6→5→4；如果K为4，则输出应该为4→3→2→1→5→6，即最后不到K个元素不反转。</p>
<h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><p>每个输入包含多个测试用例。每个测试用例第1行给出第1个结点的地址、结点总个数正整数N(&lt;= 105)、以及正整数K(&lt;=N)，即要求反转的子链结点的个数。结点的地址是5位非负整数，NULL地址用-1表示。</p>
<p>接下来有N行，每行格式为：</p>
<p>Address Data Next</p>
<p>其中Address是结点地址，Data是该结点保存的整数数据，Next是下一结点的地址。</p>
<h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><p>对每个测试用例，顺序输出反转后的链表（每个节点的 Address Data Next），其上每个结点占一行，格式与输入相同。</p>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
</code></pre><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
</code></pre><h2 id="Source-2"><a href="#Source-2" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpc7th@ahstu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> add;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;Node;</span><br><span class="line">Node L[<span class="number">100001</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;N;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;::iterator it;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scan</span><span class="params">(<span class="keyword">int</span> &amp;Add,<span class="keyword">int</span> &amp;num,<span class="keyword">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N.add&gt;&gt;N.data&gt;&gt;N.next;</span><br><span class="line">        L[N.add]=N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_sort</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> flag=start;</span><br><span class="line">     <span class="keyword">while</span>(flag!=<span class="number">-1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         N.push_back(L[flag]);</span><br><span class="line">         flag=L[flag].next;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F_sort</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> G=N.size()/n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse((N.begin()+i*n),(N.begin()+(i+<span class="number">1</span>)*n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(it=N.begin();it&lt;N.end()<span class="number">-1</span>;it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,(*it).add,(*it).data,(*(it+<span class="number">1</span>)).add);</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>,(*(N.end()<span class="number">-1</span>)).add,(*(N.end()<span class="number">-1</span>)).data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> Add,num,n;</span><br><span class="line">    <span class="comment">//freopen("反转链表.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("反转链表.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;Add&gt;&gt;num&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        scan(Add,num,n);</span><br><span class="line">       L_sort(Add,n);</span><br><span class="line">       F_sort(n);</span><br><span class="line">       print();</span><br><span class="line">       N.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="贪吃蛇"><a href="#贪吃蛇" class="headerlink" title="贪吃蛇"></a>贪吃蛇</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:9 Accepted:2</p>
<h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>有童年的孩子都玩过这个经典游戏，不过这里的规则又有点不同，现在有一个N*M(N，M&lt;=100)的方形矩形，在这个矩形的每一个方格上都放有若干个樱桃，一条可爱的小蛇从矩形的<br>左上角开始出发，每次移动都只能移动一格，向右或向下，而每到达一格贪吃的小蛇都会吧该位置上的樱桃吃个一干二净，直到到达右下角时停止。而贪吃的小蛇不怕撑死，它只想吃到最多<br>的樱桃，请你告诉它他最多能吃到多少樱桃以及具体路线吧。（数据保证最优路线只有一条）</p>
<h2 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h2><p>每个输入包含多个测试用例，每个测试用例第一行给出N,M，接下来N行M列数据代表每个位置上的樱桃个数。（矩阵坐标从（1,1）开始）。</p>
<h2 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h2><p>对于每个测试用例输出第一行为能吃到的最大樱桃个数，接下来为小蛇所需要走的路线的坐标，每个坐标占一行。</p>
<h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>4 4
1 2 3 7
3 4 2 1
1 5 4 8
10 3 0 3
</code></pre><h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>28
(1,1)
(2,1)
(2,2)
(3,2)
(3,3)
(3,4)
(4,4)
</code></pre><h2 id="Source-3"><a href="#Source-3" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpc7th@ahstu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_sum;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; way;</span><br><span class="line">&#125;MP;</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line">MP Mp[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> A;</span><br><span class="line">    <span class="keyword">while</span>(a!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        A+=((a%<span class="number">10</span>)+<span class="string">'0'</span>);</span><br><span class="line">        a/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(A.begin(),A.end());</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=M;i++)</span><br><span class="line">        mp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++)</span><br><span class="line">        mp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=M;j++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;mp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hand_mp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=M;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Mp[i][j].m_sum=mp[i][j]+((mp[i][j<span class="number">-1</span>]&gt;=mp[i<span class="number">-1</span>][j])?mp[i][j<span class="number">-1</span>]:mp[i<span class="number">-1</span>][j]);</span><br><span class="line">            mp[i][j]= Mp[i][j].m_sum;</span><br><span class="line">            Mp[i][j].way=(mp[i][j<span class="number">-1</span>]&gt;=mp[i<span class="number">-1</span>][j])?(Mp[i][j<span class="number">-1</span>]).way:(Mp[i<span class="number">-1</span>][j]).way;</span><br><span class="line">            Mp[i][j].way.push_back(change(i));</span><br><span class="line">            Mp[i][j].way.push_back(change(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Mp[N][M].m_sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Mp[N][M].way.size();i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;Mp[N][M].way[i]&lt;&lt;<span class="string">","</span>&lt;&lt;Mp[N][M].way[i+<span class="number">1</span>]&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("贪吃蛇.in","r",stdin);</span></span><br><span class="line">   <span class="comment">// freopen("贪吃蛇.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M)</span><br><span class="line">    &#123;</span><br><span class="line">        scan();</span><br><span class="line">        hand_mp();</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="均分硬币"><a href="#均分硬币" class="headerlink" title="均分硬币"></a>均分硬币</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:14 Accepted:4</p>
<h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>有N堆硬币，编号分别为 1，2，…, N（N&lt;=100) 每堆上有若干个硬币，可以在任一堆上取若干个硬币，然后移动。移动规则为：在编号为 1 堆上取的硬币，只能移到编号为 2 的堆上；<br>在编号为 N 的堆上取的硬币，只能移到编号为 N-1 的堆上；其他堆上取的硬币，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上硬币<br>数都一样多。例如 N=4，4 硬币数分别为： ①　9　②　8　③　17　④　6 移动3次可达到目的。</p>
<h2 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h2><p>每个输入包含多个测试用例，每个测试用例第一行为整数N硬币堆数，接下来一行N个数为相应堆上硬币的数量。</p>
<h2 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h2><p>对于每个测试用例，输出其最少需要移动次数，若无法均分则输出“Oh no！”</p>
<h2 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>4
9 8 17 6
</code></pre><h2 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>3
</code></pre><h2 id="Source-4"><a href="#Source-4" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpc7th@ahstu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avg</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> avge;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        sum+=A[i];</span><br><span class="line">    avge=sum/n;</span><br><span class="line">    <span class="keyword">if</span>(avge*n==sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]!=avge)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i+<span class="number">1</span>]+=A[i]-avge;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;flag&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Oh no!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">        avg(A,N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="丢啊丢啊丢手绢"><a href="#丢啊丢啊丢手绢" class="headerlink" title="丢啊丢啊丢手绢"></a>丢啊丢啊丢手绢</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:17 Accepted:4</p>
<h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>在安科图书馆前的草地上围坐着N个同学1,2,3，…..N.(按顺序围成一个圈），然后从其中一个同学开始，拿着一手绢按编号从小到大的方向一步一步绕着圈子走，<br>一步经过一个同学，若干步后把手绢交给面前的同学，接到手绢的同学不改变方向用同样的方式把手绢交给另一个同学后淘汰出游戏，凡是一个同学离开圈子，剩下同学<br>把空缺消除再构成一个圆(相对位置不变）。现在告诉你开始同学的编号和手帕n次行进的步数，你知道终剩下哪些同学吗？</p>
<h2 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h2><p>每个输入包含多个测试用例，每个测试用例包括两部分：<br>第一部分三个数字num(参与游戏学生总数)，i(初始学生编号),n(手绢移动的次数）。<br>第二部分n个整数为n次手绢分别移动的步数。</p>
<h2 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h2><p>输出游戏结束后所剩学生的编号(按升序输出)。</p>
<h2 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>6 2 3
2 3 4
</code></pre><h2 id="Sample-Output-5"><a href="#Sample-Output-5" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>5 6
</code></pre><h2 id="Source-5"><a href="#Source-5" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpc7th@ahstu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        A.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">game</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,<span class="keyword">int</span> *way,<span class="keyword">int</span> n,<span class="keyword">int</span> first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">     A.erase(A.begin()+first);</span><br><span class="line">     index=first<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A.erase(A.begin()+(index+way[i])%A.size());</span><br><span class="line">        index=(index+way[i])%A.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.size();i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("¶ª°¡¶ª°¡¶ªÊÖ¾î.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("¶ª°¡¶ª°¡¶ªÊÖ¾î.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> num,first,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">int</span> way[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;num&gt;&gt;first&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;way[i];</span><br><span class="line"></span><br><span class="line">        init(A,num);</span><br><span class="line">         game(A,way,n,first);</span><br><span class="line">         A.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:0 Accepted:0</p>
<h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>小洛，小欢，小涛是三个小屁孩，他们有一个共同的爱好—吃糖！小杨每天都会给他们买糖吃，但他有个要求，每次小杨会把买来的糖随机分成三堆，<br>(&lt;=10^4) 三个小屁孩想要吃到糖，就必须按小杨的要求每次把任意一堆糖的一半放到其他糖堆里，最终使三堆糖的数量和小杨所要求的完全一致，才被允许吃.<br>(若一堆糖为奇数个，它的一半为较少的那部分）。那么他们最少需要移动多少次才能吃到糖果。</p>
<h2 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h2><p>每个输入包含多个测试用例，每个测试用例第一行给出3个数字为初始的糖堆数量，第二行3个数字为小杨要求糖堆最终数量。</p>
<h2 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h2><p>对于每个测试用例输出一行为其最少移动次数，若不可能达到要求输出“Unfind”。</p>
<h2 id="Sample-Input-6"><a href="#Sample-Input-6" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>6 10 3
6 5 8

1 2 5
3 0 5
</code></pre><h2 id="Sample-Output-6"><a href="#Sample-Output-6" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>1
Unfind
</code></pre><h2 id="Source-6"><a href="#Source-6" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpc7th@ahstu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">int</span> candy[<span class="number">3</span>];</span><br><span class="line">&#125; ST;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">int</span> init[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> target[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">state</span><span class="params">(ST &amp;S,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f,s,t;</span><br><span class="line">    f=S.candy[<span class="number">0</span>];</span><br><span class="line">    s=S.candy[<span class="number">1</span>];</span><br><span class="line">    t=S.candy[<span class="number">2</span>];</span><br><span class="line">    S.step++;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        S.candy[<span class="number">0</span>]=f-f/<span class="number">2</span>;</span><br><span class="line">        S.candy[<span class="number">1</span>]=s+f/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        S.candy[<span class="number">0</span>]=f+s/<span class="number">2</span>;</span><br><span class="line">        S.candy[<span class="number">1</span>]=s-s/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        S.candy[<span class="number">0</span>]=f-f/<span class="number">2</span>;</span><br><span class="line">        S.candy[<span class="number">2</span>]=t+f/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        S.candy[<span class="number">0</span>]=f+t/<span class="number">2</span>;</span><br><span class="line">        S.candy[<span class="number">2</span>]=t-t/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        S.candy[<span class="number">1</span>]=s-s/<span class="number">2</span>;</span><br><span class="line">        S.candy[<span class="number">2</span>]=t+s/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        S.candy[<span class="number">1</span>]=s+t/<span class="number">2</span>;</span><br><span class="line">        S.candy[<span class="number">2</span>]=t-t/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> *init,<span class="keyword">int</span> *target,<span class="built_in">queue</span>&lt;ST&gt; &amp;Q,<span class="keyword">int</span> &amp;STEP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ST flag;</span><br><span class="line">    <span class="built_in">string</span> fl,l;</span><br><span class="line">    flag.step=<span class="number">0</span>;</span><br><span class="line">    flag.candy[<span class="number">0</span>]=init[<span class="number">0</span>];</span><br><span class="line">    flag.candy[<span class="number">1</span>]=init[<span class="number">1</span>];</span><br><span class="line">    flag.candy[<span class="number">2</span>]=init[<span class="number">2</span>];</span><br><span class="line">    Q.push(flag);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> b[<span class="number">15</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(b,<span class="string">"%d"</span>,flag.candy[i]);</span><br><span class="line">        fl+=b;</span><br><span class="line">    &#125;</span><br><span class="line">    mp[fl]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag.candy[<span class="number">0</span>]==target[<span class="number">0</span>]&amp;&amp;flag.candy[<span class="number">1</span>]==target[<span class="number">1</span>]&amp;&amp;flag.candy[<span class="number">2</span>]==target[<span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        STEP=flag.step;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        flag=Q.front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            state(flag,i);</span><br><span class="line">            <span class="keyword">if</span>(flag.candy[<span class="number">0</span>]==target[<span class="number">0</span>]&amp;&amp;flag.candy[<span class="number">1</span>]==target[<span class="number">1</span>]&amp;&amp;flag.candy[<span class="number">2</span>]==target[<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                STEP=flag.step;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fl=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> b[<span class="number">15</span>];</span><br><span class="line">                <span class="built_in">sprintf</span>(b,<span class="string">"%d"</span>,flag.candy[i]);</span><br><span class="line">                fl+=b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp[fl]!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Q.push(flag);</span><br><span class="line">                mp[fl]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag=Q.front();</span><br><span class="line">        &#125;</span><br><span class="line">        Q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f,s,t;</span><br><span class="line">    <span class="keyword">int</span> F,S,T;</span><br><span class="line">    <span class="keyword">int</span> STEP;</span><br><span class="line">   <span class="comment">// freopen("分糖果.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("分糖果.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;f&gt;&gt;s&gt;&gt;t&gt;&gt;F&gt;&gt;S&gt;&gt;T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((f+s+t)!=(F+S+T))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Unfind"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;ST&gt; Q;</span><br><span class="line">        init[<span class="number">0</span>]=f;</span><br><span class="line">        init[<span class="number">1</span>]=s;</span><br><span class="line">        init[<span class="number">2</span>]=t;</span><br><span class="line">        target[<span class="number">0</span>]=F;</span><br><span class="line">        target[<span class="number">1</span>]=S;</span><br><span class="line">        target[<span class="number">2</span>]=T;</span><br><span class="line">        <span class="keyword">if</span>(Search(init,target,Q,STEP))</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;STEP&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Unfind"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        mp.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="埋炸弹啦"><a href="#埋炸弹啦" class="headerlink" title="埋炸弹啦~"></a>埋炸弹啦~</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:47 Accepted:18</p>
<h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>小明是个埋弹专家同时也是个数学爱好者，他每次进行埋弹任务时都喜欢数字决定埋在哪里，他会选出两个数字然后分别把它们转化成八位二进制数，第一个作为横向坐标(从左往右)，<br>第二个作为纵向(从上往下)坐标构成一个8*8的矩阵，而他埋弹的位置当然就是横竖坐标中1的交叉点。请把他埋的位置表示出来，炸弹位置用‘+’表示，其他地方用‘-’表示。</p>
<h2 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h2><p>每个输入包含多个测试用例，每个测试用例一行为两个整数 a，b(0&lt;=a,b&lt;256)为小明所选定的两个数。</p>
<h2 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h2><p>对于每个测试用例，输出一个8*8的矩阵，按要求表明炸弹位置。</p>
<h2 id="Sample-Input-7"><a href="#Sample-Input-7" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>9 18
</code></pre><h2 id="Sample-Output-7"><a href="#Sample-Output-7" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>--------
--------
--------
----+--+
--------
--------
----+--+
--------
</code></pre><h2 id="Source-7"><a href="#Source-7" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpc7th@ahstu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> X,Y;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        X+=((x%<span class="number">2</span>)+<span class="string">'0'</span>);</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(y!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Y+=((y%<span class="number">2</span>)+<span class="string">'0'</span>);</span><br><span class="line">        y/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(X.begin(),X.end());</span><br><span class="line">    reverse(Y.begin(),Y.end());</span><br><span class="line">    <span class="keyword">int</span> l1=X.size();</span><br><span class="line">    <span class="keyword">int</span> l2=Y.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>-l1;i++)</span><br><span class="line">        X.insert(X.begin(),<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>-l2;i++)</span><br><span class="line">        Y.insert(Y.begin(),<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bomb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Y.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;X.size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Y[i]==<span class="string">'1'</span>&amp;&amp;X[j]==<span class="string">'1'</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">'-'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("ÂñÕ¨µ¯À²~.in","r",stdin);</span></span><br><span class="line">   <span class="comment">// freopen("ÂñÕ¨µ¯À²~.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        bomb();</span><br><span class="line">        X=<span class="string">""</span>;</span><br><span class="line">        Y=<span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="化学老师的惩罚"><a href="#化学老师的惩罚" class="headerlink" title="化学老师的惩罚"></a>化学老师的惩罚</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:0 Accepted:0</p>
<h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>小明的化学成绩很差，他的老师对他恨铁不成钢啊，于是想了一个法子——把他关在了一个密室里，出不来不给吃饭。这个把小明急坏了。。<br>小明发现密室的墙上写了许多化学方程式中。化学方程式，也称为化学反应方程式，是用化学式表示物质化学反应的式子。化学方程式反映的是客观事实。因此书写化学方程式要遵守两个原则：一是必须以客观事实为基础；二是要遵守质量守恒定律。<br>化学方程式不仅表明了反应物、生成物和反应条件。同时，化学计量数代表了各反应物、生成物物质的量关系，通过相对分子质量或相对原子质量还可以表示各物质之间的质量关系，即各物质之间的质量比。对于气体反应物、生成物，还可以直接通过化学计量数得出体积比。例如：2NaOH+H2SO4=Na2SO4+2H2O<br>经过多次试探、推理，小明发现密码是4位数字，就隐藏在化学方程式等号后的第一个分子中，其分子量就可能是密码（若分子量不足4位，前面加0）。</p>
<p>好在小明还记得墙上各化学方程式用到的化学元素的原子量如下：</p>
<p>N | C | O | Cl | S | H | Al | Ca | Zn | Na | B | Ni</p>
<p>14 | 12 | 16 | 35 | 32 | 2 | 27 | 40 | 65 | 23 | 11 | 59</p>
<p>你能帮小明尽快找到密码吗？</p>
<h2 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h2><p>输入包含多组测试用例。<br>每个测试用例 第一行： K，表示有K个化学方程式；<br>接下来有K行，每行为一个化学方程式</p>
<h2 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h2><p>对于每个化学方程式输出一行：即密码。</p>
<h2 id="Sample-Input-8"><a href="#Sample-Input-8" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>2
2C+O2=2CO
Ca2CO3+H2O=Ca2(OH)2+CO2
</code></pre><h2 id="Sample-Output-8"><a href="#Sample-Output-8" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>0056
0116
</code></pre><h2 id="Source-8"><a href="#Source-8" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpc7th@ahstu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sp_num;</span><br><span class="line"><span class="built_in">string</span> total;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mp[<span class="string">"Na"</span>]=<span class="number">23</span>;</span><br><span class="line">    mp[<span class="string">"Zn"</span>]=<span class="number">65</span>;</span><br><span class="line">    mp[<span class="string">"Ca"</span>]=<span class="number">40</span>;</span><br><span class="line">    mp[<span class="string">"Al"</span>]=<span class="number">27</span>;</span><br><span class="line">    mp[<span class="string">"H"</span>]=<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">"S"</span>]=<span class="number">32</span>;</span><br><span class="line">    mp[<span class="string">"Cl"</span>]=<span class="number">35</span>;</span><br><span class="line">    mp[<span class="string">"O"</span>]=<span class="number">16</span>;</span><br><span class="line">    mp[<span class="string">"C"</span>]=<span class="number">12</span>;</span><br><span class="line">    mp[<span class="string">"N"</span>]=<span class="number">14</span>;</span><br><span class="line">    mp[<span class="string">"B"</span>]=<span class="number">11</span>;</span><br><span class="line">    mp[<span class="string">"Ni"</span>]=<span class="number">59</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;B.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> flag;</span><br><span class="line">        flag += B[i];</span><br><span class="line">        flag += B[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(mp[flag] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> f = i+<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">string</span> n;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(B[f]))</span><br><span class="line">            &#123;</span><br><span class="line">                n += B[f];</span><br><span class="line">                f++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="string">""</span>)</span><br><span class="line">                n = <span class="string">"1"</span>;</span><br><span class="line">            i = (--f);</span><br><span class="line">            sum += mp[flag] * atoi(n.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">string</span> n;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(B[l]))</span><br><span class="line">            &#123;</span><br><span class="line">                n += B[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="string">""</span>)</span><br><span class="line">                n = <span class="string">"1"</span>;</span><br><span class="line">            <span class="built_in">string</span> K;</span><br><span class="line">            K += B[i];</span><br><span class="line">            sum += mp[K] * atoi(n.c_str());</span><br><span class="line">            i = (--l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">T_calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> S=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sp.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        S+=calculate(sp[i]) * (atoi(sp_num[i].c_str()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S * atoi(total.c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="built_in">string</span> A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> B;</span><br><span class="line">    <span class="built_in">string</span>::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=(find(A.begin(), A.end(), <span class="string">'='</span>)+<span class="number">1</span>); it != A.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( *it == <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        B += (* it );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(B[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        total += B[<span class="number">0</span>];</span><br><span class="line">        B.erase(B.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(total==<span class="string">""</span>)</span><br><span class="line">        total=<span class="string">"1"</span>;</span><br><span class="line">    <span class="built_in">string</span> flag;</span><br><span class="line">    <span class="keyword">int</span> o=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(!B.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        o--;</span><br><span class="line">        <span class="keyword">if</span>(B[<span class="number">0</span>]==<span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>::iterator it,it1;</span><br><span class="line">            <span class="built_in">string</span> F;</span><br><span class="line">            it=find(B.begin(),B.end(),<span class="string">')'</span>);</span><br><span class="line">            F.assign(B.begin()+<span class="number">1</span>,it);</span><br><span class="line">            sp.push_back(F);</span><br><span class="line">            F=<span class="string">""</span>;</span><br><span class="line">            it1=(++it);</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>( (*it))&amp;&amp;it!=B.end())</span><br><span class="line">            &#123;</span><br><span class="line">                F+=*it;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(F==<span class="string">""</span>)</span><br><span class="line">                sp_num.push_back(<span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sp_num.push_back(F);</span><br><span class="line">            B.erase(B.begin(),(it));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> flag;</span><br><span class="line">            <span class="built_in">string</span>::iterator it=(find(B.begin(),B.end(),<span class="string">'('</span>));</span><br><span class="line">            flag.assign(B.begin(),(it));</span><br><span class="line">            sp.push_back(flag);</span><br><span class="line">            B.erase(B.begin(),(it));</span><br><span class="line">            sp_num.push_back(<span class="string">"1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("化学老师的惩罚.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("化学老师的惩罚.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(N--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> A;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;A;</span><br><span class="line">            Find(A);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%04d\n"</span>, T_calculate());</span><br><span class="line">            sp.clear();</span><br><span class="line">            sp_num.clear();</span><br><span class="line">            total=<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="水题！"><a href="#水题！" class="headerlink" title="水题！"></a>水题！</h1><hr>
<p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:116 Accepted:44</p>
<h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><p>杯子高H，水高h，杯顶半径R，杯底半径r，求水的体积。（Pi=3.1415926)</p>
<h2 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h2><p>H R r h</p>
<h2 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h2><p>水的体积</p>
<h2 id="Sample-Input-9"><a href="#Sample-Input-9" class="headerlink" title="Sample Input"></a>Sample Input</h2><pre><code>10 8 7 4
</code></pre><h2 id="Sample-Output-9"><a href="#Sample-Output-9" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre><code>855.56
</code></pre><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>圆台计算公式V=1/3<em>Pi</em>h<em>(R^2+r^2+R</em>r)</p>
<h2 id="Source-9"><a href="#Source-9" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>icpcth7@ahstu</p>
</blockquote>
<blockquote>
<h3 id="获奖名单"><a href="#获奖名单" class="headerlink" title="获奖名单"></a>获奖名单</h3></blockquote>
<p><img src="http://fayne.cn/usr/uploads/2016/04/1907297266.jpg" alt="0.jpg"></p>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>校赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>校赛</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1055-矩阵乘法</title>
    <url>/2015/06/07/akoj-1055-e7-9f-a9-e9-98-b5-e4-b9-98-e6-b3-95/</url>
    <content><![CDATA[<table border="0" width="100%" background="http://183.167.205.82:8081/JudgeOnline/images/table_back.jpg" style="border-collapse:collapse; border-spacing:0px; font-family:Simsun"><br><tbody><br><tr><br><td><br><br><span style="font-size:24px; color:blue">矩阵乘法</span><br><br>Time Limit:1000MS&nbsp; Memory Limit:65536K<br><br>Total Submit:19 Accepted:7<br><br><strong><span style="font-size:24px; color:#333399">Description</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">矩阵乘法是线性代数中最基本的运算之一。&nbsp;<br><br>给定三个矩阵 A\B\C 请编写程序判断A<em>B = C 是否成立。</em></span><br><br><strong><span style="font-size:24px; color:#333399">Input</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">输入包含多组数据。每组数据的格式如下：&nbsp;<br><br>第一行包括两个整数p 和q，表示矩阵A 的大小。后继p 行，每行有q 个整数，表示矩阵A&nbsp;<br><br>的元素内容。&nbsp;<br><br>紧接着用相同的格式给出矩阵B 和矩阵C。&nbsp;<br><br>输入数据的最后一行是两个0，你的程序处理到这里时就应该退出了。&nbsp;<br><br>输入数据中所有的整数绝对值都不超过100。</span><br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Output</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">对每一组输入数据，你的程序都要输出单独一行字符。&nbsp;<br><br>如果 AB=C成立则输出”Yes”&nbsp;<br><br>如果 A 和B 根本不能相乘，或A<em>B=C不成立，则输出”No”。注意大小写。</em></span><br><br><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px"></span><br><pre><span style="font-family:Times New Roman; font-size:14px">2 3<br>1 2 3<br>4 5 6<br>3 2<br>1 2<br>3 4<br>5 6<br>2 2<br>22 28<br>49 64<br>1 2<br>1 2<br>2 1<br>2<br>1<br>2 2<br>2 4<br>1 2<br>1 2<br>1 2<br>1 1<br>1<br>1 1<br>1<br><br>0 0</span></pre><br><br><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px"></span><br><pre><span style="font-family:Times New Roman; font-size:14px">Yes<br>No<br>No</span></pre><br><br><strong><span style="font-size:24px; color:#333399">Hint</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">此题考察线性代数基本概念，请参阅线性代数教材。</span><br><br><strong><span style="font-size:24px; color:#333399">Source</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">2009中科大ACM校赛-普及版</span><br><br><span style="color:rgb(51,51,153); font-size:14px; font-family:Simsun">[</span><a href="http://183.167.205.82:8081/JudgeOnline/submitpage?problem_id=1055" target="_blank" rel="noopener">Submit</a><span style="color:rgb(51,51,153); font-size:14px; font-family:Simsun">]&nbsp;&nbsp;<br> [</span><a target="_blank" style="color:rgb(51,51,153); font-size:14px; font-family:Simsun; outline:none">Go Back</a><span style="color:rgb(51,51,153); font-size:14px; font-family:Simsun">]&nbsp;&nbsp; [</span><a href="http://183.167.205.82:8081/JudgeOnline/problemstatus?problem_id=1055" target="_blank" rel="noopener">Status</a><span style="color:rgb(51,51,153); font-size:14px; font-family:Simsun">]&nbsp;&nbsp;<br> [</span><a href="http://183.167.205.82:8081/JudgeOnline/bbs?problem_id=1055" target="_blank" rel="noopener">Discuss</a><span style="color:rgb(51,51,153); font-size:14px; font-family:Simsun">]</span><br><br><span style="color:rgb(51,51,153); font-size:14px; font-family:Simsun"><br><br></span><br><br><span style="color:rgb(51,51,153); font-size:14px; font-family:Simsun"><br><br></span><br><br><span style="color:rgb(51,51,153); font-size:14px; font-family:Simsun"></span><p></p><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#define MAXN 101<br><br>int a[MAXN][MAXN], b[MAXN][MAXN], c[MAXN][MAXN], d[MAXN][MAXN];<br><br>int main()<br>{<br>    int i, j, m, n, x, y, u, v, p;<br>    while ( ~scanf(“%d%d”, &amp;m, &amp;n))<br>    {<br>        if ( m == 0 &amp;&amp; n == 0 ) break;<br>        for ( i=0; i&lt;m; i++ ) {<br>            for ( j=0; j&lt;n; j++ ) {<br>                scanf(“%d”, &amp;a[i][j]);<br>            }<br>        }<br>        scanf(“%d%d”, &amp;x, &amp;y);<br>        for ( i=0; i&lt;x; i++ ) {<br>            for ( j=0; j&lt;y; j++ ) {<br>                scanf(“%d”, &amp;b[i][j]);<br>            }<br>        }<br>        scanf(“%d%d”, &amp;u, &amp;v);<br>        for ( i=0; i&lt;u; i++ ) {<br>            for ( j=0; j&lt;v; j++ ) {<br>                scanf(“%d”, &amp;c[i][j]);<br>            }<br>        }<br>        if ( n != x || m != u || v != y ) {<br>            puts(“No”);<br>        }<br>        else {<br><br>            for ( i=0; i&lt;u; i++ ) {<br>                for ( j=0; j&lt;v; j++ ) {<br>                    d[i][j] = 0;<br>                    for ( p=0; p&lt;n; p++ ) {<br>                        d[i][j] += a[i][p]  b[p][j];<br>                    }<br>                    if ( d[i][j] != c[i][j] ) break;<br>                }<br>            }<br>            if ( i == u &amp;&amp; j == v ) puts(“Yes”);<br>            else puts(“No”);<br>        }<br>    }<br><br>    return 0;<br>}</pre><br><br></td><br></tr><br></tbody><br></table>

<p></p><p align="center" style="font-family:Simsun; font-size:14px"><span style="font-size:14px; color:#333399"></span></p>
<p></p>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM退役帖 -- 未真正开始也不会结束</title>
    <url>/2017/05/22/acm-e9-80-80-e5-bd-b9-e5-b8-96-e6-9c-aa-e7-9c-9f-e6-ad-a3-e5-bc-80-e5-a7-8b-e4-b9-9f-e4-b8-8d-e4-bc-9a-e7-bb-93-e6-9d-9f/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码无效, 请检查并重试" data-whm="这些内容无法验证，但您仍然可以查看"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Hey, 请输入密码" /><label>Hey, 请输入密码</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="d72afaaf97914642bf31785968594ad7b3242c5476e659513ec97b62bcd73252">e26fddff9de72a61d72e8da229c2bda218e9143231e30540854acf179c81c9a26c7b8da14aae19175e99bc7eb49e11c962f48794e83041654ef214e6771ec26239dc272549196324ff2542ffaea86b0b6a5bd8d0a3390e0ca2bb7715a6cf18d8774461b9c83bcfc1a61f204f8a554e7e7cfc7ba0ed819083828767ef9e6f6aa89839636d020f0c4f6ffc3ff55bcd0dee3f88c47e68213f8a5f0adf2de10a1360057600aa613c77b5d91f6651bf1f4f7b8e105f100c55885b71fd4eb55077992037637a822736e321f47c85f3d7bb07b1b25aad946217ff280cb248de83264454d50928677d8df8f69261372f9ebddb2c7add60d68bf18e8ccfc1f44477ddb7fb49441111700192668d26da7ea8b39f6810872ffbbf560f7601e8e4a0aa8f4e55607afd8234ac33d2d7d7c8b7e8479c56dd82dfb0b0fc6c8050ffa115dbb85aebe612297067024c2557742dd5626b1ce7ea0311847c1b55d6e8c57a48fa54f081990cd0c3093647b147de48aaba03cdf5fb9d9b00d1c3d287e90cb8395970cc4d1d4a37fa63e7900e77405a1e7b10a4d7825feec61bbc9fa34e9d0f8f8836e2c94ec07de782405f198163c96c4ce8a393ec243b19a90dd761167e26d231f35b01f7c9a25c503c11f9a4600f143ea7a9842722a18b8a146079d1c8fc561b20a35cc5ef6234ea4f5e022051cc8bf30407fec13d5d771bf7bf3aa470ba71c1dae0fc71d5de9baaf6765411c9c8c123b3863bea91906276dbd6834f243dea1f4795b08f9e7f7db10cd9051b1e2cbc2f16ba7b684648267d20d55500d8ccde9572ed4535ae6038af493501e0d2dd967fa6187f75ba146589ccc13e5424d183200b8b97f8a5a5af7a17365749a5d80a4349a47fd3fc867629f6f797d3dfab5e3127ed71b4b318c6de5f61d7b4b5c399af99ae07ba0466b6978fda36a91a573176bc340962e126b827f59370a0035d6ceecc79b76c0fe0247736bf247524e7b17d0ffd2b8bf83d58d4c4ed47857de935ef6b183fb1beaa4dd1d5b4dc78824748e984f192ba693089d59adbfccf5e5a8626f47dbe1668d5403e71d80a0e876834e285afb3c3bf26ca3ed1a9ba49488dc663115999cac020ce2ba8148ef770ff37339ddc496bf23abd6b80c7a8d528910264f1640b4180674ad578edb766eea0862eb7c4bf27e8afd6bd1162c7bf40fb04060b669aff12c698cd422882bc0f4603b63ac0655b0475754832bdc3646e02f98f09e9cd7f77e14396079452b759110687a39d4cb9aa8e73b9e2368a1523c70bb365c79a73292530f44fa49876f06d37cd4e5645fc52e0530347135fa77791f4e5c2bdb95fe082d3f4f4ae8fe525967b7ccdf590f74014e92507c6b6e284af2652a7fe5e1d102f6b5da692bf4e033cadf9ee472b1d1d96ac575e7a4ae996b9df606bcdbd99511a6ddfa6958fe109d1cef4fe32f34bae13bd2d2367efc9009421901d0e8ab4b37af1332ee2d110139fee1c76c30c31b4019d4a6d8bbd217272d86055ef59c46e65e0f975f5f95059aee9489a0d0fb68e8ef68bd087e518b6cfebab5efdede376873908da8c2fff2c917eff0a65d930563478f167ab638e284005f5b79aa1025e5c195f15e394abcd531cf32454d3b7055de1a82ec5289f125f5548011ce8bded1e7229db31e61dfad0083c215d2b57c9d7146bb8d8dc0b986764da5675b251f59ef8099782f3f78220fd6b738f03bec8ecebbda3537b28477f8f032f3d1855378f532dee24ea37c138b87187d8beed73554f7bc11a501c00e0c145aa51c35b22761a584f47d741b5585e2c9d2f507ec56b27b43551ad86b8a09317ed6c0fe192fc0e5b06ac487fe16878d19a185a8db114a74b627461eee98926f2792531702ef74b9e54cad110f569501f4c3a953c1b979fbc3c8b63d9ab7c4923a23bec87921606cccfd5b3ee8e83dd4d04b1401b7225faddeb9b620f79259122e42f357a35ca5c8e6deb3d98cbd1bb9619f0070fe48f231732de066e2c1dd06b2eb826e237c78756f5f547bc9a4619e980e34fa5346a70e4385f9c6f00c2cbbfbe03df324eb7090ef54904ddd6c9ee1b77f3f4c4fa83620afcffdd42386ec09a2d3208ac233278d9daef935de9224c075bea8ff29480971a0074129aa5ad5ee000a59ee2fad2102402c5c42f7c1364895b81d236e9daca39f681b19eb4841971b74df26f49685057f79dfbf717c2eb660877385bfdd9c774333b650240f5b1352a3e73335d3156bf2e592c8ab7302569d009086e5b62af18e6a7f02c2159ad14f41f8e305e4a15af2a33a8ea7c26c08175494a64933deb5abdc3f58da0c48078f2edd1e50b6a5b3896fc8eee1a23cf10c302bb2232ca5944185eba9e80c5464b48706cd815327d216a3d063c62a1f002177b59d955cf9266b1c5aec257320a0dd618ee9f053869ba50016ecda8d66044083db50c5ffc6024d2daf392f3dcedbb23f67e34f4fe435d96ad5e6f2db841dc1cdf7160ac67e84ff1f6324f362e989a0e51031975ec0cfc7d9ac40359322af6b11abc2ca73839ac363511c1d850405183c1df292127f74273bb8098cc10d6499f1e5abc2df51fa1a88f10d15da9d783ff3f92642ba42ed1979c2b7f7583400c34d5475325988c5823c6bc703fb382dd5371478032b99f75b9f27a34ad01e7a012a9108f5ba60aa08530e41151dfb3abf99beaa2d7e029a3a318c906bd2d595c62c47ec4946875e2cdb66a157661a9868b23139f3777a1a9bcbeb1b9a58c5b0b7b9359e99c91e351fcf50bd94541233be16e4b36778ef10d7cea85e02fafdc8f6f75d4cc17b094b2341404a6ddfae2e51b47896b57cc4a9c6545398542cf1dcf467950bc7886136fd1d069c74fbb187e32e4a4ed362e8b9844d6f882f45358a414840d8d61dbd72535da030c181376170c991893483f3bbbf25e654b68e7678649309af999e3dd82896b0d165332a80c7022680fbcacee99912a82f4610bcf6097f20eda3efdd9d666cfa73f458706608f3b26afe3d19770344b261884456f4a0232dc2d2e6598a6f94d807a3e2e71bbfb00adc04707537815311c5dc83d1d06748daa41cd2262d2a44d373956fb9ead8e0df9abc4773131cab0ebe8fdb6bd0236bb610085abfdf4ca0c8531b4341e69845aeb12779e85eda26260d2ca762148880fb2754a05d625028059d81776276cd851ed1165dcf90125e0fbd4dd90a11b60c213bc04d70c55431d0b8de22749672907c8658a63c4f220b912cd2d39310de2d57e9382b5e3d5f1d7927be1deabb9a1bfad00d784bac09eb96c842be1885ed4ee83c70b5290fd5ce6999aabc59f8e7af078add5ddf448597effb84618059e93ab1efdaa7530882022a4be6ab7b02d437a55f648b950a9723de6db49b5f635f75987fc441ceb95d1f6dfac5bccd5e741d52a9d92d66644985d3a7cc027c6696e1d2c18e6ca916675f3a74f01a9417ce773810db794ef5e2a2ada09ccc1d166b27ec229d7e72ff5dedf2a4d991a3756da6fa9e83663ce3eb194611882841043e774bc1d9eada73fd1152e87625162547fba37acf3d77ed565db18085ec907a8a86246aaaf97c562b55d3990e13bc6e7baa5f9d2b91fd9c541301764ae5a532257a0dadd069923cd33a66a4e87a90f84a69fbadafe76c6fe0a55ba060296ae91c20b9fa220f07fba5f0b1271c2c2511af5db296ce4e1e84bf8998fd6164cc0c275012ee1a13f9d7bf2b5f171db9b210b2a93f6b06580b5e1ab0e43f8b86cec09d73dca38513fe13ffc7083d7102069ef36083bfa196d9e4e72bb750f02b3e0280357550ca87ab020988fb8e47da66bc99a63c6f15c5de3608d96c3c669ade50c8979b265ecc8924efc3d8ef8d4edd8611a9815aa00a221d097410855996ff0e36bec9ae2b685f281ff9361000cb884ff93f8b05860507f41b2629e52eb5eb2f160036c5fcec11bd53bdc36236557a3fe57f2c75b97116335863ea85fa5c59ef498ad17bd87fbf0657e37c82ce65c4d293428aa3137979b5dd2debb3c9e0fed544d3a8ffc3da2d8618b377b8beacf5e15d54e299a88967e239c9a6d03055a0eab1620d329f77f4e0efdc461730b84594978c7520c0a3b75b72479ea1af3deb253244dbd84e387578e28c73943727b2cbc1e736418d4749dd4c7409a378bfdafc488e6516d68c61b12b00cfdd080efd661507a75b825373bde1eed76b68ea19bb025167e956f4d45e1316d7d4ae4b34bc9137a192278a55bee7292b688af0f179eb769a285ba67067348ece7f0a8ec7c3d2124a92afa663cea8289166c7e5a786e88e8336f54537dee721749f8933434041d01c9473fbaa028e13511b2aff65c9aef69b5f136f99895286ad24f939f023c4d2304399106a7433f92796d6a95dbe2accfcfaf673a76d9ac90789843e9dc711f5832136c35be0a1dbe3212f5cf9c645b4b4d9bf224bbfc874e922bc9304a3d6aad56cfb4e53d7b7bccec654db16b034458605e95e673d023e2a7ee94793731d27169cfbb4bb88310f6b91848ef6f444ab3ae5431a42bd43421195698fdc43c2065b28cfc4ef083eb54a283566598fc7c65edabef56c0b79247dc8ba0e01f17708681645aa666cc96d979b1f74965fcee0d422ea1c00499eefa185f8909ad91797712a91c96567a233dc8a4d03de9a6c9ed8a4082a783dadc6e4af9e0f5cda1f7dd1f82f661d12c0df9d1e974475ff165748dfab869d01d5ddfecbeae49f9a4a80e6de72f1c4e4e49b162eca8ae63ebdee9e81f5f48e727445d1bbf9e515deff2b7e76f880b1c0701c61e6a96eb9fbec0d35b6783b1a6ad710b021f800c40f19c6565264bd164ce414f3fe94f348d7f6edf147b1f47d30cf81d14dc75618df588e34e4f969577df2515acc1a4a149b84291572d2cbca45b86449648221f6724f4a75f650ddb6f4f555f91439a0e36ed1ad13a1d117640f61898fc06ccf65557aa41baef28a9c7059a9a6c404f9e4c8d0900849ebe5d046bb07ccb4aa18a9420867ba5f46312395f421248888287568bd424c642b2bc35dd35514bc272184e192bddad5d12810c1ec7b81f91e296a9c86b6feeb8ce97022ba9dd5f555f4e7dc1702a28bf66974faf07f9867c7607d3c4f59ea116a5c11c388a937cddd02089672955f22ffd20ee3c83bf92ceb9b755898b6af63bda6420294520488c5a1cc239b9d8e585519bca2d57f2e82fa8fe7f1d5692a647fbc30fb9a38ebabb7b87ba1fe507e5f0d063ab790d1e6bc7d6dbb342bd41b0782e41f917f42fcb82026c38438a3c16d00eecfa367f4cf6d2e5e7cf5b8493199478004013a06eae3563326aca9dffe02b5ede294c5a61704018fa94a436f6b7ab68c45f2732e8e7707e28fee39acd735f51ac96a321a1d929050bffbba8cf63d556a6a0e0c2c8d1328ebe9f02068b6ea28122004c77c82a73e7f247449dd7829720aef452596a7dcb44a7ece7f8107da3d0db36f5927a78fc329f91cdc0f0a76d689c22c1605be53ef53bcea41e1cc2aabcf1a6110bada462ee8263e03239afe47362afed68f52b49bf3fbf40ecd017047b3ef8e2531df35a4d4f3c179aedad9d305fd0c895f4f96e91169b6cf1dfc2db70ff23be423895a83498a2741bd5d3a31eca8d2766873101e79c7ee62cd4c834295e7c38294725ce5b164048c668d163414077f8f678c9d66a7d9766655d112978f9e24c07aae1e17de39c2c40325e5cb2c48b3f0f7c9b90ab7e793d02277f27a999247a7f4b1f34e65b198758a9d1b4b61e48ace35d8be4ba0a4b4a52513cbaf788804267b853ffe57b6bdc1b71fc418f910b8dfc4fd38433ec0192e3fa7a16eb677f6bcfaf4a638b3a4c09b3ffed01a7605f58ca45d27da45548648c05174d1221dd0d891714618adf138763c81fa1088a0e1796e363ff723777caab8014a9123b1a79f6e1b28f3d1284770a1b5677e4a81d204fe4b667b2d1a1ed26fa00a3b47b26f0f753464bc447fd8c046e414fc6d70c5c99c760e14f437c70d8ff7b715e698c51f29344b9520b2bf5f1fd46cef870a4af9e31ced20bd6d839541c38e27a2f8ec62ef0229c22fbad6075a8f986f9da435df94c720b48f34471b2e45648d09ce1793de4fb65755ee038fa59b319dad2c5997208fbc3498acbdbfa6d018b13e6e1f271f82c421c5bf1ccfd416bc8a9f96f45dc77f2c72d2758e342068a7ddd9b80b9544fa18c68397e052c2301917b67d98e2fedeafba2cd723f23c563acadc5594f1e21787f8a7d2dcc8826763c68f7a95e383a0f875723287b7e8960cf8940d2fbf90bc211511076a39b32100274d5eb2916c0c6c1abbf7879ea5bfd2fc34ee40a0134bae789b456d98cacd42a416f81775a808111677c48c685ea1fad414e88d570821a53336548ee5c9ca47ed128f8b2bd9db34511a9d5b24450ef90e257714f4575afcd9536f913c881272020b3e335e3a3389a044c5447a00714d99d48b75759d56db42da1922a7c60a987944fbae22d52383adf36a8505aafa258af02bcb20a899e86ac0efd7e6c173e55633963fb7c37b2d4bd5dddea5c0c63d9a698fce7f31139571b32ef50e435a9432f2dae886ecdae6b337e31032d970b14d8937eb488887558df52920ae0d3e66c12f7ff2c12437de7d2e06376a8a4fa085c782ad1b2e9c2158802ee27f5887ea0277f7547d7eb7df91b5c7a37bd23e24fcff0d487de1194204ccc1805dc669240b570682301609a113987457fe2ac5d62d7b8c7cce33e7751e04e16bbc7973c21ccb2568466a4492b7e3a8729878a4302330090f8c2fdecb126ec1713d631b498eb01b78673583689ef88c298585117535927eba8d5104dbe16be8ba2ff75b91fb5d967dfcb091b9bcf1b216e398a6da27d6243f9dcbf6d50b6b497a357158a</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>acm退役帖</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1059-Picture</title>
    <url>/2015/05/09/akoj-1059-picture/</url>
    <content><![CDATA[<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">给你一个矩形的宽度和高度，要求按sample output样例输出此矩形。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">输入包含多组数据，每一组包含两个数N和M（ 0 &lt; N ，M , &lt; 75 )分别代表矩形的宽和高。输入以EOF结束。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">对每一组N和M，输出相应的矩形。每一组输出结束后输出一个空行。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">3 2</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">+---+
|   |
|   |
+---+</span></pre>
<a id="more"></a>
**<span style="font-size:24px; color:#333399">Source</span>**

<span style="font-family:Times New Roman; font-size:14px">Hdu 翻译</span>

<span style="font-family:Times New Roman; font-size:14px">

</span>

<span style="font-family:Times New Roman; font-size:14px"></span>

<pre name="code" class="cpp">#include <stdio.h>

int main()
{
    int n, m;
    int i,j;
    while ( ~scanf("%d%d", &n, &m))
    {
        printf("+");
        i = n;
        while (i--)
        printf("-");
        printf("+\n");

        j = m;
        while (m--)
        {

        printf("|");
        i = n;
        while (i--)
        printf(" ");
        printf("|\n");
        }
        printf("+");
        i = n;
        while (i--)
        printf("-");
        printf("+\n");
        printf("\n");

    }
    return 0;
}
</stdio.h></pre>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1073- Let the Balloon Rise</title>
    <url>/2015/05/09/akoj-1073-lettheballoonrise/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">Let the Balloon Rise</span></p>
<p>Time Limit:1000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:92 Accepted:58</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges’ favorite time is guessing the most popular problem.<br> When the contest is over, they will count the balloons of each color and find the result.&nbsp;</span></p>
<p>This year, they decide to leave this lovely job to you.&nbsp;</p>
<p><br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">Input contains multiple test cases. Each test case starts with a number N ( 0 &lt; N &lt; = 1000 ) – the total number of balloons distributed. The next N lines<br> contain one color each. The color of a balloon is a string of up to 15 lower-case letters.&nbsp;</span></p>
<p>A test case with N = 0 terminates the input and this test case is not to be processed.</p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case.</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">5
green
red
blue
red
red
3
pink
orange
pink
0</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<p>&lt;</p>
<p>pre&gt;<span style="font-family:Times New Roman; font-size:14px">red<br></span><span style="font-family:Times New Roman; font-size:14px">pink</span></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre name="code" class="cpp">#include <stdio.h>
#include <string.h>
int main()
{
    int n,i,j,num[1000];
    int max=0,t=0;
    char color[1000][16];
    while(scanf("%d",&n)!=EOF)
    {
        if(n)
        {
            num[0]=0;
            scanf("%s",color[0]);
            for(i=1;i<n;i++) { num[i]="0;" scanf("%s",color[i]); for(j="0;j<i-1;j++)" if(strcmp(color[i],color[j])="=0)" num[i]+="1;" } max="0;" t="0;" for(i="1;i<n;i++)" if(max<num[i]) printf("%s\n",color[t]); else break; }< pre>

<p></p></n;i++)></string.h></stdio.h></pre><p></p>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1076-Encoding</title>
    <url>/2015/06/07/akoj-1076-encoding/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">Encoding</span></p>
<p>Time Limit:1000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:62 Accepted:35</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">Given a string containing only ‘A’ - ‘Z’, we could encode it using the following method:&nbsp;</span></p>
<p>1. Each sub-string containing k same characters should be encoded to “kX” where “X” is the only character in this sub-string.&nbsp;</p>
<p>2. If the length of the sub-string is 1, ‘1’ should be ignored.&nbsp;</p>
<p><br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">The first line contains an integer N (1 &lt; = N &lt; = 100) which indicates the number of test cases. The next N lines contain N strings. Each string consists<br> of only ‘A’ - ‘Z’ and the length is less than 10000.</span></p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">For each test case, output the encoded string in a line.</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">2
ABC
ABBCCC</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">ABC
A2B3C</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Source</span></strong></p>
<p><strong><span style="font-size:24px; color:#333399"></span></strong></p>
<pre name="code" class="cpp">#include <stdio.h>
#include <string.h>
#define MAXN 10000 + 10

char str[MAXN];

int main()
{

    int n, i, k, c, thisn, maxn;
    scanf("%d", &n);
    while (n--)
    {
        c = 0;
        scanf("%s", str);
        k = strlen(str);
        str[k] = -1; // 这里的输入长度小于定义的长度所以不会越界
        thisn = maxn = 0;
        for ( i=0; i<k; i++ ) { thisn++; if ( thisn> maxn ) {    //实时更新段的长度
                maxn = thisn;
            }
            if ( str[i+1] != str[i] ) { // 当后面的与前面的不同时输出之前的
                thisn = 0;
                if ( maxn == 1 ) {
                    printf("%c", str[i]);
                }
                else {
                    printf("%d%c", maxn, str[i]);
                    maxn = 0; // 输出后将最大长度再次赋值为0
                }
            }
        }

        printf("\n");
    }

    return 0;
} </k;></string.h></stdio.h></pre>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1074-人见人爱A^B</title>
    <url>/2015/05/10/akoj-1074-e4-ba-ba-e8-a7-81-e4-ba-ba-e7-88-b1ab/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">人见人爱A^B</span></p>
<p>Time Limit:1000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:91 Accepted:55</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">求A^B的最后三位数表示的整数。&nbsp;</span></p>
<p>说明：A^B的含义是“A的B次方”&nbsp;</p>
<p></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。</span><br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">2 3
12 6
6789 10000
</span><span style="font-family:Times New Roman; font-size:14px">0 0</span>

<span style="font-family:Times New Roman; font-size:14px"></span>
<pre name="code" class="cpp">#include <stdio.h>

int main()
{
    int m, n;
    long long s = 1;
    while (~scanf("%d%d", &m, &n))
    {
        s = 1;
        if ( m == 0 && n == 0 )  break;
        int i;
        if ( n == 0 )
            printf("1\n");
        else
            for (n; n > 0; n--) {
                s = s * m % 1000;

            }
        printf("%d\n", s);
    }

    return 0;
}</stdio.h></pre>

<p></p></pre><p></p>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1148-小光棍数</title>
    <url>/2015/05/11/akoj-1148-e5-b0-8f-e5-85-89-e6-a3-8d-e6-95-b0/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">小光棍数</span></p>
<p>Time Limit:1000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:197 Accepted:94</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">最近Topcoder的XD遇到了一个难题，倘若一个数的三次方的后三位是111，他把这样的数称为小光棍数。他已经知道了第一个小光棍数是471,471的三次方是104487111，现在他想知道第m（m&lt;=10000000000）个小光棍数是多少？</span></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">有多组测试数据。第一行一个整数n，表示有n组测试数据。接下来的每行有一个整数m。</span><br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">输出第m个小光棍数。&nbsp;</span></p>
<p></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">1
1
</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<p><span style="font-family:Times New Roman; font-size:14px">471</span></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p><p></p>
<pre name="code" class="html">#include <stdio.h>//此题使用了同余定理

int main()
{
    int n;
    scanf("%d", &n);
    while (n--)
    {
        long long m;
        scanf("%lld", &m);
        printf("%lld\n", 471 + 1000*(m-1));
    }

    return 0;
}</stdio.h></pre>

<p>补充同余定理：参考百度百科：<a href="http://baike.baidu.com/link?url=4tXM4vNY5I9BsSRtbCRQbSLX203c8pLGrsFqg3FkHDNTJuVQr5QgvGRPbL7wqmAL8oCW6uusTrumFgW3kg6zla" target="_blank" rel="noopener">点击打开链接</a></p>
<p><span style="font-family:'Times New Roman'"></span></p>
<p>##<br><span class="headline-1-index" style="width:25px; height:24px; line-height:24px; font-size:16px; display:block; float:left; margin:1px 0px 0px; color:rgb(255,255,255); text-align:center; background:rgb(81,156,234)">1</span><span class="headline-content" style="line-height:24px; display:block; float:left; padding:0px 8px 0px 5px">定义</span><span class="text_edit editable-title" style="display:block; float:right; padding:6px 0px 0px 8px; margin-left:10px"><a href="http://baike.baidu.com/link?url=4tXM4vNY5I9BsSRtbCRQbSLX203c8pLGrsFqg3FkHDNTJuVQr5QgvGRPbL7wqmAL8oCW6uusTrumFgW3kg6zla#" title="编辑本段" target="_blank" rel="noopener">编辑</a></span></p>
<div class="para" style="font-size:14px; color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif"><br>数学上的记法为：</div>

<div class="para" style="font-size:14px; color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif"><br>a≡ b(mod d)</div>

<div class="para" style="font-size:14px; color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif"><br>可以看出当n&lt;d的时候,所有的n都对d同商,比如时钟上的小时数,都小于12,所以小时数都是模12的同商.</div>

<div class="para" style="font-size:14px; color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif"><br>对于同余有三种说法都是等价的,分别为:</div>

<div class="para" style="font-size:14px; color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif"><br>(1) a和b是模d同余的.</div>

<div class="para" style="font-size:14px; color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif"><br>(2) 存在某个整数n,使得a=b+nd .</div>

<div class="para" style="font-size:14px; color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif"><br>(3) d<a href="http://baike.baidu.com/view/135932.htm" target="_blank" rel="noopener">整除</a>a-b.</div>

<div class="para" style="font-size:14px; color:rgb(51,51,51); margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif"><br>可以通过换算得出上面三个说法都是正确而且是等价的.</div>

<p><span style="font-size:18px; color:#ff0000">这里用到了第二点的性质，同时需要注意的是使用%lld做的输入输出选项可以参考博客：<a href="http://blog.csdn.net/hongxdong/article/details/5559312" target="_blank" rel="noopener">http://blog.csdn.net/hongxdong/article/details/5559312</a></span></p>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1153-p次方求和</title>
    <url>/2015/06/22/akoj-1153-p-e6-ac-a1-e6-96-b9-e6-b1-82-e5-92-8c/</url>
    <content><![CDATA[<table border="0" width="100%" background="http://183.167.205.82:8081/JudgeOnline/images/table_back.jpg" style="border-collapse:collapse; border-spacing:0px; font-family:Simsun"><br><tbody><br><tr><br><td><br><br><span style="font-size:24px; color:blue">p次方求和</span><br><br>Time Limit:1000MS&nbsp; Memory Limit:65536K<br><br>Total Submit:196 Accepted:46<br><br><strong><span style="font-size:24px; color:#333399">Description</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">一个很简单的问题，求1^p+2^p+3^p+……+n^p的和。</span><br><br><strong><span style="font-size:24px; color:#333399">Input</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">第一行单独一个数字t表示测试数据组数。接下来会有t行数字，每行包括两个数字n,p，&nbsp;<br><br>输入保证0&lt; n&lt; =1000,0&lt; =p&lt; =1000。&nbsp;<br><a id="more"></a><br></span><br><br><strong><span style="font-size:24px; color:#333399">Output</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">输出1^p+2^p+3^p+……+n^p对10003取余的结果，每个结果单独占一行。&nbsp;<br><br></span><br><br><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px"></span><br><pre><span style="font-family:Times New Roman; font-size:14px">2<br>10 1<br>10 2<br><br></span></pre><br><br><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px"></span><br><pre><span style="font-family:Times New Roman; font-size:14px">55<br>385</span></pre><br><br><strong><span style="font-size:24px; color:#333399">Source</span></strong><br><br><span style="font-weight:bold"><span style="font-size:24px; color:#333399"><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px"><span style="white-space:pre"></span>[</span><a href="http://183.167.205.82:8081/JudgeOnline/submitpage?problem_id=1153" target="_blank" rel="noopener">Submit</a><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px">]&nbsp;&nbsp;<br> [</span><a target="_blank" style="outline:none; font-family:Simsun; font-size:14px">Go Back</a><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px">]&nbsp;&nbsp; [</span><a href="http://183.167.205.82:8081/JudgeOnline/problemstatus?problem_id=1153" target="_blank" rel="noopener">Status</a><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px">]&nbsp;&nbsp;<br> [</span><a href="http://183.167.205.82:8081/JudgeOnline/bbs?problem_id=1153" target="_blank" rel="noopener">Discuss</a><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px">]</span></span></span><br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int a[1002][1002];<br><br>int main()<br>{<br>    int i, j, s, n, p, t;<br>    for ( i=1; i&lt;1002; i++ ) {<br>        a[i][0] = 1;<br>    }<br>    for ( j=1; j&lt;1002; j++ ) {<br>        for ( i=1; i&lt;1002; i++ ) {<br>            a[i][j] = a[i][j-1] * i % 10003;//构造次方表，a[i][j]表示i的j次方<br>        }<br>    }<br>    scanf(“%d”, &amp;t);<br>    while ( t– )<br>    {<br>        s = 0;<br>        scanf(“%d%d”, &amp;n, &amp;p);<br>        for ( i=1; i&lt;=n; i++ ) {<br>            s = s + a[i][p];<br>        }<br>        printf(“%d\n”, s % 10003);<br>    }<br><br>    return 0;<br>}</pre><br><br></td><br></tr><br></tbody><br></table>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1267-独木舟上的荡漾</title>
    <url>/2015/06/06/akoj-1267-e7-8b-ac-e6-9c-a8-e8-88-9f-e4-b8-8a-e7-9a-84-e8-8d-a1-e6-bc-be/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">独木舟上的荡漾</span></p>
<p>Time Limit:1000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:76 Accepted:44</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">进行一次独木舟的旅行活动，独木舟可以在港口租到，并且之间没有区别。一条独木舟最多只能乘坐两个人，且乘客的总重量不能超过独木舟的最大承载量。我们要尽量减少这次活动中的花销，所以要找出可以安置所有旅客的最少的独木舟条数。现在请写一个程序，读入独木舟的最大承载量、旅客数目和每位旅客的重量。根据给出的规则，计算要安置所有旅客必须的最少的独木舟条数，并输出结果。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">第一行输入s,表示测试数据的组数；&nbsp;</span></p>
<p>每组数据的第一行包括两个整数w，n，80&lt;=w&lt;=200,1&lt;=n&lt;=300，w为一条独木舟的最大承载量,n为人数；&nbsp;</p>
<p>接下来的一组数据为每个人的重量（不能大于船的承载量）；<br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">每组人数所需要的最少独木舟的条数。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">3
85 6
5 84 85 80 84 83
90 3
90 45 60
100 5
50 50 90 40 60</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">5
3
3</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Source</span></strong></p>
<p><strong><span style="font-size:24px; color:#333399"></span></strong></p>
<pre name="code" class="cpp">#include <stdio.h>
#include <string.h>
#define MAXN 300 + 10

int a[MAXN];

void my_sort(int b[], int n)
{
    int i, j, t;
    for ( i=0; i<n-1; i++ ) { for ( j="i+1;" j<n; j++ if b[i]> b[j] ) {
                t = b[i];
                b[i]= b[j];
                b[j] = t;
            }
        }
    }
}

int main()
{
    int s, w, n, i, c, j;
    scanf("%d", &s);
    while ( s-- )
    {
        memset(a, 0, sizeof(a));
        c = 0;
        scanf("%d%d", &w, &n);
        for ( i=0; i<n; i++ ) { scanf("%d", &a[i]); } my_sort(a, n); for ( i="0," j="n-1;" i<="j;" if a[i] + a[j] <="w" 如果最轻的和最重的可以，则比较第二重的和第二轻的 ，依次比较（1） i++; j--; c++; else 如果只剩一个人，单独一条船 让重的人单独一条船， 让第二重的成为最重的人，再到（1）进行比较 printf("%d\n", c); return 0; }< pre>
</n;></n-1;></string.h></stdio.h></pre>]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1162-计算表达式</title>
    <url>/2015/06/22/akoj-1162-e8-ae-a1-e7-ae-97-e8-a1-a8-e8-be-be-e5-bc-8f/</url>
    <content><![CDATA[<table border="0" width="100%" background="http://183.167.205.82:8081/JudgeOnline/images/table_back.jpg" style="border-collapse:collapse; border-spacing:0px; font-family:Simsun"><br><tbody><br><tr><br><td><br><br><span style="font-size:24px; color:blue">计算表达式</span><br><br>Time Limit:1000MS&nbsp; Memory Limit:65536K<br><br>Total Submit:14 Accepted:7<br><br><strong><span style="font-size:24px; color:#333399">Description</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">对于一个不存在括号的表达式进行计算</span><br><br><strong><span style="font-size:24px; color:#333399">Input</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">存在多种数据，每组数据一行，表达式不存在空格</span><br><br><strong><span style="font-size:24px; color:#333399">Output</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px">输出结果</span><br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px"></span><br><pre><span style="font-family:Times New Roman; font-size:14px">6/2+3+3<em>4</em></span></pre><br><br><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong><br><br><span style="font-family:Times New Roman; font-size:14px"></span><br><pre><span style="font-family:Times New Roman; font-size:14px">18</span></pre><br><br><strong><span style="font-size:24px; color:#333399">Source</span></strong><br><br><span style="font-weight:bold"><span style="font-size:24px; color:#333399"><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px"><span style="white-space:pre"></span>[</span><a href="http://183.167.205.82:8081/JudgeOnline/submitpage?problem_id=1162" target="_blank" rel="noopener">Submit</a><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px">]&nbsp;&nbsp;<br> [</span><a target="_blank" style="outline:none; font-family:Simsun; font-size:14px">Go Back</a><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px">]&nbsp;&nbsp; [</span><a href="http://183.167.205.82:8081/JudgeOnline/problemstatus?problem_id=1162" target="_blank" rel="noopener">Status</a><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px">]&nbsp;&nbsp;<br> [</span><a href="http://183.167.205.82:8081/JudgeOnline/bbs?problem_id=1162" target="_blank" rel="noopener">Discuss</a><span style="color:rgb(51,51,153); font-family:Simsun; font-size:14px">]</span><br><br></span></span><br><br><strong><span style="font-size:24px; color:#333399"></span></strong><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>/此题关键对数的处理，遇到加减就增加个变量储存 ，<br> <em>遇到‘-’还需要把这个数转换为其相反数储存
 </em>/<br><br>int main()<br>{<br>    char temp;<br>    int x, a[200], i, sum = 0;<br>    memset(a, 0, sizeof(a));<br>    while (~scanf(“%d”, &amp;x))<br>    {<br>        sum = 0;<br>        i = 0;<br>        a[i] = x;<br>        while ( ~scanf(“%c”, &amp;temp) &amp;&amp; temp != ‘\n’ )<br>        {<br>            scanf(“%d”, &amp;x);<br>            switch(temp)<br>            {<br>                case ‘<em>‘: a[i] </em>= x; break;//遇到乘除就当成一个数处理<br>                case ‘/‘: a[i] /= x; break;<br>                case ‘+’: a[++i] = x; break;<br>                case ‘-‘: a[++i] = -x; break;<br>            }<br>        }<br>        for ( i; i&gt;=0; i–) {<br>            sum += a[i];<br>        }<br>        printf(“%d\n”, sum);<br>    }<br>}</pre><br><br></td><br></tr><br></tbody><br></table>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1280另类阶乘问题</title>
    <url>/2015/05/09/akoj-1280-e5-8f-a6-e7-b1-bb-e9-98-b6-e4-b9-98-e9-97-ae-e9-a2-98/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">另类阶乘问题</span></p>
<p>Time Limit:3000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:22 Accepted:20</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">大家都知道阶乘这个概念，举个简单的例子：5！=1<em>2</em>3<em>4</em>5.现在我们引入一种新的阶乘概念，将原来的每个数相乘变为i不大于n的所有奇数相乘例如：5!!=1<em>3</em>5.现在明白现在这种阶乘的意思了吧！现在你的任务是求出1!!+2!!……+n!!的正确值(n&lt;=20)</span></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">第一行输入一个a(a&lt;=20)，代表共有a组测试数据&nbsp;</span></p>
<p>接下来a行各行输入一个n.<br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">各行输出结果一个整数R表示1!!+2!!……+n!!的正确值</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">2
3
5</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">5
23</span></pre>

<pre><span style="font-family:Times New Roman; font-size:14px"></span><pre name="code" class="cpp">#include <stdio.h>
long long  jie(int n)
{
    int i;
    long long s = 1;
    for (i = 1; i <= n; i +="2)" { s *="i;" } return s; long result(int k) int i; for ( <="k;" ++i) main() scanf("%d", &n); while (n--) k; &k); printf("%d\n", result(k)); 0; }< pre>

<p></p></=></stdio.h></pre><p></p>
</pre>]]></content>
      <categories>
        <category>AKOJ</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1319-四方定理</title>
    <url>/2015/07/12/akoj-1319-e5-9b-9b-e6-96-b9-e5-ae-9a-e7-90-86/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">四方定理</span></p>
<p>Time Limit:1000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:28 Accepted:11</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">数论中著名的“四方定理”讲的是：所有自然数至多只要用四个数的平方和就可以表示。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">输入包含多行数据</span></p>
<p>每行输入一个n，(1&lt;=n&lt;=10000)</p>
<p>数据以EOF结束<br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">由于可能会出现多种情况，依次输出最小的a,b,c,d即可</span></p>
<p>即输出最小的a,然后输出最小的b,依此类推</p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">110
211
520</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">0 1 3 10
0 3 9 11
0 0 6 22</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Source</span></strong></p>
<p><span style="font-size:14px; color:#333399">[<a href="http://183.167.205.82:8081/JudgeOnline/submitpage?problem_id=1319" target="_blank" rel="noopener">Submit</a>]&nbsp;&nbsp; [<a>Go Back</a>]&nbsp;&nbsp; [<a href="http://183.167.205.82:8081/JudgeOnline/problemstatus?problem_id=1319" target="_blank" rel="noopener">Status</a>]&nbsp;&nbsp;<br> [<a href="http://183.167.205.82:8081/JudgeOnline/bbs?problem_id=1319" target="_blank" rel="noopener">Discuss</a>]</span></p>
<p></p><p></p>
<pre name="code" class="cpp">#include <stdio.h>

int main()
{
    int n, i, j, x, y, s;
    while ( ~scanf("%d", &n) )
    {
        for ( i=0; i<=n; i++ ) { for ( j="0;" j<="n;" j++ x="0;" x<="n;" x++ y="0;" y<="n;" y++ s="i*i+j*j+x*x+y*y;" if n printf("%d %d %d\n", i, j, x, y); break; } }< pre>
</=n;></stdio.h></pre>]]></content>
      <categories>
        <category>AKOJ</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1272-字母统计</title>
    <url>/2015/06/06/akoj-1272-e5-ad-97-e6-af-8d-e7-bb-9f-e8-ae-a1/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">字母统计</span></p>
<p>Time Limit:1000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:72 Accepted:48</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">现在给你一个由小写字母组成字符串，要你找出字符串中出现次数最多的字母，如果出现次数最多字母有多个那么输出最小的那个。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">第一行输入一个正整数T（0&lt;t&lt;25）</span></p>
<p>随后T行输入一个字符串s,s长度小于1010。</p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong><br><a id="more"></a><br><span style="font-family:Times New Roman; font-size:14px">每组数据输出占一行，输出出现次数最多的字符；</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">3
abcd
bbaa
jsdhfjkshdfjksahdfjkhsajk</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">a
a
j</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Source</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">LY</span></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<p></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre name="code" class="cpp">#include <stdio.h>
#include <string.h>
#define MAXN 1020

char str[MAXN];

int main()
{
    int n, i, word[30], max, p;
    scanf("%d", &n);
    while (n--)
    {
        max = 0;
        memset(word, 0, sizeof(word));
        scanf("%s", str);
        int k = strlen(str);
        for ( i=0; i<k; i++ ) { word[str[i] - 'a']++; 这样的好处不仅把每个字母的个数统计好了 } for ( i="0;" i<26; 且按字母排好序了 if (word[i]> max)
            {
                max = word[i];
                p = i;
            }
        }
        printf("%c\n", p+'a');
    }

    return 0;
}</k;></string.h></stdio.h></pre>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1369 贪吃蛇</title>
    <url>/2016/04/27/akoj-1369-e8-b4-aa-e5-90-83-e8-9b-87/</url>
    <content><![CDATA[<h1 id="贪吃蛇"><a href="#贪吃蛇" class="headerlink" title="贪吃蛇"></a>贪吃蛇</h1><p>Time Limit:1000MS Memory Limit:65536K<br>Total Submit:9 Accepted:2</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>有童年的孩子都玩过这个经典游戏，不过这里的规则又有点不同，现在有一个N*M(N，M&lt;=100)的方形矩形，在这个矩形的每一个方格上都放有若干个樱桃，一条可爱的小蛇从矩形的<br>左上角开始出发，每次移动都只能移动一格，向右或向下，而每到达一格贪吃的小蛇都会吧该位置上的樱桃吃个一干二净，直到到达右下角时停止。而贪吃的小蛇不怕撑死，它只想吃到最多<br>的樱桃，请你告诉它他最多能吃到多少樱桃以及具体路线吧。（数据保证最优路线只有一条）</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>每个输入包含多个测试用例，每个测试用例第一行给出N,M，接下来N行M列数据代表每个位置上的樱桃个数。（矩阵坐标从（1,1）开始）。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每个测试用例输出第一行为能吃到的最大樱桃个数，接下来为小蛇所需要走的路线的坐标，每个坐标占一行。<br><a id="more"></a></p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><!--more-->
<pre>4 4
1 2 3 7
3 4 2 1
1 5 4 8
10 3 0 3
</pre>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><pre>28
(1,1)
(2,1)
(2,2)
(3,2)
(3,3)
(3,4)
(4,4)
</pre>

<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="mailto:icpc7th@ahstu" target="_blank" rel="noopener">icpc7th@ahstu</a></p>
</blockquote>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><font color="#ff0000">这一题需要用到动态规划，由于贪吃蛇每次只能往右或往下走，所以对于每一个格子而言，当前格子的最大值（dp[i][j]） =&#160; 当前格子的值（a[i][j]） + max{当前格子上方格子的最大值dp[i-1][j],&#160; 当前格子左方格子的最大值dp[i][j-1]}。</font>

<font color="#ff0000">即 表达式为dp[i][j] = a[i][j] + max(dp[i-1][j], dp[i][j-1])</font>

<font color="#ff0000">好了，最大值即为dp[n][m]， 求出了最大值，就需要求路径了，因为我们之前把每个格子的最大值都求出来了，所以从右下角开始倒推即可，首先将最后一个格子的坐标保存起来，我是放在在了stack中，然后依次放入当前上方的格子或左边的格子的坐标，因为当前格子的最大值是上方或左方格子的最大值+当前格子最初的值得来的，所以只需保存上方和左方格子中较大一个格子的坐标</font>&lt;/p<br><br><p><font color="#ff0000">需要注意的是当到了边界时，在左边界，只可以往上走了，所以需要把格子上方的坐标都保存起来，同理上方也一样，下面给出，c++和Java版的代码</font>

<font color="#ff0000">欢迎大家提出宝贵意见</font>

</p><p><strong>c++</strong></p>
<pre><code>#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;stack&amp;gt;

using namespace std;

stack&amp;lt;int&amp;gt; st;
int a[101][101], dp[101][101], n, m;

void scan()
{
    for (int i=1; i&amp;lt;=n; i++)
        for (int j=1; j&amp;lt;=m; j++)
            scanf(&quot;%d&quot;, &amp;amp;a[i][j]);
    for (int i=0; i&amp;lt;=n; i++)
        dp[i][0] = 0;
    for (int j=0; j&amp;lt;=m; j++)
        dp[0][j] = 0;
}

int solve()
{
    for (int i=1; i&amp;lt;=n; i++)
        for (int j=1; j&amp;lt;=m; j++)
            dp[i][j] = a[i][j] + max(dp[i-1][j], dp[i][j-1]);
    return dp[n][m];
}

void Pu(int n, int m)
{
    st.push(m);
    st.push(n);
    if (n == 1 &amp;amp;&amp;amp; m == 1)
        return;
    else if (n == 1 &amp;amp;&amp;amp; m &amp;gt; 1)
        Pu(n, m-1);
    else if (n &amp;gt; 1 &amp;amp;&amp;amp; m == 1)
        Pu(n-1, m);
    else {
        if (dp[n-1][m] &amp;gt; dp[n][m-1])
            Pu(n-1, m);
        else
            Pu(n, m-1);
    }
}

void printPath()
{
    Pu(n, m);
    while (!st.empty()){
        printf(&quot;(%d,&quot;, st.top());
        st.pop();
        printf(&quot;%d)\n&quot;, st.top());
        st.pop();
    }
}

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;amp;n, &amp;amp;m)){
        scan();
        printf(&quot;%d\n&quot;, solve());
        printPath();
    }
    return 0;
}
`&lt;/pre&gt;

**java**

&lt;pre&gt;`import java.util.Scanner;
import java.util.Stack;

public class P1369 {
    static int n, m, a[][], dp[][];
    static Stack&amp;lt;Integer&amp;gt; stack;
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        while (cin.hasNext()) {
            n = cin.nextInt();
            m = cin.nextInt();
            a = new int[n+1][m+1];
            dp = new int[n+1][m+1];
            for (int i=1; i&amp;lt;=n; i++) {
                for (int j=1; j&amp;lt;=m; j++)
                    a[i][j] = cin.nextInt();
            }
            System.out.println(solve());
            printPath();
        }
        cin.close();
    }
    private static void printPath() {
        stack = new Stack&amp;lt;&amp;gt;();
        Pu(n, m);
        while (!stack.isEmpty()) {
            System.out.println(&quot;(&quot;+stack.pop()+&quot;,&quot;+stack.pop()+&quot;)&quot;);
        }
        stack.removeAllElements();
    }
    private static void Pu(int n, int m) {
        stack.push(m);
        stack.push(n);
        if (n == 1 &amp;amp;&amp;amp; m == 1)
            return;
        else if (n == 1 &amp;amp;&amp;amp; m &amp;gt; 1)
            Pu(n, m-1);
        else if (n &amp;gt; 1 &amp;amp;&amp;amp; m == 1)
            Pu(n-1, m);
        else {
            if (dp[n-1][m] &amp;gt; dp[n][m-1])
                Pu(n-1, m);
            else
                Pu(n, m-1);
        }
    }
    private static int solve() {
        for (int i=0; i&amp;lt;=n; i++)
            dp[i][0] = 0;
        for (int j=0; j&amp;lt;=m; j++)
            dp[0][j] = 0;
        for (int i=1; i&amp;lt;=n; i++) {
            for (int j=1; j&amp;lt;=m; j++) {
                dp[i][j] = a[i][j] + Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[n][m];
    }
}
</code></pre>]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>akoj-1222-炸金花</title>
    <url>/2015/06/06/akoj-1222-e7-82-b8-e9-87-91-e8-8a-b1/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">炸金花</span></p>
<p>Time Limit:1000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:40 Accepted:19</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">　炸金花是一个风靡全球的扑克游戏，喜欢玩他的人不计其数，不少人因为这个游戏发了家，而更多的人则输得倾家荡产。为了帮助赌徒们戒掉它，安徽科技学院决定派你去写一个程序，帮助赌徒们更好的认识这个游戏。&nbsp;</span></p>
<p>　　炸金花在这里被简化成这样一个情况：每一个人都会被随机的发到1~13中的任意三张牌，然后比较大小。比较大小的方式是这样的：&nbsp;</p>
<p>　　豹子：即三张一样的牌，同类型的豹子，数字大的更大，豹子大于任何其他情况。&nbsp;</p>
<p>　　顺子：即三张递增的连续的牌，比如（4,5,6），（1,2,3），都是顺子的话，谁的点数大则大，顺子大于对子和单张。&nbsp;</p>
<p>　　对子：即两张一样的牌带一张单牌，比如（1,1,4），（2,2,5），都是对子的话，谁的那一对大则大，如果那一对也一样，则比较单张的大小。对子大于单张。&nbsp;</p>
<p>　　单张：即三张牌不是上述的三种。单张的比较大小方式是，先比较最大的，再比较第二大的，再比较第三大的。&nbsp;</p>
<p>　　你的任务是，对于给定的牌，判断输赢<br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">多组输入，每组输入两行，第一行三个数是你的三张牌，第二行是对手的三张牌&nbsp;</span></p>
<p></p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">每组数据输出，若你赢输出you win，否则you lose</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">9 9 9
7 8 9</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px"></span></p>
<pre><span style="font-family:Times New Roman; font-size:14px">you win</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Source</span></strong></p>
<p><span style="color:#ff0000">这个题只需不断的分类，但感觉自己写的这代码量还是有点多了，欢迎大家来此评论</span></p>
<p><strong><span style="font-size:24px; color:#333399"></span></strong></p>
<pre name="code" class="cpp">#include <stdio.h>

void my_sort(int *x, int *y, int *z)
{
    int t;
    if ( *x > *y ) { t = *x; *x = *y; *y = t; }
    if ( *x > *z ) { t = *x; *x = *z; *z = t; }
    if ( *y > *z ) { t = *y; *y = *z; *z = t; }
}

int judge_1(int *x, int *y, int *z)
{
    if ( *x == *y && *y == *z )
        return 1;
    return 0;
}

int judge_2(int *x, int *y, int *z)
{
    if ( *y == *x + 1 && *y == *z -1 )
        return 1;
    return 0;
}

int judge_3(int *x, int *y, int *z)
{
    if ( *x == *y )
        return *x;
    else if ( *y == *z ) {
        return *y;
    }
    return 0;
}

int judge_4(int *x, int *y, int *z)
{
    if ( *x == *y )
        return *z;
    else if ( *y == *z ) {
        return *x;
    }
    return 0;
}

void printY()
{
    printf("you win\n");
}

void printN()
{
    printf("you lose\n");
}

int main()
{
    int a, b, c, x, y, z;
    while ( ~scanf("%d%d%d%", &a, &b, &c) )
    {
        scanf("%d%d%d", &x, &y, &z);
        my_sort(&a, &b, &c);
        my_sort(&x, &y, &c);
        if ( judge_1(&a, &b, &c) ) {
            if ( judge_1(&x, &y, &z) ) {
                if ( c > z ) {
                    printY();
                }
                else {
                    printN();
                }
            }
            else {
                printY();
            }
        }
        else if ( judge_2(&a, &b, &c) ) {
            if ( judge_2(&x, &y, &z) ) {
                if ( c > z ) {
                    printY();
                }
                else {
                    printN();
                }
            }
            else {
                printY();
            }
        }
        else if ( judge_3(&a, &b, &c) ) {
            if ( judge_3(&x, &y, &z) ) {
                if ( judge_3(&a, &b, &c) > judge_3(&x, &y, &z) ) {
                    printY();
                }
                else if ( judge_3(&a, &b, &c) < judge_3(&x, &y, &z) ) {
                    printN();
                }
                else if ( judge_4(&a, &b, &c) > judge_4(&x, &y, &z) ) {
                    printY();
                }
                else {
                    printN();
                }
            }
            else {
                printY();
            }
        }
        else  {
            if ( c > z ) {
                printY();
            }
            else if ( c < z ) {
                printN();
            }
            else if ( b > y ) {
                printY();
            }
            else if ( b < y ) {
                printN();
            }
            else if ( a > x ) {
                printY();
            }
            else if ( a < x ) {
                printN();
            }
        }
    }

    return 0;
}</stdio.h></pre>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>AKOJ -- 1529 -- 寻找最大数</title>
    <url>/2017/06/30/akoj-1529-e5-af-bb-e6-89-be-e6-9c-80-e5-a4-a7-e6-95-b0/</url>
    <content><![CDATA[<center><br><br><div><br><br>## 1529: 寻找最大数<br><br><span style="color:green">Time Limit:&nbsp;</span>1 Sec&nbsp;&nbsp;<span style="color:green">Memory Limit:&nbsp;</span>128 MB<br><br><span style="color:green">Submit:&nbsp;</span>107&nbsp;&nbsp;<span style="color:green">Solved:&nbsp;</span>53<br><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1528" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1529" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1529" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1529" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1529&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1530" target="_blank" rel="noopener">下一题</a></div><br><br></center>

<div><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>给出一个整数n每次可以移动相邻数位上的数字，最多移动k次，得到一个新的整数，求这个新的整数的最大值是多少。<br><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>多组测试数据。<br><br>每组测试数据占一行，每行有两个数N和K (1 ≤ N≤ 10^100; 0 ≤ K ≤ 100).<br><br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)">每组测试数据的输出占一行，输出移动后得到的新的整数的最大值。</div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(51,51,51)">1990 1</div><br><div style="color:rgb(51,51,51)">100 0</div><br><div style="color:rgb(51,51,51)">9090000078001234 6</div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div style="color:rgb(51,51,51)">9190</div><br><div style="color:rgb(51,51,51)">100</div><br><div style="color:rgb(51,51,51)">9907000008001234</div>

<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><a id="more"></a>
<div><br><br>/<em><a href="https://oj.ahstu.cc/JudgeOnline/problemset.php?search=&amp;v=pro" target="_blank" rel="noopener"></a><br><br><span style="font-size:14px">这道题主要是用到贪心算法，还是比较好理解</span><br><br><span style="font-size:14px">一个字符串a[n], 从a[0]开始，到a[n-1]依次与后面的进行替换</span><br><br><span style="font-size:14px">贪心规则：每次需要与后面的length-i个元素相比较，找到最大的替换到i的位置</span><br><br><span style="font-size:14px">算法：每次从头开始，以一个位置为起点，在可移动步数内找一个最大值，然后移动到起点 ，可移动步数减去当前移动步数。如果还可移动在从头开始找。</span>

</em>/<br><br><pre code_snippet_id="2466274" snippet_file_name="blog_20170630_1_2003248" name="code" class="java">import java.util.Scanner;<br><br>/*<em>
 </em> Created by fan on 17-6-30.<br> */<br>public class P1529 {<br>    public static void main(String[] args) {<br>        Scanner cin = new Scanner(System.in);<br>        while (cin.hasNext()) {<br>            String n = cin.next();<br>            int k = cin.nextInt();<br>            solve(n, k);<br>        }<br>        cin.close();<br>    }<br><br>    private static void solve(String s, int k) {<br>        char a[] = s.toCharArray();<br>       for (int i=0; i&lt;a.length-1 &amp;&amp; k!=0; i++) {<br>           char maxc = a[i]; //maxc 存储a[i]后的最大元素<br>           int maxi = i;  //maxi 存储a[i]后的最大元素的下标<br>           for (int j=i+1; j&lt;=k+i &amp;&amp; j&lt;a.length; j++) { //for 用于查找a[i]后的最大元素（k步以内最大元素）<br>                if (maxc &lt; a[j]) {<br>                    maxc = a[j];<br>                    maxi = j;<br>                }<br>           }<br>           for (int j=maxi; j&gt;i; j–) { //找到最大元素就依次交换<br>               char t = a[j];<br>               a[j] = a[j-1];<br>               a[j-1] = t;<br>           }<br>           k = k - (maxi - i); // 更新现在的可移动步数<br>           //..如果还有步数则继续，从第二个元素开始继续进行贪心<br>       }<br>        System.out.println(new String(a));<br>    }<br>}<br></pre><br><br></div><br><center><br><div style="color:red"><br><br></div><br></center><br></div>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】colorAccent,colorPrimary,colorPrimaryDark……来这里你就明白了</title>
    <url>/2017/11/30/android-color/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/ec9cc0658457df4baf8abed904334935.png" alt="android-color"><br><a id="more"></a></p>
<p><a href="http://www.aoaoyi.com/archives/623.html" target="_blank" rel="noopener">原文传送门</a></p>
<p>伴随着Android5.0的发布也更新了support-v7-appcompat 到V21，其中增加了ToolBar、recyclerview、cardview等控件。<br>Android5.0对改变APP样式下了不小的功夫，写法也和以前不一样了，下面先简单介绍一下colorAccent,colorPrimary,colorPrimaryDark……的作用：<br><img src="https://cdn.fayne.cn/5d4fc3295e88f97e719622b198e0df29.png" alt="android-color"></p>
<ol>
<li>colorPrimary 应用的主要色调，actionBar默认使用该颜色Toolbar导航栏的底色</li>
</ol>
<ul>
<li>colorPrimaryDark 应用的主要暗色调，statusBarColor默认使用该颜色</li>
<li>statusBarColor 状态栏颜色，默认使用colorPrimaryDark</li>
<li>windowBackground 窗口背景颜色</li>
<li>navigationBarColor 底部栏颜色</li>
<li>colorForeground 应用的前景色，ListView的分割线，switch滑动区默认使用该颜色</li>
<li>colorBackground 应用的背景色，popMenu的背景默认使用该颜色</li>
<li>colorAccent CheckBox，RadioButton，SwitchCompat等一般控件的选中效果默认采用该颜色</li>
<li>colorControlNormal CheckBox，RadioButton，SwitchCompat等默认状态的颜色。</li>
<li>colorControlHighlight 控件按压时的色调</li>
<li>colorControlActivated 控件选中时的颜色，默认使用colorAccent</li>
<li>colorButtonNormal 默认按钮的背景颜色</li>
<li>editTextColor：默认EditView输入框字体的颜色。</li>
<li>textColor Button，textView的文字颜色</li>
<li>textColorPrimaryDisableOnly RadioButton checkbox等控件的文字</li>
<li>textColorPrimary 应用的主要文字颜色，actionBar的标题文字默认使用该颜色</li>
<li>colorSwitchThumbNormal: switch thumbs 默认状态的颜色. (switch off)</li>
</ul>
<p>这样是不是更清晰理解了这些Color的作用，更多分享敬请下回分析。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android定制之Ubuntu下常见问题及解决</title>
    <url>/2018/08/26/android-linux-note/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/o-linux.png" alt="Android-O"><br><a id="more"></a></p>
<h2 id="解决chrome打不开"><a href="#解决chrome打不开" class="headerlink" title="解决chrome打不开"></a>解决chrome打不开</h2><p>初次安装操作系统后, 安装Chrome浏览器发现点击无任何反应, 可以尝试以下命令解决<br><code>sudo apt install --reinstall libnss3</code></p>
<h2 id="滚动条替换"><a href="#滚动条替换" class="headerlink" title="滚动条替换"></a>滚动条替换</h2><p>Ubuntu默认的滚动条显示不好用, 而且不易操作, 可以换为以下滚动条<br><code>gsettings set com.canonical.desktop.interface scrollbar-mode normal</code><br>恢复为默认滚动条样式命令：<br><code>gsettings reset com.canonical.desktop.interface scrollbar-mode</code></p>
<h2 id="MTK刷机错误S-UNDEFINED-ERROR-1001"><a href="#MTK刷机错误S-UNDEFINED-ERROR-1001" class="headerlink" title="MTK刷机错误S_UNDEFINED_ERROR (1001)"></a>MTK刷机错误S_UNDEFINED_ERROR (1001)</h2><p>当在ubuntu 14.04 或是更高版本使用MTK的Smart Phone Flash Tool 工具刷机时，会遇到一个错误：<br>BROM ERROR : S_UNDEFINED_ERROR (1001)<br>是由于 modemmanager包在ubuntu 14.04或是更高版本中对于MTK的Flash工具支持不完全，所造成的，如果想使用MTK 的 Flash　工具，就要卸载这个包</p>
<ul>
<li>执行以下命令：<br><code>sudo apt-get remove modemmanager</code></li>
<li>然后重启udev服务<br><code>sudo service udev restart</code></li>
<li>卸载这个服务之后可能会造成内核模块　cdc_acm　不可用．执行以下命令进行检查<br><code>lsmod | grep cdc_acm</code></li>
<li>如果没有输出，执行<br><code>sudo modprobe cdc_acm</code><br>完成后，可以正常刷机了<h2 id="网络共享不能打开-smb-报错-this-location-could-not-be-displayed"><a href="#网络共享不能打开-smb-报错-this-location-could-not-be-displayed" class="headerlink" title="网络共享不能打开(smb://#### 报错 this location could not be displayed)"></a>网络共享不能打开(smb://#### 报错 this location could not be displayed)</h2>修复命令<code>sudo apt-get install gvfs-backends</code><h2 id="命令行右键消失"><a href="#命令行右键消失" class="headerlink" title="命令行右键消失"></a>命令行右键消失</h2><code>sudo apt-get install nautilus-open-terminal</code></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android数据储存方案</title>
    <url>/2017/10/31/android-data-save/</url>
    <content><![CDATA[<blockquote>
<p>Android数据常用的储存方案，分别如下</p>
</blockquote>
<h2 id="文件储存数据"><a href="#文件储存数据" class="headerlink" title="文件储存数据"></a>文件储存数据</h2><h3 id="将文件储存到文件中"><a href="#将文件储存到文件中" class="headerlink" title="将文件储存到文件中"></a>将文件储存到文件中</h3><p><code>Context</code>类提供了一个<code>openFileOutput()</code>方法，可以用于将数据文件储存到指定的文件中。这个方法接收两个参数，第一个参数文件名，可以不包含路径，默认储存位置<code>/data/data/&lt;package-name&gt;/files/</code>目录下，第二个参数是文件的操作模式，<code>MODE_PRIVATE</code>和<code>MODE_APPEND</code>，其中<code>MODE_PRIVATE</code>是默认的操作模式，表示同名文件时覆盖原文件，后者则表示追加<br><a id="more"></a><br><code>OpenFileOuput()</code>方法返回的是一个<code>FileOutputStream</code>对象，得到这个对象就可以使用<code>Java</code>流的方式将文件写入到文件中了</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String inputText)</span> </span>&#123;</span><br><span class="line">    FileOutputStream out;</span><br><span class="line">    BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 得到一个FileOutputStream对象</span></span><br><span class="line">        out = openFileOutput(<span class="string">"data"</span>, Context.MODE_PRIVATE);</span><br><span class="line">        <span class="comment">// 构建出一个OutputStreamWriter对象</span></span><br><span class="line">        <span class="comment">// 再使用OutputStreamWriter构建出一个BufferedWriter对象</span></span><br><span class="line">        writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">        <span class="comment">// 使用BufferedWriter来将文本内容写入到文件中</span></span><br><span class="line">        writer.write(inputText);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>MainActivity</code>中的代码，布局加入<code>EditText</code>，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText edit;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        edit = findViewById(R.id.edit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 重写onDestroy()，保证销毁前一定会调用这个方法</span></span><br><span class="line">        String inputText = edit.getText().toString();</span><br><span class="line">        save(inputText);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...save()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><p>类似的，<code>Context</code>类提供一个<code>openFileInput()</code>方法，用于从文件中读取数据。它只接收一个参数，即要读取的文件文件名，然后系统会自动到<code>/data/data/&lt;package-name&gt;/files/</code>中去加载这个文件，并返回一个<code>FileInputStream</code>对象，得到这个对象再通过Java流的方式就可以将数据读取出来了。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream in;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 得到一个FileInputStream对象</span></span><br><span class="line">        in = openFileInput(<span class="string">"data"</span>);</span><br><span class="line">        <span class="comment">// 使用InputStreamReader构建出一个BufferedReader对象</span></span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">        String line;<span class="comment">// 使用BufferedReader 逐行读取，把文件中所有的文本内容全部读取出来存放到StringBuilder中</span></span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            content.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> content.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>MainActivity</code>实现<code>EditText</code>能够保存上次输入的内容<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText edit;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        String inputText = load();</span><br><span class="line">        edit = findViewById(R.id.edit);</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(inputText)) &#123;</span><br><span class="line">            edit.setText(inputText);</span><br><span class="line">            edit.setSelection(inputText.length());</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"Restoring successed"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...save()</span></span><br><span class="line">    <span class="comment">//...load()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用SharePreferences储存数据"><a href="#使用SharePreferences储存数据" class="headerlink" title="使用SharePreferences储存数据"></a>使用SharePreferences储存数据</h2><h3 id="将数据储存到SharedPreferences中"><a href="#将数据储存到SharedPreferences中" class="headerlink" title="将数据储存到SharedPreferences中"></a>将数据储存到SharedPreferences中</h3><p><code>SharePreferences</code>是用键值对的方式来储存数据的。每当保存一条数据，需要给这条数据提供相应的键，这样在读取文件的时候就可以通过这个键把相应的值取出来。而且<code>SharePreferences</code>还支持多种不同的数据类型的储存</p>
<h4 id="Android提供了三种得到SharePreferences的方法"><a href="#Android提供了三种得到SharePreferences的方法" class="headerlink" title="Android提供了三种得到SharePreferences的方法"></a>Android提供了三种得到<code>SharePreferences</code>的方法</h4><ol>
<li><code>Context</code>类中的<code>getSharePreferences()</code>方法<br>此方法接收两个参数，第一个用于指定<code>SharePreferences</code>文件的名称，如果指定的文件不存在则会创建一个，<code>SharePreferences</code>文件都是放在<code>/data/data/&lt;package-name&gt;/shared_prefs/</code>目录下的。第二个参数用于指定操作模式，主要有两种模式可以选择，<code>MODE_PRIVATE</code>和<code>MODE_MULTI_PROCESS</code>,<code>MODE_PRIVATE</code>仍然是默认的操作模式，表示当前的应用程序才会对<code>SharePreferences</code>文件进行读写。<code>MODE_MULTI_PROCESS</code>则一般用于会有多个进程中对同一个文件进行读写的情况</li>
<li><code>Activity</code>类中的<code>getPreferences()</code>方法<br>这个方法和<code>Context</code>中的<code>getSharePreferences()</code>方法类似，不过它只接收一个操作模式的参数，因为使用这个方法时会自动将当前活动的类名作为<code>SharePreferences</code>的文件名</li>
<li><code>PreferenceManeger</code>类中的<code>getDefaultSharePreferences</code>方法<br>这是一个静态方法，它接收一个<code>Context</code>参数，并自动使用当前应用程序的包名作为前缀来命名<code>SharePreferences</code>文件，操作可分为三步<ol>
<li>调用<code>SharePreferences</code>对象的<code>edit()</code>方法来获取一个<code>SharePreferences.Edit</code>对象。</li>
<li>向<code>SharePreferences.Edit</code>对象中添加数据，比如添加一个布尔型数据就使用<code>putBoolean</code>方法，以此类推</li>
<li>调用<code>apply()</code>方法将添加的数据提交，从而完成数据储存的操作</li>
</ol>
</li>
</ol>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button btnSaveData;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        btnSaveData = findViewById(R.id.btnSaveData);</span><br><span class="line">        btnSaveData.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// 通过getSharedPreferences()方法指定SharedPreferences的文件名为data，并得到SharedPreferences.Editor对象。</span></span><br><span class="line">                SharedPreferences.Editor editor = getSharedPreferences(<span class="string">"data"</span>, MODE_PRIVATE).edit();</span><br><span class="line">                editor.putString(<span class="string">"name"</span>, <span class="string">"Tom"</span>);</span><br><span class="line">                editor.putInt(<span class="string">"age"</span>, <span class="number">28</span>);</span><br><span class="line">                editor.putBoolean(<span class="string">"married"</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 调用apply()方法进行提交</span></span><br><span class="line">                editor.apply();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从SharedPreferences中读取数据"><a href="#从SharedPreferences中读取数据" class="headerlink" title="从SharedPreferences中读取数据"></a>从SharedPreferences中读取数据</h3><p>//TODO 未完待续</p>
<h2 id="SQLite数据库储存数据"><a href="#SQLite数据库储存数据" class="headerlink" title="SQLite数据库储存数据"></a>SQLite数据库储存数据</h2>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓学习笔记</title>
    <url>/2017/09/27/android-study01/</url>
    <content><![CDATA[<h2 id="目录分析"><a href="#目录分析" class="headerlink" title="目录分析"></a>目录分析</h2><ul>
<li><code>src</code> 代码目录(放置所有Java代码)</li>
<li><code>gen</code> 这个目录是自动生成的，主要有一个R.java文件，在项目中添加的任何文件都会生成一个相应的资源id</li>
<li><code>assets</code> 存放一些随程序打包的文件（用的不多），程序运行时可以动态读取这些文件的内容</li>
<li><code>bin</code> 编译时自动产生的文件。其中会有一个是你当前项目编译好的安装包</li>
<li><code>libs</code> 存放第三方jar包。这个目录下的jar包会被自动添加到构建路径中去</li>
<li><code>res</code> 资源目录，使用到的所有图片，布局，字符串等资源。上述的R.java中的内容也是根据这个目录下的文件自动生成的。有很多子目录，其中drawable目录存放图片，布局放在layout目录下，字符串放在values目录下</li>
<li><code>AndroidManifest.xml</code> 整个Android项目的配置文件，在程序中定义的所有四大组件都需要在这文件里注册，另外还可以在这个文件中给出应用程序权限声明<a id="more"></a></li>
<li><code>project.properties</code> 通过一行代码指定了编译程序所使用的SDK版本</li>
</ul>
<h2 id="使用Android的日志工具-Log"><a href="#使用Android的日志工具-Log" class="headerlink" title="使用Android的日志工具 Log"></a>使用Android的日志工具 Log</h2><ul>
<li><code>Log.v()</code> 打印最琐碎的，意义最小的日志信息。对应级别verbose，是Android日志中级别最低的一种</li>
<li><code>Log.d()</code> 打印一些调试信息。对应级别debug，比verbose高一级</li>
<li><code>Log.i()</code> 打印一下比较重要的数据，这些数据应该是你非常想看到的，可以帮你分析用户行为的哪种，对应级别info，比debug高一级</li>
<li><code>Log.w()</code> 打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些警告的地方。对用级别warn，比info高一级</li>
<li><code>Log.e()</code> 打印程序中的错误信息，比如程序进入到了catch语句中。当有错误信息打印出来的时候，一般都代表你程序出现了严重的问题了，必须尽快修复。对应级别error，比warn高一级</li>
</ul>
<p><code>Log.d</code>方法中传入了两个参数，第一个参数是tag，一般传入当前的类名就好，主要用于对打印信息进行过滤，第二个参数是msg，即想到要打印的具体的内容</p>
<p>System.out.println()与Log，Log和Logcat配合起来很强大，可以添加过滤器，但前者处理起来很麻烦。后者检查日志更加专业，方便</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom上传图片错误卡死img.toPng is not a function</title>
    <url>/2019/07/27/atom-error-img-toPng/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/50065f575b3fa1cb59c92132f7a4204c.png" alt="Atom_Error"><br><a id="more"></a></p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>今天在使用七牛图床的时候发现错误<br> TypeError: img.toPng is not a function<br> 报错导致图片上传失败，如上图，卡死在这个位置，只有退出Atom才行</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>路径: <code>user/.atom/packages/markdown-assistant/lib/main.coffee</code>57行<ul>
<li>将`uploadFn = (callback)-&gt;<pre><code>uploaderIns.upload(img.toPng(), &apos;png&apos;, callback)`
</code></pre></li>
<li>修改为<br>`uploadFn = (callback)-&gt;<pre><code>uploaderIns.upload(img.toPNG(), &apos;png&apos;, callback)`
</code></pre>即可</li>
</ul>
</li>
</ul>
<blockquote>
<p>修改main.coffee第57行代码api名称改变</p>
</blockquote>
<p><img src="https://cdn.fayne.cn/a2d033f8422b317e0390bf853703f0e2.png" alt="error_atom"></p>
<p><img src="https://cdn.fayne.cn/3ef317c5d9e779ab93aa540bf8e13c22.png" alt="atom_config"></p>
<blockquote>
<p>以上，就可以愉快的贴图了</p>
</blockquote>
]]></content>
      <categories>
        <category>Atom</category>
      </categories>
      <tags>
        <tag>error</tag>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title>Android定制之常见问题解决</title>
    <url>/2018/08/26/android-note/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/o-hero.jpg" alt="Android-O"><br><a id="more"></a></p>
<blockquote>
<p>此修改基于MTK|SPRD平台，Android O/Android GO</p>
</blockquote>
<h2 id="状态栏默认显示电量百分比"><a href="#状态栏默认显示电量百分比" class="headerlink" title="状态栏默认显示电量百分比"></a>状态栏默认显示电量百分比</h2><p>frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java<br>这样修改不知道是不是不规范, 因为注释IMPORTANT: Do not add any more upgrade steps here as the global<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">2338</span>,<span class="number">7</span> +<span class="number">2338</span>,<span class="number">12</span> @@ <span class="class"><span class="keyword">class</span> <span class="title">DatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">             <span class="comment">// set default button light timeout.</span></span><br><span class="line">             loadIntegerSetting(stmt, Settings.System.BUTTON_LIGHT_OFF_TIMEOUT,</span><br><span class="line">                     R.integer.def_button_light_off_timeout);</span><br><span class="line">-</span><br><span class="line">+            <span class="comment">//add for default show battery percent @2018-08-09 &#123;</span></span><br><span class="line">+            <span class="keyword">if</span> (SystemProperties.getBoolean(<span class="string">"ro.bdfun.show_battery_perecnt"</span>, <span class="keyword">true</span>))&#123;</span><br><span class="line">+                loadSetting(stmt, Settings.System.SHOW_BATTERY_PERCENT, <span class="number">1</span>);</span><br><span class="line">+            &#125;</span><br><span class="line">+            <span class="comment">/// @&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">              * IMPORTANT: Do not add any more upgrade steps here as the global,</span></span><br><span class="line"><span class="comment">              * secure, and system settings are no longer stored in a database</span></span><br></pre></td></tr></table></figure></p>
<h2 id="关闭未知来源-包括所有系统软件"><a href="#关闭未知来源-包括所有系统软件" class="headerlink" title="关闭未知来源, 包括所有系统软件"></a>关闭未知来源, 包括所有系统软件</h2><p>设置-应用和通知-高级-特殊应用权限-安装未知应用<br>frameworks/base//core/java/android/app/AppOpsManager.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">957</span>,<span class="number">7</span> +<span class="number">957</span>,<span class="number">7</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppOpsManager</span> </span>&#123;</span><br><span class="line">             AppOpsManager.MODE_ALLOWED,  <span class="comment">// OP_RUN_IN_BACKGROUND</span></span><br><span class="line">             AppOpsManager.MODE_ALLOWED,  <span class="comment">// OP_AUDIO_ACCESSIBILITY_VOLUME</span></span><br><span class="line">             AppOpsManager.MODE_ALLOWED,</span><br><span class="line">-            AppOpsManager.MODE_DEFAULT,  <span class="comment">// OP_REQUEST_INSTALL_PACKAGES</span></span><br><span class="line">+            AppOpsManager.MODE_ERRORED,  <span class="comment">// OP_REQUEST_INSTALL_PACKAGES // modified  for turn off unknown source default</span></span><br><span class="line">             AppOpsManager.MODE_ALLOWED,  <span class="comment">// OP_PICTURE_IN_PICTURE</span></span><br><span class="line">             AppOpsManager.MODE_DEFAULT,  <span class="comment">// OP_INSTANT_APP_START_FOREGROUND</span></span><br><span class="line">             AppOpsManager.MODE_ALLOWED, <span class="comment">// ANSWER_PHONE_CALLS</span></span><br></pre></td></tr></table></figure></p>
<p>//Android O已经默认移除了总开关未知来源选项框, 随之添加的是对有安装应用权限的应用的未知来源选项, 但是发现这样修改后是默认关闭了所以应用的未知来源选项, 却发现所有应用的显示出来了(没有安装应用权限的应用是没有必要显示的), 这样修改貌似不是很科学</p>
<h2 id="不开移动数据不能发送彩信"><a href="#不开移动数据不能发送彩信" class="headerlink" title="不开移动数据不能发送彩信"></a>不开移动数据不能发送彩信</h2><p>vendor/mediatek/proprietary/frameworks/opt/telephony<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">52</span>,<span class="number">6</span> +<span class="number">52</span>,<span class="number">7</span> @@ <span class="keyword">import</span> com.mediatek.internal.telephony.MtkGsmCdmaPhone;</span><br><span class="line"> <span class="keyword">import</span> com.mediatek.internal.telephony.MtkPhoneConstants;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">+<span class="keyword">import</span> android.os.SystemProperties; <span class="comment">// add</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/** DataConnectionExt is default implementation for Data Plugin. */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataConnectionExt</span> <span class="keyword">implements</span> <span class="title">IDataConnectionExt</span> </span>&#123;</span><br><span class="line">@@ -<span class="number">82</span>,<span class="number">7</span> +<span class="number">83</span>,<span class="number">7</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataConnectionExt</span> <span class="keyword">implements</span> <span class="title">IDataConnectionExt</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDataAllowedAsOff</span><span class="params">(String apnType)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DEFAULT) ||</span><br><span class="line">-                TextUtils.equals(apnType, PhoneConstants.APN_TYPE_MMS) ||</span><br><span class="line">+                (!SystemProperties.getBoolean(<span class="string">"ro.func.open_nodata_send_mms"</span>, <span class="keyword">false</span>) &amp;&amp; TextUtils.equals(apnType, PhoneConstants.APN_TYPE_MMS)) ||  <span class="comment">// add for no internet connect to send mm</span></span><br><span class="line">                 TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DUN)) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="图标图标字体显示不全，修改为显示两行"><a href="#图标图标字体显示不全，修改为显示两行" class="headerlink" title="图标图标字体显示不全，修改为显示两行"></a>图标图标字体显示不全，修改为显示两行</h2><p>这里对于图标字体显示不全当然还可以改为跑马灯效果<br>// 如需修改Luncher3文件夹的两行显示, 也在DeviceProfile.java文件中, 方法类似<br>  packages/apps/Launcher3/src/com/android/launcher3/BubbleTextView.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span> <span class="keyword">implements</span> <span class="title">ItemInfoUpdateReceiver</span> </span>&#123;</span><br><span class="line">+       setSingleLine(<span class="keyword">false</span>);</span><br><span class="line">+       setMaxlines(<span class="number">2</span>);</span><br><span class="line">+       setTextSize(TypedValue.COMPLEX_UNIT_SP, <span class="number">13</span>); <span class="comment">// 字体大小视情况决定</span></span><br></pre></td></tr></table></figure></p>
<p>  packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java b/src/com/android/launcher3/DeviceProfile.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceProfile</span> </span>&#123;</span><br><span class="line">         iconDrawablePaddingPx = (<span class="keyword">int</span>) (iconDrawablePaddingOriginalPx * scale);</span><br><span class="line"></span><br><span class="line">         cellHeightPx = iconSizePx + iconDrawablePaddingPx</span><br><span class="line">-                + Utilities.calculateTextHeight(iconTextSizePx);</span><br><span class="line">+                + Utilities.calculateTextHeight(iconTextSizePx) * <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">int</span> cellYPadding = (getCellSize().y - cellHeightPx) / <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span> (iconDrawablePaddingPx &gt; cellYPadding &amp;&amp; !isVerticalBarLayout()</span><br><span class="line">                 &amp;&amp; !inMultiWindowMode()) &#123;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceProfile</span> </span>&#123;</span><br><span class="line">         allAppsIconTextSizePx = iconTextSizePx;</span><br><span class="line">         allAppsIconSizePx = iconSizePx;</span><br><span class="line">         allAppsIconDrawablePaddingPx = iconDrawablePaddingPx;</span><br><span class="line">-        allAppsCellHeightPx = getCellSize().y;</span><br><span class="line">+        allAppsCellHeightPx = getCellSize().y + Utilities.calculateTextHeight(iconTextSizePx);</span><br><span class="line">         <span class="keyword">if</span> (isVerticalBarLayout()) &#123;</span><br><span class="line">        <span class="comment">// Always hide the Workspace text with vertical bar layout.</span></span><br></pre></td></tr></table></figure>
<h2 id="客户要求，将CARD改为SIM"><a href="#客户要求，将CARD改为SIM" class="headerlink" title="客户要求，将CARD改为SIM"></a>客户要求，将CARD改为SIM</h2><p>  vendor/mediatek/proprietary/packages/apps/SystemUI/<br>  src/com/mediatek/keyguard/Telephony/KeyguardSimPinPukMeView.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyguardSimPinPukMeView</span> <span class="keyword">extends</span> <span class="title">KeyguardPinBasedInputView</span> </span>&#123;</span><br><span class="line">             <span class="comment">///   fetch the latest/updated active sub list.</span></span><br><span class="line">             SubscriptionInfo info = mUpdateMonitor.getSubscriptionInfoForSubId(subId, forceReload);</span><br><span class="line">             CharSequence displayName = info != <span class="keyword">null</span> ? info.getDisplayName() : <span class="string">""</span>; <span class="comment">// don't crash</span></span><br><span class="line">+            displayName = ((String) displayName).replace(<span class="string">"CARD 1"</span>,<span class="string">"SIM 1"</span>).replace(<span class="string">"CARD 2"</span>,<span class="string">"SIM 2"</span>);</span><br><span class="line">             <span class="comment">// M: add for ALPS02475558</span></span><br><span class="line">             <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">-                displayName = <span class="string">"CARD "</span> + Integer.toString(mPhoneId + <span class="number">1</span>);</span><br><span class="line">+                displayName = <span class="string">"SIM "</span> + Integer.toString(mPhoneId + <span class="number">1</span>);</span><br><span class="line">                 Log.d(TAG, <span class="string">"we set a displayname"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             Log.d(TAG, <span class="string">"resetState() - subId = "</span> + subId + <span class="string">", displayName = "</span> + displayName) ;</span><br></pre></td></tr></table></figure></p>
<p>  vendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/sim/SimDialogActivity.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimDialogActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">        mSimManagementExt.setCurrNetworkIcon(holder.icon, mDialogId, position);</span><br><span class="line">        holder.icon.setAlpha(OPACITY);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">-       holder.title.setText(sir.getDisplayName());</span><br><span class="line">+       holder.title.setText((sir.getDisplayName().toString()).replace(<span class="string">"CARD"</span>, <span class="string">"SIM"</span>));</span><br><span class="line">        holder.summary.setText(sir.getNumber());</span><br><span class="line">        holder.icon.setImageBitmap(sir.createIconBitmap(mContext));</span><br></pre></td></tr></table></figure></p>
<h2 id="添加133紧急拨号"><a href="#添加133紧急拨号" class="headerlink" title="添加133紧急拨号"></a>添加133紧急拨号</h2><p>vendor/mediatek/proprietary/external/EccList/ecc_list.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"911"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"112"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"113"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">+    <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"133"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">EccTable</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>vendor/mediatek/proprietary/external/EccList/cdma_ecc_list.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"911"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"112"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"113"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">+    <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"133"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">EccTable</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>vendor/mediatek/proprietary/external/EccList/cdma_ecc_list_ss.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"911"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"112"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"113"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">+    <span class="tag">&lt;<span class="name">EccEntry</span> <span class="attr">Ecc</span>=<span class="string">"133"</span> <span class="attr">Category</span>=<span class="string">"0"</span> <span class="attr">Condition</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">EccTable</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="移除分屏模式"><a href="#移除分屏模式" class="headerlink" title="移除分屏模式"></a>移除分屏模式</h2><p>  frameworks/base/core/res/res/values/config.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">     <span class="comment">&lt;!-- True if the device supports at least one form of multi-window.</span></span><br><span class="line"><span class="comment">          E.g. freeform, split-screen, picture-in-picture. --&gt;</span></span><br><span class="line">-    <span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">"config_supportsMultiWindow"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line">+    <span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">"config_supportsMultiWindow"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- True if the device supports split screen as a form of multi-window. --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">"config_supportsSplitScreenMultiWindow"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="默认APN按顺序显示"><a href="#默认APN按顺序显示" class="headerlink" title="默认APN按顺序显示"></a>默认APN按顺序显示</h2><p>  device/mediatek/common<br>  apns-conf.xml<br>  将需要的接入点设置的放在最上面<br>  vendor/mediatek/proprietary/packages/apps/MtkSettings/ext/src/com/mediatek/settings/ext/DefaultApnSettingsExt.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultApnSettingsExt</span> <span class="keyword">implements</span> <span class="title">IApnSettingsExt</span> </span>&#123;</span><br><span class="line">      */</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getApnSortOrder</span><span class="params">(String order)</span> </span>&#123;</span><br><span class="line">-        <span class="keyword">return</span> order;</span><br><span class="line">+        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="指令添加修改，使用Google-Dialer"><a href="#指令添加修改，使用Google-Dialer" class="headerlink" title="指令添加修改，使用Google Dialer"></a>指令添加修改，使用Google Dialer</h2><p> 需要在AndroidManifest中添加android_secret_code<br> 并在src/com/agenew/peakli/phoneinfo/SecretCodeActivity.java添加对应操作<br>  vendor/mediatek/proprietary/packages/apps/PhoneInfo</p>
<h2 id="声音-勿扰自定义规则不随语言改变切换"><a href="#声音-勿扰自定义规则不随语言改变切换" class="headerlink" title="声音-勿扰自定义规则不随语言改变切换"></a>声音-勿扰自定义规则不随语言改变切换</h2><p>frameworks/base/services/core/java/com/android/server/notification/ZenModeHelper.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">918</span>,<span class="number">7</span> +<span class="number">918</span>,<span class="number">8</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZenModeHelper</span> </span>&#123;</span><br><span class="line">         weeknights.endHour = <span class="number">7</span>;</span><br><span class="line">         <span class="keyword">final</span> ZenRule rule1 = <span class="keyword">new</span> ZenRule();</span><br><span class="line">         rule1.enabled = <span class="keyword">false</span>;</span><br><span class="line">-        rule1.name = mDefaultRuleWeeknightsName;</span><br><span class="line">+        rule1.name = mContext.getResources()</span><br><span class="line">+                .getString(R.string.zen_mode_default_weeknights_name);</span><br><span class="line">         rule1.conditionId = ZenModeConfig.toScheduleConditionId(weeknights);</span><br><span class="line">         rule1.zenMode = Global.ZEN_MODE_ALARMS;</span><br><span class="line">         rule1.component = ScheduleConditionProvider.COMPONENT;</span><br><span class="line">@@ -<span class="number">933</span>,<span class="number">7</span> +<span class="number">934</span>,<span class="number">8</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZenModeHelper</span> </span>&#123;</span><br><span class="line">         weekends.endHour = <span class="number">10</span>;</span><br><span class="line">         <span class="keyword">final</span> ZenRule rule2 = <span class="keyword">new</span> ZenRule();</span><br><span class="line">         rule2.enabled = <span class="keyword">false</span>;</span><br><span class="line">-        rule2.name = mDefaultRuleWeekendsName;</span><br><span class="line">+        rule2.name = mContext.getResources()</span><br><span class="line">+                .getString(R.string.zen_mode_default_weekends_name);</span><br><span class="line">         rule2.conditionId = ZenModeConfig.toScheduleConditionId(weekends);</span><br><span class="line">         rule2.zenMode = Global.ZEN_MODE_ALARMS;</span><br><span class="line">         rule2.component = ScheduleConditionProvider.COMPONENT;</span><br><span class="line">@@ -<span class="number">950</span>,<span class="number">7</span> +<span class="number">952</span>,<span class="number">8</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZenModeHelper</span> </span>&#123;</span><br><span class="line">         events.reply = EventInfo.REPLY_YES_OR_MAYBE;</span><br><span class="line">         <span class="keyword">final</span> ZenRule rule = <span class="keyword">new</span> ZenRule();</span><br><span class="line">         rule.enabled = <span class="keyword">false</span>;</span><br><span class="line">-        rule.name = mDefaultRuleEventsName;</span><br><span class="line">+        rule.name = mContext.getResources()</span><br><span class="line">+                .getString(R.string.zen_mode_default_events_name);</span><br><span class="line">         rule.conditionId = ZenModeConfig.toEventConditionId(events);</span><br><span class="line">         rule.zenMode = Global.ZEN_MODE_ALARMS;</span><br><span class="line">         rule.component = EventConditionProvider.COMPONENT;</span><br></pre></td></tr></table></figure></p>
<h2 id="重启字串显示关机"><a href="#重启字串显示关机" class="headerlink" title="重启字串显示关机"></a>重启字串显示关机</h2><p>frameworks/base/services/core/java/com/android/server/power/ShutdownThread.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">348</span>,<span class="number">7</span> +<span class="number">348</span>,<span class="number">13</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">                             com.android.internal.R.string.reboot_to_reset_message));</span><br><span class="line">                 pd.setIndeterminate(<span class="keyword">true</span>);</span><br><span class="line">             &#125;</span><br><span class="line">+        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mReboot)&#123;</span><br><span class="line">+                pd.setTitle(context.getText(com.android.internal.R.string.sim_restart_button));</span><br><span class="line">+                pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_reset_message));</span><br><span class="line">+                pd.setIndeterminate(<span class="keyword">true</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span>(!sInstance.isCustomizedShutdown()) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (showSysuiReboot()) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加充电提示音"><a href="#添加充电提示音" class="headerlink" title="添加充电提示音"></a>添加充电提示音</h2><p>充电提示默认是无线充电时才会有提示, 若需要有线充电提示音则按以下方法添加<br>frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">212</span>,<span class="number">6</span> +<span class="number">212</span>,<span class="number">10</span> @@ <span class="keyword">import</span> java.util.Objects;</span><br><span class="line"> <span class="keyword">import</span> java.util.Set;</span><br><span class="line"> <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">+<span class="keyword">import</span> android.media.Ringtone;</span><br><span class="line">+<span class="keyword">import</span> android.media.RingtoneManager;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** &#123;<span class="doctag">@hide</span>&#125; */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationManagerService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"NotificationService"</span>;</span><br><span class="line">@@ -<span class="number">1018</span>,<span class="number">7</span> +<span class="number">1022</span>,<span class="number">25</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationManagerService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">                 mListeners.onUserUnlocked(user);</span><br><span class="line">                 mAssistants.onUserUnlocked(user);</span><br><span class="line">                 mZenModeHelper.onUserUnlocked(user);</span><br><span class="line">-            &#125;</span><br><span class="line">+            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(Intent.ACTION_POWER_CONNECTED))&#123;</span><br><span class="line">+                <span class="keyword">final</span> <span class="keyword">boolean</span> enabled = Settings.Global.getInt(getContext().getContentResolver(),  </span><br><span class="line">+                                Settings.Global.CHARGING_SOUNDS_ENABLED, <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; SystemProperties.getBoolean(<span class="string">"ro.bdfun.sound_power_connected"</span>, <span class="keyword">false</span>);  </span><br><span class="line">+                <span class="keyword">final</span> String soundPath = Settings.Global.getString(getContext().getContentResolver(),  </span><br><span class="line">+                                Settings.Global.WIRELESS_CHARGING_STARTED_SOUND);</span><br><span class="line">+</span><br><span class="line">+                 <span class="keyword">if</span> (enabled &amp;&amp; soundPath != <span class="keyword">null</span>) &#123;  </span><br><span class="line">+                     <span class="keyword">final</span> Uri soundUri = Uri.parse(<span class="string">"file://"</span> + soundPath);  </span><br><span class="line">+                     <span class="keyword">if</span> (soundUri != <span class="keyword">null</span>) &#123;  </span><br><span class="line">+                         <span class="keyword">final</span> Ringtone sfx = RingtoneManager.getRingtone(getContext(), soundUri);  </span><br><span class="line">+                         <span class="keyword">if</span> (sfx != <span class="keyword">null</span>) &#123;  </span><br><span class="line">+                             sfx.setStreamType(AudioManager.STREAM_SYSTEM);  </span><br><span class="line">+                             sfx.play();  </span><br><span class="line">+                         &#125;  </span><br><span class="line">+                     &#125;  </span><br><span class="line">+                &#125;               </span><br><span class="line">+            &#125;</span><br><span class="line">             <span class="comment">/// M: Privacy protected lock support</span></span><br><span class="line">             <span class="keyword">if</span> (mMtkPplManager.filterPplAction(action)) &#123;</span><br><span class="line">                 mNotificationLight.turnOff();</span><br><span class="line">@@ -<span class="number">1370</span>,<span class="number">6</span> +<span class="number">1392</span>,<span class="number">7</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationManagerService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">         filter.addAction(Intent.ACTION_USER_PRESENT);</span><br><span class="line">         filter.addAction(Intent.ACTION_USER_STOPPED);</span><br><span class="line">         filter.addAction(Intent.ACTION_USER_SWITCHED);</span><br><span class="line">+        filter.addAction(Intent.ACTION_POWER_CONNECTED); <span class="comment">// add by fanjinhao</span></span><br><span class="line">         filter.addAction(Intent.ACTION_USER_ADDED);</span><br><span class="line">         filter.addAction(Intent.ACTION_USER_REMOVED);</span><br><span class="line">         filter.addAction(Intent.ACTION_USER_UNLOCKED);</span><br></pre></td></tr></table></figure></p>
<h2 id="默认音量修改"><a href="#默认音量修改" class="headerlink" title="默认音量修改"></a>默认音量修改</h2><p>修改在 frameworks/base/media/java/android/media/AudioSystem.java中<br>默认值定义在DEFAULT_STREAM_VOLUME这个数组中<br>这里的数值是按比值的大小, 在frameworks/base/services/core/java/com/android/server/audio/AudioService.java定义了其最大值<br>所以修改音量需要对照修改</p>
<h2 id="长按power键添加静音调节模式-SPRD-MTK类似"><a href="#长按power键添加静音调节模式-SPRD-MTK类似" class="headerlink" title="长按power键添加静音调节模式(SPRD, MTK类似)"></a>长按power键添加静音调节模式(SPRD, MTK类似)</h2><p>vendor/sprd/platform/frameworks/base/core/res/res/values/config.xml<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">74</span>,<span class="number">6</span> +<span class="number">74</span>,<span class="number">8</span> @@</span><br><span class="line">         &lt;item&gt;users&lt;/item&gt;</span><br><span class="line">         &lt;!-- SPRD: add the airplane --&gt;</span><br><span class="line">         &lt;item&gt;airplane&lt;/item&gt;</span><br><span class="line">+        &lt;!--  add the silent --&gt;</span><br><span class="line">+        &lt;item&gt;silent&lt;/item&gt;</span><br><span class="line">     &lt;/string-array&gt;</span><br></pre></td></tr></table></figure></p>
<p>如需要进行宏控, 则做如下修改<br>frameworks/base/services/core/java/com/android/server/policy/LegacyGlobalActions.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">301</span>,<span class="number">9</span> +<span class="number">301</span>,<span class="number">11</span> @@ <span class="class"><span class="keyword">class</span> <span class="title">LegacyGlobalActions</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span>.<span class="title">OnDismissListener</span>, <span class="title">DialogIn</span></span></span><br><span class="line"><span class="class">                     <span class="title">mItems</span>.<span class="title">add</span>(<span class="title">new</span> <span class="title">BugReportAction</span>())</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) &#123;</span><br><span class="line">-                <span class="keyword">if</span> (mShowSilentToggle) &#123;</span><br><span class="line">+                <span class="comment">// for show silent mode in long press power button @2018-08-11 &#123;</span></span><br><span class="line">+                <span class="keyword">if</span> (mShowSilentToggle &amp;&amp; SystemProperties.getBoolean(<span class="string">"ro.func.show_silent_power"</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                     mItems.add(mSilentModeAction);</span><br><span class="line">                 &#125;</span><br><span class="line">+                <span class="comment">/// @&#125;</span></span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (SystemProperties.getBoolean(<span class="string">"fw.power_user_switcher"</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                     addUsersToMenu(mItems);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>多平台音乐播放APlayer - 支持https</title>
    <url>/2017/12/09/aplayer/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/27a2c45ff0209417a4abb635c4806c0a.png" alt="aplayer"><br><a id="more"></a></p>
<blockquote>
<p>已更新，音乐复活了</p>
</blockquote>
<h2 id="写在开始"><a href="#写在开始" class="headerlink" title="写在开始"></a>写在开始</h2><p>之前因为搭建好这个站点后，音乐播放也是用aplayer试过，但是自从将站点全面https后，每次使用aplayer播放音乐，小绿锁就消失了，这点就很不好，于是就放弃了。但是最近看到一篇文章中成功的添加了https支持，果断在自己的小站上使用，确实很好用</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>APlayer无疑是最好用的，不仅支持https，还支持众多主流音乐平台的音乐播放<br>需要引入下面两个js文件</p>
<ol>
<li><p>APlayer.min.js &amp; APlayer.min.css</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Meting.min.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>将上面的的两行代码顺序引进自己的网站就可以使用了，例如我是放在<code>/next/layout/_custom/header.swig</code>文件中的</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在需要使用音乐的地方插入一下代码即可使用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"aplayer"</span> data-id=<span class="string">"29732992"</span> data-server=<span class="string">"netease"</span> data-type=<span class="string">"song"</span> data-autoplay=<span class="string">"true"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>效果如下</p>
<div class="aplayer" data-id="29732992" data-server="netease" data-type="song" data-autoplay="true"></div>

<p>其中参数如下, 加粗表示必须填写</p>
<ul>
<li><strong>data-id</strong>: 歌曲/专辑/歌单ID</li>
<li><strong>data-server</strong>: 音乐平台，支持以下参数<ul>
<li>netease(网易云音乐)</li>
<li>tencent(qq音乐)</li>
<li>xiami(虾米音乐)</li>
<li>kugou(酷狗音乐)</li>
<li>baidu(百度音乐)</li>
</ul>
</li>
<li><strong>data-type</strong>: 请求类型，有以下参数<ul>
<li>song(单曲)</li>
<li>album(专辑)</li>
<li>playlist(歌单)</li>
<li>search(搜索)</li>
</ul>
</li>
<li>data-mode: 播放模式<ul>
<li>random(随机)</li>
<li>single(单曲)</li>
<li>circulation(列表循环)</li>
<li>order(列表)</li>
</ul>
</li>
<li><p>data-autoplay: 自动播放</p>
<ul>
<li>false</li>
<li>true</li>
</ul>
<p>更多参数详见<a href="https://aplayer.js.org/docs/#/?id=options" target="_blank" rel="noopener">APlayer</a></p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><blockquote>
<ul>
<li><a href="https://aplayer.js.org/" target="_blank" rel="noopener">APlayer</a></li>
<li><a href="https://www.tiexo.cn/aplayer/" target="_blank" rel="noopener">Hexo音乐播放完美支持https和多平台</a></li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>music</category>
        <category>hexo</category>
        <category>aplayer</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>aplayer</tag>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo快速收录 - 基于python的百度主动推送工具</title>
    <url>/2017/09/01/baiduPushTool/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul>
<li>基于python的主动推送工具, 根据百度站长工具说的，主动推送&gt;自动收录&gt;sitemap&gt;手动提交，于是写了一个Python版本的主动提交工具备忘</li>
<li>使用此工具前提得有自己网站的站点地图<a id="more"></a>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> httplib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(urlSitemap)</span>:</span> <span class="comment">#生成urls.txt 所有网址链接</span></span><br><span class="line">    data = requests.get(urlSitemap).text</span><br><span class="line">    link_list1 = re.findall(<span class="string">r"url=\"(.*?)\"/&gt;"</span>, data)</span><br><span class="line">    link_list2 = re.findall(<span class="string">r"&lt;loc&gt;(.*?)&lt;/loc&gt;"</span>, data)</span><br><span class="line">    urls = open(<span class="string">"urls.txt"</span>, <span class="string">'w+'</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> link_list1 + link_list2:</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; urls, <span class="string">"https:%s"</span> % url</span><br><span class="line">    urls.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(filecontents)</span>:</span></span><br><span class="line">    <span class="comment"># 括号内容需自己提供</span></span><br><span class="line">    url = <span class="string">"/urls?site=(url)&amp;token=(token)"</span> <span class="comment"># url为网址地址，token在百度站长平台里会提供</span></span><br><span class="line">    headers = &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;</span><br><span class="line">    conn = httplib.HTTPConnection(<span class="string">'data.zz.baidu.com'</span>)</span><br><span class="line">    conn.request(method=<span class="string">"POST"</span>, url=url, body=filecontents, headers=headers)</span><br><span class="line">    response = conn.getresponse()</span><br><span class="line">    baidupushresult = response.read()</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="keyword">return</span> baidupushresult</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'http://www.fayne.cn/baidusitemap.xml'</span> <span class="comment"># url 填写sitemap.xml地址，这里是我的</span></span><br><span class="line">    generate(url)</span><br><span class="line">    filecontents = open(<span class="string">'urls.txt'</span>, <span class="string">'rb'</span>).read()</span><br><span class="line">    ps = eval(push(filecontents))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'成功推送%d条，当天剩余%d条'</span> % (ps[<span class="string">'success'</span>], ps[<span class="string">'remain'</span>])</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>运行此代码，输出<br><code>成功推送233条，当天剩余4991126条</code> ，表明推送成功</p>
<h3 id="结束收工"><a href="#结束收工" class="headerlink" title="结束收工"></a>结束收工</h3><p>至此，一个简单主动推送工具就完成了，代码写的有些丑陋，望见谅</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>C互质个数</title>
    <url>/2015/04/23/c-e4-ba-92-e8-b4-a8-e4-b8-aa-e6-95-b0/</url>
    <content><![CDATA[<p><span style="font-size:24px; color:blue">C互质个数 </span></p>
<p>Time Limit:1000MS&nbsp; Memory Limit:65536K</p>
<p>Total Submit:55 Accepted:27</p>
<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">贝贝、妞妞和康康都长大了，如今，他们已届小学毕业，老师给贝贝出了一道强化计算的题目，让她做一大堆除法，以确定两个数之间是否有公共的因子，并且还要数清楚没有公因子的数对。可是，毕竟有些数太大了，量又太多了，即使她与妞妞和康康联手，也没有耐心在一个小时做完这种吃力的事情啊。虽然他们真的知道该怎么做，可是，他们的心早就飞到海边的沙滩上了，想尽情地玩，但眼看又不能。能不能帮他们“减负”，尽早放飞心情，那就要靠你了。</span><br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">输入若干组（≤100组）整数（每个整数n满足0&lt; n &lt; 2^32），每组整数（个数≤50）占一行（第一个数代表数字个数）。</span></p>
<p>**<span style="font-size:24px; color:#333399">Output</span></p>
<p>**</p>
<p><span style="font-family:Times New Roman; font-size:14px">对每组整数，输出其彼此互质的个数，每个结果单独占一行。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">6 27 91 18 2 5 9
4 13 5 60 12</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">11
4
</span>**<span style="font-size:24px; color:#333399">Source</span>**</pre>

<pre name="code" class="cpp">#include <stdio.h>

int gcd(int i, int j)
{
    return j ? gcd(j, i % j) : i;
}

int main()
{
    int n, i, j;
    int a[50];
    while (~scanf("%d", &n))
    {
        for ( i=0; i<n; i++ ) { scanf("%d", &a[i]); } int count="0;" for ( i="0;" i<n; ++i) j="i+1;" j<n; ++j if (gcd(a[i], a[j])="=" 1) count++; printf("%d\n", count); return 0; }< pre>

<pre></pre>

<pre></pre>
</n;></stdio.h></pre>]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>「转载」一些值得记录的 AutoLayout 用法</title>
    <url>/2021/05/07/autolayout-tips/</url>
    <content><![CDATA[<h1 id="AutoLayout-Tips"><a href="#AutoLayout-Tips" class="headerlink" title="AutoLayout Tips"></a>AutoLayout Tips</h1><blockquote>
<p>原文链接：<a href="https://github.com/nixzhu/dev-blog/blob/main/posts/autolayout-tips.md" target="_blank" rel="noopener">AutoLayout Tips</a></p>
</blockquote>
<p>一些值得记录的 AutoLayout 用法。如无意外，作者是：<a href="https://twitter.com/nixzhu" target="_blank" rel="noopener">@nixzhu</a></p>
<hr>
<ul>
<li><a href="#tip-1">Tip 1：两个不等宽的 View，彼此相邻，并“共同”居中于 Superview</a></li>
<li><a href="#tip-2">Tip 2：让 AutoLayout 与 UIScrollView 合作无间</a></li>
</ul>
<hr>
<a id="more"></a>
<h2 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip 1"></a>Tip 1</h2><p><strong>两个不等宽的 View，彼此相邻，并“共同”居中于 Superview</strong></p>
<p>文字可能不好描述，那就来图片：</p>
<p><img src="https://github.com/nixzhu/dev-blog/raw/master/images/autolayout-tip1.png" alt="AutoLayout Tip 1"></p>
<p>如上图所示，黑色的是 Superview，它有两个 Subview，一个是 imageView，一个是 label。</p>
<p>imageView 和 label 相邻，且“它们的组合”居中于 Superview。label 的宽度是可变的，左右两个示意图非常清楚。</p>
<p>那怎样用 AutoLayout 的约束来描述这样的布局呢？</p>
<p>首先来处理两个 Subview 的“相邻”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *constraintH = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-(&gt;=0)-[imageView]-[label]-(&gt;=0)-|&quot;</span><br><span class="line">                                                                   options:0</span><br><span class="line">                                                                   metrics:nil</span><br><span class="line">                                                                     views:viewsDictionary];</span><br></pre></td></tr></table></figure>
<p>这个约束集描述了 imageView 和 label 相邻，而且，imageView 的左边相对于 Superview 的距离 &gt;=0 ，即是可变的；同样，label 的右边相对于 Superview 的距离也 &gt;= 0，一样可变。但若此时运行代码，它们并不会居中于 Superview，可能都挤在右边或左边。</p>
<p>我们使用一个 helperView 来处理“居中”问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLayoutConstraint *constraint3 =[NSLayoutConstraint constraintWithItem:helperView</span><br><span class="line">                                                              attribute:NSLayoutAttributeLeft</span><br><span class="line">                                                              relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                                 toItem:self.imageView</span><br><span class="line">                                                              attribute:NSLayoutAttributeLeft</span><br><span class="line">                                                             multiplier:1</span><br><span class="line">                                                               constant:0];</span><br><span class="line"></span><br><span class="line">NSLayoutConstraint *constraint4 =[NSLayoutConstraint constraintWithItem:helperView</span><br><span class="line">                                                              attribute:NSLayoutAttributeRight</span><br><span class="line">                                                              relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                                 toItem:self.label</span><br><span class="line">                                                              attribute:NSLayoutAttributeRight</span><br><span class="line">                                                             multiplier:1</span><br><span class="line">                                                               constant:0];</span><br></pre></td></tr></table></figure>
<p>helperView 的左边相对于 imageView 的左边对齐，helperView 的右边相对于 label 的右边对齐。最后重点来了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLayoutConstraint *constraint5 =[NSLayoutConstraint constraintWithItem:helperView</span><br><span class="line">                                                              attribute:NSLayoutAttributeCenterX</span><br><span class="line">                                                              relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                                 toItem:self.view // Superview</span><br><span class="line">                                                              attribute:NSLayoutAttributeCenterX</span><br><span class="line">                                                             multiplier:1</span><br><span class="line">                                                               constant:0];</span><br></pre></td></tr></table></figure>
<p>我们让 helperView 的 X 中心与 Superview 的 X 中心一致。于是，伟大的约束会让 helperView 横向居中于 Superview，虽然我们看不见它，但它会将 imageView 和 label 拉到“共同”居中的位置。</p>
<p>搞定！（注意上面的代码省略了一些竖向居中的约束。）虽然是用代码描述的，但是文字说明很清楚了，直接在 IB 里构建约束也没有问题。关键就是我们的 helperView，它虽不可见，但只要它的约束起作用就可以了。</p>
<p>我也写了一个 <a href="https://github.com/nixzhu/CenterTwoViewsUseAutoLayout" target="_blank" rel="noopener">Demo 放在 GitHub</a>，如有必要，请稍微看看！</p>
<h2 id="Tip-2"><a href="#Tip-2" class="headerlink" title="Tip 2"></a>Tip 2</h2><p><strong>让 AutoLayout 与 UIScrollView 合作无间</strong></p>
<p>只要度过了最开始的不适应期，各位用着 AutoLayout 时应该都是心情愉悦的。虽然手写约束会给人冗长的感觉，但 API 的长度并不会阻碍你对代码的理解。不过大部分时间里，我们都在 Storyboard 里，愉快的链接着约束，日子美好又幸福。</p>
<p>可惜好景不长。有一天，我们遇到的某个需求很可能需要我们用 UIScrollView 来实现。比如一个很长的展示页面，里面有文字、有图片、可能还有一些按钮等等。它们的长度或宽度很可能会超过 iPhone（或 iPad）的高度或宽度。Apple 当然很仔细地研究过小尺寸屏幕，它提供的解决方案就是 UIScrollView。</p>
<p>我们就来试试。</p>
<p>我们拖入一个 UIScrollView 放在 ViewController 的 View 里，并设置其约束，到四边的距离都是 0：</p>
<p><img src="https://raw.githubusercontent.com/nixzhu/dev-blog/master/images/autolayout_tip2_add_scrollview.png" alt></p>
<p>更新一下它的 Frame：</p>
<p><img src="https://raw.githubusercontent.com/nixzhu/dev-blog/master/images/autolayout_tip2_add_scrollview2.png" alt></p>
<p>然后我们拖入一个 UILabel 到 UIScrollView 里，这时 Storyboard 就会报告两个错误：</p>
<p><img src="https://raw.githubusercontent.com/nixzhu/dev-blog/master/images/autolayout_tip2_add_label.png" alt></p>
<p>如果英文不太好的话，我们可以用谷歌翻译。ambiguous 的意思是“不明确”，也就是说，UIScrollView 不能确定其内容的宽或高。</p>
<p>由此，我们可以推断，当 UIScrollView 有 SubView 的时候，它就会开始考虑其“内部”的 contentView 的 Size 了。因为 UIScrollView 处于一个 AutoLayout 的环境中，它不能直接得到 SubView 的 Frame，也就不能确定其 contentView 的 Size，于是 Storyboard 就会跑出来告诉我们这件事。</p>
<p>那我们给 UILabel 加上 3 边约束：</p>
<p><img src="https://raw.githubusercontent.com/nixzhu/dev-blog/master/images/autolayout_tip2_add_label2.png" alt></p>
<p>正常来说，只需要上边和左边就能确定 UILabel 的位置，但右边的约束的作用实际是“撑宽”UIScrollView，这时错误就只有一个了：</p>
<p><img src="https://raw.githubusercontent.com/nixzhu/dev-blog/master/images/autolayout_tip2_add_label3.png" alt></p>
<p>很明显，UIScrollView 可以确定其 contentView 的宽度了，因为 UILabel 的宽度固定，它的左边到 UIScrollView 的左边固定，它的右边到 UIScrollView 的右边固定，于是 AutoLayout 系统可以通过这些约束“猜出” UIScrollView 的 contentView 的宽度。</p>
<p>然后，我们再给 UILabel 加上下边的约束，错误就会完全消失了。</p>
<p><img src="https://raw.githubusercontent.com/nixzhu/dev-blog/master/images/autolayout_tip2_add_label4.png" alt></p>
<p>可事情还没完。若我想 UILabel 的右边约束是 20，下边约束也是 20，可行吗？读者可以自行修改约束的值，很明显是可以的。但这时候就“目测”来看，很明显这两个约束的“线段”会长于 20，那为什么 Storyboard 不会报错或警告呢？</p>
<p>如果读者理解了前面的过程，那就会有答案。因为 UILabel 在 UIScrollView 内的 contentView 上，虽然看起来 UIScrollView 很宽很大，但其 contentView 并不是。相反，contentView 的 Size 是由其中的 Subview 的约束所确定的。</p>
<p>这就是你在同时使用 AutoLayout 和 UIScrollView 时所唯一需要明白的地方。</p>
<p>实际上，我们可以更进一步，修改 ViewController 的尺寸。</p>
<p>将 ViewController 的 Size 改为 Freeform：</p>
<p><img src="https://raw.githubusercontent.com/nixzhu/dev-blog/master/images/autolayout_tip2_size.png" alt></p>
<p>并将 View 的 Size 改为 (70, 69)</p>
<p><img src="https://raw.githubusercontent.com/nixzhu/dev-blog/master/images/autolayout_tip2_size2.png" alt></p>
<p>这时候就看起来“正常”了，对吧？同样的道理，如果你要往 UIScrollView 里放入很多很多的 Subview，那你就先将 View 的 Size 改到一个合适的尺寸，再做 Subview 的布局，注意修改约束的“值”（因为看起来的长度不一定是实际的长度）。</p>
<p>最后强调一点，确保约束能让 AutoLayout 确定 UIScrollView 的 contentView 的 Size，此外就是正常的 AutoLayout 用法。当然，有时候我们只需要高度增加，宽度和屏幕一样，那约束好设置吗？</p>
<p>同样有个 <a href="https://github.com/nixzhu/AutoLayoutInUIScrollView" target="_blank" rel="noopener">Demo 放在 GitHub</a>，如有必要，请稍微看看！</p>
<p>2015 年 11 月 7 日补记：<a href="http://weibo.com/2076580237/D2zBsiMPk?type=comment" target="_blank" rel="noopener">微博评论里</a>有人提到所谓正确的用法是“使用一个单一的 containerView 占满全部，然后把所有的 subview 添加到 containerView 中”，但这是我极力避免的，因为这样的方式并没有说清楚原理。Demo 里有三个 Tab，第一个是上面介绍的过程，第二个是限制为只能上下滑动，第三个是要显示的东西的尺寸（无论高宽）超过屏幕的情况。它们都不需要一个中间的 containerView。</p>
<hr>
<p>欢迎转载，但请一定注明出处！ <a href="https://github.com/nixzhu/dev-blog" target="_blank" rel="noopener">https://github.com/nixzhu/dev-blog</a></p>
]]></content>
      <categories>
        <category>AutoLayout</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言程序设计进阶 翁恺 第4周编程练习</title>
    <url>/2015/06/07/c-e8-af-ad-e8-a8-80-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e8-bf-9b-e9-98-b6-e7-bf-81-e6-81-ba-e7-ac-ac4-e5-91-a8-e7-bc-96-e7-a8-8b-e7-bb-83-e4-b9-a0/</url>
    <content><![CDATA[<div class="u-learn-moduletitle f-cb" style="margin:0px 0px 20px; padding:10px 0px; outline:none; zoom:1; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(238,238,238); color:rgb(51,51,51); font-family:Arial,'Hiragino Sans GB',SimSun,宋体,serif; line-height:18px; background-color:rgb(238,238,238)"><br><br>##<br>第4周编程练习<br><br><a href="http://www.icourse163.org/help/help.htm#/hf?t=3" target="_blank" rel="noopener">查看帮助</a><br><br><div class="backbtn f-fr j-backbtn" id="auto-id-aBi8NLEHFav9XpR8" style="margin:8px 0px 0px; padding:0px; outline:none; float:right; color:rgb(101,162,0)"><br><span class="f-icon"></span>返回</div><br></div><br><a id="more"></a><br><div class="j-content-box" style="margin:0px; padding:0px; outline:none; color:rgb(51,51,51); font-family:Arial,'Hiragino Sans GB',SimSun,宋体,serif; line-height:18px; background-color:rgb(238,238,238)"><br><div class="u-homework-submit" style="margin:0px; padding:0px; outline:none"><br><div class="j-cannot-submit cannotsb" style="margin:0px; padding:0px; outline:none"><br></div><br><div class="j-homework-con" style="margin:0px; padding:0px; outline:none"><br><br>第4周编程练习<br><br><div class="cxinfo f-cb" style="margin:0px; padding:0px; outline:none; zoom:1"><input type="checkbox" class="f-fl cxcheck j-cxcheck" id="auto-id-HXhbEPih98D3viwa" style="margin:4px 0px 0px; padding:0px; outline:0px; font-size:12px; line-height:1.5; font-family:Arial,'Hiragino Sans GB',SimSun,宋体,serif; color:rgb(51,51,51); vertical-align:middle; border-style:none; float:left"><br><div class="f-fl f-f0 f-fc6 txt j-cxtxt" style="margin:0px; padding:0px 0px 0px 10px; outline:none; float:left; font-family:Arial,'Hiragino Sans GB','Microsoft YaHei',微软雅黑,Helvetica,sans-serif; color:rgb(102,102,102); line-height:22px; width:675px"><br><br>依照学术诚信条款，我保证此作业是本人独立完成的。<br><br></div><br></div><br><div class="ojtip f-fc6" style="margin:20px 0px 10px; padding:10px 15px; outline:none; color:rgb(102,102,102); line-height:22px; background:rgb(254,255,209)"><br><br>温馨提示：<br><br>1.本次作业属于Online Judge题目，提交后由系统即时判分。<br><br>2.学生可以在作业截止时间之前<span class="f-fcred" style="color:rgb(216,0,0)">不限次数提交答案</span>，系统将取其中的最高分作为最终成绩。<br><br></div><br><div class="j-homework-paper" style="margin:0px; padding:0px; outline:none"><br><div class="m-homeworkQuestionList" style="margin:0px; padding:0px 0px 50px; outline:none"><br><div class="u-questionItem u-ojQuestion examMode first last" style="margin:0px; padding:18px 0px 5px; outline:none; border-bottom-style:none; font-size:14px; background-color:rgb(255,255,255)"><br><div class="j-title f-cb title questionDes" style="margin:0px 0px 10px; padding:0px; outline:none; zoom:1"><br><div class="position f-fl" style="margin:0px; padding:0px; outline:none; float:left; width:38px; font-size:22px; line-height:26px"><br>1</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_26" style="margin:0px; padding:0px; outline:none; float:left; border:0px; line-height:24px; word-break:break-word; word-wrap:break-word; white-space:pre-wrap; width:600px"><br>逆序输出<span style="word-wrap:break-word">（10分）</span></div><br></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_27" style="margin:0px 0px 20px 15px; padding:0px; outline:none; border:0px; color:rgb(102,102,102); line-height:22px; word-break:break-word; word-wrap:break-word; white-space:pre-wrap; font-size:12px"><br><br><strong>题目内容：</strong><br><br>你的程序会读入一系列的正整数，预先不知道正整数的数量，一旦读到-1，就表示输入结束。然后，按照和输入相反的顺序输出所读到的数字，不包括最后标识结束的-1。<br><br><strong>输入格式:</strong><br><br>一系列正整数，输入-1表示结束，-1不是输入的数据的一部分。<br><br><strong>输出格式：</strong><br><br>按照与输入相反的顺序输出所有的整数，每个整数后面跟一个空格以与后面的整数区分，最后的整数后面也有空格。<br><br><strong>输入样例：</strong><br><br>1 2 3 4 -1<br><br><strong>输出样例：</strong><br><br>4 3 2 1&nbsp;<br><br></div><br><div class="j-limit f-fc6 limit f-fs0" style="margin:0px 0px 20px 15px; padding:0px; outline:none; color:rgb(102,102,102); font-size:12px; font-weight:bold"><br><span class="itm" style="margin-right:25px">时间限制：500ms</span>内存限制：32000kb</div><br><div class="j-limit f-fc6 limit f-fs0" style="margin:0px 0px 20px 15px; padding:0px; outline:none; color:rgb(102,102,102); font-size:12px; font-weight:bold"><br><br></div><br><div class="j-limit f-fc6 limit f-fs0" style="margin:0px 0px 20px 15px; padding:0px; outline:none; color:rgb(102,102,102); font-size:12px; font-weight:bold"><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>typedef struct _node {<br>    int value;<br>    struct _node <em>before;<br>} Node;<br><br>int main()<br>{<br>    Node </em> head = NULL;<br>    int number;<br>    do {<br>        scanf(“%d”, &amp;number);<br>        if ( number != -1)<br>        {<br>            Node <em>p = (Node</em>)malloc(sizeof(Node));<br>            p-&gt;value = number;<br>            p-&gt;before = head;<br>            head = p;<br>        }<br>    } while ( number != -1);<br>    Node *p;<br>    for ( p = head; p; p=p-&gt;before) {<br>        printf(“%d “, p-&gt;value);<br>    }<br><br>    return 0;<br>}</pre><br><br></div><br></div><br></div><br></div><br></div><br></div><br></div>
]]></content>
      <categories>
        <category>MOOC</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title>B趣味求和</title>
    <url>/2015/04/18/b-e8-b6-a3-e5-91-b3-e6-b1-82-e5-92-8c/</url>
    <content><![CDATA[<p><span style="font-family:Times New Roman; font-size:14px">编写一个程序，求Sn=a+aa+aaa+……+aa…aaa（有n个a）的值，其中a是一个数字。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">输入数据含有不多于50组的数据，每组数据由两个正整数（0&lt;a, n &lt; 10）组成。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">对于每组数据a和n，计算Sn=a+aa+aaa+……+aa…aaa（有n个a）的值，每个计算结果应单独一行。</span><br><a id="more"></a><br><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">5 2
5 1</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">60
5</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Source</span></strong></p>
<p><strong><span style="font-size:24px; color:#333399"></span></strong></p>
<pre name="code" class="cpp">#include <stdio.h>
#include <math.h>

int main()
{
    long long s,t,i,c = 1;
    int a,n;
    while ( 2 == scanf("%d%d",&a,&n))
    {
       t = 1;
       c=10;
       s=0;
        t = pow(10.0,(double)(n));
        for ( i=a; i<t; i="(c-1)/9*a){" s +="i;" c *="10;" } printf("%lld\n",s); return 0; }< pre>
</t;></math.h></stdio.h></pre>]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>Tiki&amp;球</title>
    <url>/2019/09/28/cat/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码无效, 请检查并重试" data-whm="这些内容无法验证，但您仍然可以查看"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Hey, 请输入密码" /><label>Hey, 请输入密码</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="9c14b2cfe305641a4557e4442f487bb88d2ba9f387d578072b62c0c7a54cd509">5393d9cd48cf4ad629c25c2765d478ff918c3f927f5a06f7a62ff39ee7e52eb9b36d0c0c0626b435e24ae77d825ee3f9dbbe91550a1819d5298b5d94edfd47ebea195ec91c32074aba90539dc613ff7fcb46110088535a956e7cd8a459962dcaacb619dfcc878fb5c305894dfb59dda1d62d5a4214f450f0811eb31e2b374eb4e3f4fe53bfe43103bb0c42f62a9fe6de85a483eee463e147cc1448571cc15761d19544821e2a0f76545397e495f41f1806417bb5f06437807d7d248bd824897c08599534b4049c49922ae94d84631d3242c55485d170d7ef0caccdb9eb986c7a3d3ba5de91c25f3c2f4920687e4bbb42dfb3e7e2a33649ed939297ed4b33a8dc7036eefeb9b7d5b69979394ab6a4e3f112a9f7f165465bf3893e125057618ecc363a0c710aa549696c5bb519d7ac692c328b9ecda94b5c3328b03ee4ba266931</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>猫</category>
      </categories>
      <tags>
        <tag>猫</tag>
      </tags>
  </entry>
  <entry>
    <title>D重叠面积</title>
    <url>/2015/04/18/d-e9-87-8d-e5-8f-a0-e9-9d-a2-e7-a7-af/</url>
    <content><![CDATA[<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">zjahstu是个很厚道的ACMer，O(∩_∩)O~。。特为大家准备水题一道。。</span></p>
<p>题目很简单，两个矩形，告诉你矩形1，矩形2的面积和他们的总面积，请你求两矩形重叠部分的面积。如果给你的情况不存在，就输出Impossible。</p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">第一个数是T，表示测试数据的组数。 后面有T行，每行3个整数（1~10000）。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">输出阴影部分的面积或者Impossible。</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">3
20 20 40
20 20 30
20 20 50</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong><br><a id="more"></a></p>
<pre><span style="font-family:Times New Roman; font-size:14px">0
10
Impossible
</span><pre name="code" class="cpp">#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n;
    int a,b,c;

    scanf("%d",&n);
    while(n--)
    {
       scanf("%d%d%d",&a,&b,&c);
       if (a+b>=c)
            printf("%d\n",a+b-c);
       else
        printf("Impossible\n");

    }
    return 0;
}</stdlib.h></stdio.h></pre>

<p></p></pre><p></p>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下使用Charles抓包https</title>
    <url>/2019/07/27/charles-tourist/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/5786b72dfe46821dbc3b09ee6f2db852.png" alt="Charles"><br><a id="more"></a></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>最近看了一下Mac的网络转包，发现Charles这款工具挺好用的，配置一下证书可以抓包https, 我抓取得是iOS设备，其他类似</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote>
<p><strong>抓取http</strong></p>
</blockquote>
<ul>
<li>打开Charles</li>
<li>打开help -&gt; SSL-Proxying -&gt; install Charles root…,如下图位置<br><img src="https://cdn.fayne.cn/7ffacf7cbe741adbb8dc58e9e061f3b9.png" alt="Charles"><br><img src="https://cdn.fayne.cn/b5342c90bd51156ce4fcdf750093dd3c.png" alt="Charles"></li>
<li>需要将iOS设备和Mac的连到同一网络，在iOS上设置代理，点击设置-无线局域网下-WiFi名称后的感叹号，配置代理，改为手动，服务器填写上面弹出框的的IP地址，端口填写上面的端口号</li>
<li>再在Mac上allow Charles的弹出框即可，这样已经是可以抓取http协议的包了</li>
</ul>
<blockquote>
<p><strong>抓取https</strong></p>
</blockquote>
<p>上述步骤一样，只是需要配置证书了</p>
<ul>
<li>在iOS设备上的Safari浏览器中输入链接<a href="chls.pro/ssl">chls.pro/ssl</a>，下载安装证书</li>
<li>Charles上需要做额外的设置，点击Proxy-&gt;SSL Proxying Settings…如图<br><img src="https://cdn.fayne.cn/850e44da98286b090fcb4b05acaff46e.png" alt="Charles">添加，host填写*，port填写443,这样就可以抓取所有的https了</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="https显示红色的-lt-unknown-gt"><a href="#https显示红色的-lt-unknown-gt" class="headerlink" title="https显示红色的&lt;unknown&gt;"></a>https显示红色的<code>&lt;unknown&gt;</code></h3><p>如果还是抓取不到，显示红色的unknown, 则还是证书的问题，在iOS设备上的设置中，搜索信任证书设置，将针对根证书启用完成信任勾选即可</p>
<h3 id="如果要抓取Mac上https"><a href="#如果要抓取Mac上https" class="headerlink" title="如果要抓取Mac上https"></a>如果要抓取Mac上https</h3><p>在help-&gt;ssl-Proxying-&gt;install Charles root Certificate 即可</p>
<h3 id="更多可以查看官方文档"><a href="#更多可以查看官方文档" class="headerlink" title="更多可以查看官方文档"></a>更多可以查看官方文档</h3><blockquote>
<p><a href="https://www.charlesproxy.com/documentation/configuration/browser-and-system-configuration/" target="_blank" rel="noopener">更多设备的配置方案</a></p>
</blockquote>
<h2 id="抓取原理"><a href="#抓取原理" class="headerlink" title="抓取原理"></a>抓取原理</h2><p>Charles利用的是中间人攻击，Charles需要做的事情是对客户端伪装服务端，对服务端伪装客户端，具体</p>
<ul>
<li>截获真实客户端的HTTPS请求，伪装客户端向真实服务端发送HTTPS请求</li>
<li>接受真实服务器响应，用Charles自己的证书伪装服务端向真实客户端发送数据内容</li>
</ul>
]]></content>
      <categories>
        <category>网络抓包</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Android</tag>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS运行iOS应用的一个Crash记录 - Invalid parameter not satisfying:\&lt;SPRoundedWindow:0x139fbbab0\&gt;. &quot;frame=!CGRectIsNull(frame)&quot;</title>
    <url>/2022/01/16/case-ios-crash-on-mac/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/image/ios_crash.png" alt="stack"><br><a id="more"></a></p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><p>macOS Montery 12.0.1,MacBook Pro (13-inch, M1, 2020)</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>mac上运行iOS应用 -&gt; 点击iOS原生输入框（类型需要为TextField）-&gt; 跳转H5页面 -&gt; 点击H5输入框 -&gt; Crash</p>
<h3 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h3><p><img src="https://cdn.fayne.cn/image/ios_mmjqo-9w8lm.gif" alt="flow"></p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception Type:  EXC_BREAKPOINT (SIGTRAP)</span><br><span class="line">Exception Codes: 0x0000000000000001, 0x000000018b1492c8</span><br><span class="line">Exception Note:  EXC_CORPSE_NOTIFY</span><br><span class="line">Termination Reason: SIGNAL 5 Trace/BPT trap: 5</span><br><span class="line">Terminating Process: exc handler [84957]</span><br><span class="line"></span><br><span class="line">Triggered by Thread:  0</span><br><span class="line"></span><br><span class="line">Application Specific Information:</span><br><span class="line">Crashing on exception: Invalid parameter not satisfying: &lt;SPRoundedWindow: 0x14076d660&gt;. &quot;frame=!CGRectIsNull(frame)&quot;</span><br><span class="line">dyld4 config: DYLD_LIBRARY_PATH=/Users/xxxx/Library/Developer/Xcode/DerivedData/TestMacPro-fmkfqwfrltvdvselxabdtvphcckf/Build/Products/Debug-iphoneos:/usr/lib/system/introspection DYLD_INSERT_LIBRARIES=/Applications/Xcode.app/Contents/Developer/usr/lib/libBacktraceRecording.dylib:/Applications/Xcode.app/Contents/Developer/usr/lib/libMainThreadChecker.dylib:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/Library/Debugger/libViewDebuggerSupport_macCatalyst.dylib DYLD_FRAMEWORK_PATH=/Users/xxxx/Library/Developer/Xcode/DerivedData/TestMacPro-fmkfqwfrltvdvselxabdtvphcckf/Build/Products/Debug-iphoneos</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last Exception Backtrace:</span><br><span class="line">0   CoreFoundation                	       0x1882f8118 __exceptionPreprocess + 220</span><br><span class="line">1   libobjc.A.dylib               	       0x188049808 objc_exception_throw + 60</span><br><span class="line">2   Foundation                    	       0x18926ae20 -[NSMutableDictionary(NSMutableDictionary) initWithContentsOfFile:] + 0</span><br><span class="line">3   AppKit                        	       0x18ae1ffbc -[NSWindow _reallySetFrame:] + 904</span><br><span class="line">4   AppKit                        	       0x18ae1f874 -[NSWindow _oldPlaceWindow:fromServer:] + 228</span><br><span class="line">5   AppKit                        	       0x18ae1e894 -[NSWindow _setFrameCommon:display:fromServer:] + 2200</span><br><span class="line">6   SafariPlatformSupport         	       0x1ae618104 __85-[SPSafariPlatformSupport displayOTPAutoFillRelativeToRect:ofView:completionHandler:]_block_invoke + 300</span><br><span class="line">7   SafariPlatformSupport         	       0x1ae617f8c -[SPSafariPlatformSupport displayOTPAutoFillRelativeToRect:ofView:completionHandler:] + 228</span><br><span class="line">8   UIKitCore                     	       0x1b00d6334 -[UIKeyboardImpl generateAutofillCandidateByAddingTask:] + 948</span><br><span class="line">9   UIKitCore                     	       0x1b00e03fc -[UIKeyboardImpl setDelegate:force:] + 6248</span><br><span class="line">10  UIKitCore                     	       0x1afdc62f4 -[UIKeyboardSceneDelegate _reloadInputViewsForKeyWindowSceneResponder:] + 2080</span><br><span class="line">11  UIKitCore                     	       0x1afdc5aa8 -[UIKeyboardSceneDelegate _reloadInputViewsForResponder:] + 164</span><br><span class="line">12  UIKitCore                     	       0x1af7394d8 -[UIResponder(UIResponderInputViewAdditions) reloadInputViews] + 132</span><br><span class="line">13  WebKit                        	       0x1c102447c -[WKContentView(WKInteraction) _elementDidFocus:userIsInteracting:blurPreviousNode:activityStateChanges:userObject:] + 2088</span><br><span class="line">14  WebKit                        	       0x1c0d354d4 WebKit::WebPageProxy::elementDidFocus(WebKit::FocusedElementInformation const&amp;, bool, bool, WTF::OptionSet&lt;WebCore::ActivityState::Flag&gt;, WebKit::UserData const&amp;) + 216</span><br><span class="line">15  WebKit                        	       0x1c0f9bee8 WebKit::WebPageProxy::didReceiveMessage(IPC::Connection&amp;, IPC::Decoder&amp;) + 61312</span><br><span class="line">16  WebKit                        	       0x1c0993e24 IPC::MessageReceiverMap::dispatchMessage(IPC::Connection&amp;, IPC::Decoder&amp;) + 272</span><br><span class="line">17  WebKit                        	       0x1c0d041e8 WebKit::WebProcessProxy::didReceiveMessage(IPC::Connection&amp;, IPC::Decoder&amp;) + 40</span><br><span class="line">18  WebKit                        	       0x1c09763e0 IPC::Connection::dispatchMessage(std::__1::unique_ptr&lt;IPC::Decoder, std::__1::default_delete&lt;IPC::Decoder&gt; &gt;) + 808</span><br><span class="line">19  WebKit                        	       0x1c09759f0 IPC::Connection::dispatchIncomingMessages() + 508</span><br><span class="line">20  JavaScriptCore                	       0x1bfef8a40 WTF::RunLoop::performWork() + 292</span><br><span class="line">21  JavaScriptCore                	       0x1bfef9bb0 WTF::RunLoop::performWork(void*) + 36</span><br><span class="line">22  CoreFoundation                	       0x188278bbc __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 28</span><br><span class="line">23  CoreFoundation                	       0x188278b08 __CFRunLoopDoSource0 + 208</span><br><span class="line">24  CoreFoundation                	       0x1882787f4 __CFRunLoopDoSources0 + 268</span><br><span class="line">25  CoreFoundation                	       0x188277168 __CFRunLoopRun + 820</span><br><span class="line">26  CoreFoundation                	       0x188276694 CFRunLoopRunSpecific + 600</span><br><span class="line">27  HIToolbox                     	       0x190dec990 RunCurrentEventLoopInMode + 292</span><br><span class="line">28  HIToolbox                     	       0x190dec704 ReceiveNextEventCommon + 552</span><br><span class="line">29  HIToolbox                     	       0x190dec4c4 _BlockUntilNextEventMatchingListInModeWithFilter + 72</span><br><span class="line">30  AppKit                        	       0x18adcbaec _DPSNextEvent + 844</span><br><span class="line">31  AppKit                        	       0x18adca390 -[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 1332</span><br><span class="line">32  AppKit                        	       0x18adbc3b0 -[NSApplication run] + 596</span><br><span class="line">33  AppKit                        	       0x18ad8da84 NSApplicationMain + 1064</span><br><span class="line">34  AppKit                        	       0x18b063ff0 +[NSWindow _savedFrameFromString:] + 0</span><br><span class="line">35  UIKitMacHelper                	       0x19d764484 UINSApplicationMain + 1280</span><br><span class="line">36  UIKitCore                     	       0x1af5b2ce4 UIApplicationMain + 164</span><br><span class="line">37  TestMacPro                    	       0x1020c5ac0 main + 128 (main.m:17)</span><br><span class="line">38  dyld                          	       0x1024c50f4 start + 520</span><br><span class="line"></span><br><span class="line">Kernel Triage:</span><br><span class="line">VM - pmap_enter failed with resource shortage</span><br><span class="line">VM - pmap_enter failed with resource shortage</span><br><span class="line">VM - pmap_enter failed with resource shortage</span><br><span class="line">VM - Compressor failed a blocking pager_get</span><br><span class="line">VM - pmap_enter failed with resource shortage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 0 Crashed::  Dispatch queue: com.apple.main-thread</span><br><span class="line">0   AppKit                        	       0x18b1492c8 -[NSApplication _crashOnException:] + 324</span><br><span class="line">1   AppKit                        	       0x18b1492c0 -[NSApplication _crashOnException:] + 316</span><br><span class="line">2   AppKit                        	       0x18b148fe0 -[NSApplication reportException:] + 588</span><br><span class="line">3   AppKit                        	       0x18b1f2448 uncaughtErrorProc + 156</span><br><span class="line">4   CoreFoundation                	       0x1883833d8 __handleUncaughtException + 676</span><br><span class="line">5   libobjc.A.dylib               	       0x188052194 _objc_terminate() + 132</span><br><span class="line">6   libc++abi.dylib               	       0x188168ee4 std::__terminate(void (*)()) + 20</span><br><span class="line">7   libc++abi.dylib               	       0x18816befc __cxa_rethrow + 148</span><br><span class="line">8   libobjc.A.dylib               	       0x18805ded0 objc_exception_rethrow + 44</span><br><span class="line">9   AppKit                        	       0x18ae1ef20 -[NSWindow _setFrameCommon:display:fromServer:] + 3876</span><br><span class="line">10  SafariPlatformSupport         	       0x1ae618104 __85-[SPSafariPlatformSupport displayOTPAutoFillRelativeToRect:ofView:completionHandler:]_block_invoke + 300</span><br><span class="line">11  SafariPlatformSupport         	       0x1ae617f8c -[SPSafariPlatformSupport displayOTPAutoFillRelativeToRect:ofView:completionHandler:] + 228</span><br><span class="line">12  UIKitCore                     	       0x1b00d6334 -[UIKeyboardImpl generateAutofillCandidateByAddingTask:] + 948</span><br><span class="line">13  UIKitCore                     	       0x1b00e03fc -[UIKeyboardImpl setDelegate:force:] + 6248</span><br><span class="line">14  UIKitCore                     	       0x1afdc62f4 -[UIKeyboardSceneDelegate _reloadInputViewsForKeyWindowSceneResponder:] + 2080</span><br><span class="line">15  UIKitCore                     	       0x1afdc5aa8 -[UIKeyboardSceneDelegate _reloadInputViewsForResponder:] + 164</span><br><span class="line">16  UIKitCore                     	       0x1af7394d8 -[UIResponder(UIResponderInputViewAdditions) reloadInputViews] + 132</span><br><span class="line">17  WebKit                        	       0x1c102447c -[WKContentView(WKInteraction) _elementDidFocus:userIsInteracting:blurPreviousNode:activityStateChanges:userObject:] + 2088</span><br><span class="line">18  WebKit                        	       0x1c0d354d4 WebKit::WebPageProxy::elementDidFocus(WebKit::FocusedElementInformation const&amp;, bool, bool, WTF::OptionSet&lt;WebCore::ActivityState::Flag&gt;, WebKit::UserData const&amp;) + 216</span><br><span class="line">19  WebKit                        	       0x1c0f9bee8 WebKit::WebPageProxy::didReceiveMessage(IPC::Connection&amp;, IPC::Decoder&amp;) + 61312</span><br><span class="line">20  WebKit                        	       0x1c0993e24 IPC::MessageReceiverMap::dispatchMessage(IPC::Connection&amp;, IPC::Decoder&amp;) + 272</span><br><span class="line">21  WebKit                        	       0x1c0d041e8 WebKit::WebProcessProxy::didReceiveMessage(IPC::Connection&amp;, IPC::Decoder&amp;) + 40</span><br><span class="line">22  WebKit                        	       0x1c09763e0 IPC::Connection::dispatchMessage(std::__1::unique_ptr&lt;IPC::Decoder, std::__1::default_delete&lt;IPC::Decoder&gt; &gt;) + 808</span><br><span class="line">23  WebKit                        	       0x1c09759f0 IPC::Connection::dispatchIncomingMessages() + 508</span><br><span class="line">24  JavaScriptCore                	       0x1bfef8a40 WTF::RunLoop::performWork() + 292</span><br><span class="line">25  JavaScriptCore                	       0x1bfef9bb0 WTF::RunLoop::performWork(void*) + 36</span><br><span class="line">26  CoreFoundation                	       0x188278bbc __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 28</span><br><span class="line">27  CoreFoundation                	       0x188278b08 __CFRunLoopDoSource0 + 208</span><br><span class="line">28  CoreFoundation                	       0x1882787f4 __CFRunLoopDoSources0 + 268</span><br><span class="line">29  CoreFoundation                	       0x188277168 __CFRunLoopRun + 820</span><br><span class="line">30  CoreFoundation                	       0x188276694 CFRunLoopRunSpecific + 600</span><br><span class="line">31  HIToolbox                     	       0x190dec990 RunCurrentEventLoopInMode + 292</span><br><span class="line">32  HIToolbox                     	       0x190dec704 ReceiveNextEventCommon + 552</span><br><span class="line">33  HIToolbox                     	       0x190dec4c4 _BlockUntilNextEventMatchingListInModeWithFilter + 72</span><br><span class="line">34  AppKit                        	       0x18adcbaec _DPSNextEvent + 844</span><br><span class="line">35  AppKit                        	       0x18adca390 -[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 1332</span><br><span class="line">36  AppKit                        	       0x18adbc3b0 -[NSApplication run] + 596</span><br><span class="line">37  AppKit                        	       0x18ad8da84 NSApplicationMain + 1064</span><br><span class="line">38  AppKit                        	       0x18b063ff0 _NSApplicationMainWithInfoDictionary + 24</span><br><span class="line">39  UIKitMacHelper                	       0x19d764484 UINSApplicationMain + 1280</span><br><span class="line">40  UIKitCore                     	       0x1af5b2ce4 UIApplicationMain + 164</span><br><span class="line">41  TestMacPro                    	       0x1020c5ac0 main + 128 (main.m:17)</span><br><span class="line">42  dyld</span><br></pre></td></tr></table></figure>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><p><img src="https://cdn.fayne.cn/image/flow_ios_crash.png" alt="flow"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>此问题为苹果系统bug，已将此问题提交给了苹果，原因应该是是由于mac Catalyst 不支持predictive text自动纠错预测文本，可以尝试将mac上TextFiled的自动纠错预测文本关闭<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.autocorrectionType = .no</span><br></pre></td></tr></table></figure></p>
<p><strong>详细可参考</strong>：<a href="https://developer.apple.com/forums/thread/697575" target="_blank" rel="noopener">forums</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Crash</tag>
        <tag>TextField</tag>
        <tag>WKWebView</tag>
        <tag>SPRoundedWindow</tag>
      </tags>
  </entry>
  <entry>
    <title>厦门大学线下编程比赛第一题：求和</title>
    <url>/2015/04/21/e5-8e-a6-e9-97-a8-e5-a4-a7-e5-ad-a6-e7-ba-bf-e4-b8-8b-e7-bc-96-e7-a8-8b-e6-af-94-e8-b5-9b-e7-ac-ac-e4-b8-80-e9-a2-98-ef-bc-9a-e6-b1-82-e5-92-8c/</url>
    <content><![CDATA[<ul>
<li><p>编程语言要求：Java C# C C++*   <span class="inv-hard-txt">难度等级：</span><img src="http://image.job.csdn.net/www/star_on.png" alt><img src="http://image.job.csdn.net/www/star_of.png" alt><img src="http://image.job.csdn.net/www/star_of.png" alt><img src="http://image.job.csdn.net/www/star_of.png" alt><img src="http://image.job.csdn.net/www/star_of.png" alt></p>
</li>
<li><p>有效期： 2014-11-05 至 2015-12-05</p>
</li>
<li>答题时长：120分钟</li>
</ul>
<div class="hclub-subdet-contxt"><br><span style="font-size:12px; line-height:1.5">给定a和n，计算a+aa+aaa+aaaa+…+a…a(n个a) 的和。</span><br><br>输入描述：<br><br>测试数据有多组,以文件结尾。每行输入a，n（1&lt;=a,n&lt;=1000000）。<br><br>输出描述：<br><br>由于结果可能比较大，所以请输出答案mod 1000000007。<br><br><a href="http://student.csdn.net/mcs/begin_challenge/674" target="_blank" rel="noopener">题目来源</a><br><br><span style="font-size:18px; color:#FF0000">此题由本人AC通过，有疑问请联系<a href="mailto:fjinhao@qq.com" target="_blank" rel="noopener">fjinhao@qq.com</a>，欢迎来此讨论交流</span><br><br><span style="font-size:18px; color:#FF0000">本题解题在求和时，第一个数为a,后一个数=前一个数a+10<em>10^a的位数<br><br></em></span><br><a id="more"></a><br><p></p><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#define mod 1000000007<br><br>int main(void)<br>{<br>    long long a,n;<br>    long long t,m,c, i,result,k;<br>    while ( 2 == scanf(“%I64d%I64d”,&amp;a,&amp;n) )<br>    {<br>        c = 0;<br>        t = a;<br>        while(t)<br>        {<br>            c++;<br>            t /= 10;<br>        }<br>        m = 1;<br>        for ( i=1; i&lt;=c; i++)<br>        m = 10;<br>        result = a % mod;<br>        k = a % mod;<br>        for ( i =2; i&lt;=n; i++ ) {<br>            k = ( k*m + a)%mod;<br>            result = (result + k)%mod;<br>        }<br>        printf(“%d\n”,result);<br>    }<br><br>    return 0;<br>}</pre><br><br><p><br><br></p></div>
]]></content>
      <categories>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>中国大学MOOC-陈越、何钦铭-数据结构-2015秋 01-复杂度2 Maximum Subsequence Sum   (25分)</title>
    <url>/2015/09/02/e4-b8-ad-e5-9b-bd-e5-a4-a7-e5-ad-a6mooc-e9-99-88-e8-b6-8a-e3-80-81-e4-bd-95-e9-92-a6-e9-93-ad-e6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84-2015-e7-a7-8b01-e5-a4-8d-e6-9d-82-e5-ba-a62maximumsubsequences/</url>
    <content><![CDATA[<div class="m-qdetail"><strong><span style="font-size:18px">01-复杂度2&nbsp;Maximum Subsequence Sum&nbsp;&nbsp;&nbsp;(25分)</span></strong><br><div class="content"><br><div class="ques-view"><br>Given a sequence of <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.68333em; vertical-align:0em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em">K</span></span></span></span><br> integers { <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.83333em; vertical-align:-0.15em"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em">N</span><span class="vlist"><span style="top:0.15em; margin-right:0.05em; margin-left:-0.10903em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.83333em; vertical-align:-0.15em"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em">N</span><span class="vlist"><span style="top:0.15em; margin-right:0.05em; margin-left:-0.10903em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span>​</span></span></span></span></span></span>,<br> …, <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.83333em; vertical-align:-0.15em"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em">N</span><span class="vlist"><span style="top:0.15em; margin-right:0.05em; margin-left:-0.10903em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07153em">K</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span>​</span></span></span></span></span></span><br> }. A continuous subsequence is defined to be { <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.83333em; vertical-align:-0.15em"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em">N</span><span class="vlist"><span style="top:0.15em; margin-right:0.05em; margin-left:-0.10903em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.891661em; vertical-align:-0.208331em"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em">N</span><span class="vlist"><span style="top:0.15em; margin-right:0.05em; margin-left:-0.10903em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span>​</span></span></span></span></span></span>,<br> …, <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.969438em; vertical-align:-0.286108em"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em">N</span><span class="vlist"><span style="top:0.15em; margin-right:0.05em; margin-left:-0.10903em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em">​</span></span>​</span></span></span></span></span></span><br> } where <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.8777699999999999em; vertical-align:-0.19444em"></span><span class="base textstyle uncramped"><span class="mord">1</span><span class="mrel">≤</span><span class="mord mathit">i</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.05724em">j</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.07153em">K</span></span></span></span>.<br> The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.<br><br>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.<br><br>### Input Specification:<br><br>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer<span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.68333em; vertical-align:0em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em">K</span></span></span></span><br> (<span class="katex"><span class="katex-inner"><span class="strut" style="height:0.64444em"></span><span class="strut bottom" style="height:0.78041em; vertical-align:-0.13597em"></span><span class="base textstyle uncramped"><span class="mrel">≤</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>).<br> The second line contains <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.68333em; vertical-align:0em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em">K</span></span></span></span><br> numbers, separated by a space.<br><br>### Output Specification:<br><br>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence<br> is not unique, output the one with the smallest indices <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.65952em"></span><span class="strut bottom" style="height:0.65952em; vertical-align:0em"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span><br> and <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.65952em"></span><span class="strut bottom" style="height:0.85396em; vertical-align:-0.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05724em">j</span></span></span></span><br> (as shown by the sample case). If all the <span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.68333em; vertical-align:0em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em">K</span></span></span></span><br> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.<br><br>### Sample Input:<br><br>    10<br>    -10 1 2 3 4 -5 -23 3 7 -21<br>    <code>&lt;/pre&gt;

    ### Sample Output:

    &lt;pre&gt;</code>10 1 4<br><br></div><br></div><br><div class="u-tip"><br><br><em>   时间限制：200ms
</em>   内存限制：64MB<br><em>   代码长度限制：16kB
</em>   判题程序：系统默认<br><em>   作者：陈越
</em>   单位：浙江大学<br><span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">大致题意：</span><br><a id="more"></a><br><span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">此题为 最大子列和 的变式，找出序列中的最大子序列之和，并输出子序列中初始位的数和末位的数<br><br></span><br><br><span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">解题思路：</span><br><br><span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">用在线处理的方式，用thisMax储存当前临时序列和，如果大于最大maxSum的值，则更新maxSum的值</span><br><br><span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">如果thisSum的值小于0时，将thisSum的值赋为0，因为thisSum小于0时，再加上一个数肯定比之前还要小</span><br><br><span style="font-family:KaiTi_GB2312; font-size:18px">具体解答请看以下代码：</span><br><br><pre name="code" class="cpp">#include <iostream><br> /<em>
  </em> author：Fayne<br>  <em> time:2015-9-2 21:24:16
  </em>thisSum用于保存临时序列之和，maxSum更新最大序列和<br>  <em>left, right分别表示最大序列的左右序号，tempLeft保存临时左端的序号
  </em>/<br>using namespace std;<br>int A[10010];<br><br>int main()<br>{<br>    int k, i;<br>    cin &gt;&gt; k;<br>    for ( i=0; i&lt;k; i++ )<br>        cin &gt;&gt; A[i];<br>    int left = 0, right = k-1, maxSum = -1, thisSum = 0, tempLeft;//maxSum赋初值为-1为了解决出现全部序列为负的情况<br>    for ( i=0; i&lt;k; i++ )<br>    {<br>        thisSum += A[i];<br><br>        if ( thisSum &gt; maxSum )//如果临时序列和大于最大和，则更新最大和<br>        {<br>            maxSum = thisSum;<br>            left = tempLeft;//将临时左端的序号赋值给左端序号<br>            right = i;<br>        }<br>        else if ( thisSum &lt; 0 )//thisSum小于0时，从此刻下一个开始重新求和<br>        {<br>            thisSum = 0;<br>            tempLeft = i+1;//把此刻的下一序号赋值给临时左端序号<br>        }<br>    }<br>    if ( maxSum &lt; 0 )//maxSum &lt; 0 说明整个序列全为负数，根据题意，最大和应该为0<br>        maxSum = 0;<br>    cout &lt;&lt; maxSum &lt;&lt; “ “ &lt;&lt; A[left]&lt;&lt; “ “ &lt;&lt; A[right]&lt;&lt; endl;<br><br>    return 0;<br>}</iostream></pre><br><br><span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">注意题意：If all the<span class="katex"><span class="katex-inner"><span class="strut" style="height:0.68333em"></span><span class="strut bottom" style="height:0.68333em; vertical-align:0em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em">K</span></span></span></span><br> numbers are negative, then its maximum sum is defined to be 0</span><br><br></div><br></div>
]]></content>
      <categories>
        <category>MOOC</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>pat</tag>
        <tag>acm</tag>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_A_砝码称重</title>
    <url>/2016/09/25/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-a-e7-a0-9d-e7-a0-81-e7-a7-b0-e9-87-8d/</url>
    <content><![CDATA[<p>#<br>砝码称重</p>
<p></p><p></p>
<table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Time Limit: 1000 MS</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Memory Limit: 65536 KB</span></td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Total Submissions: 61</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Accepted: 37</span></td><br></tr><br></tbody><br></table>

<div style="text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif"></span><br><br>## Description<br><br><div style="color:rgb(102,102,102)"><br><span style="font-size:14px">小明非常喜爱物理，有一天，他对物理实验室中常用的弹簧拉力计产生了兴趣。实验室中有两种质量不同的砝码，小明分别用<span style="font-family:Calibri">a</span>个第一种砝码放在弹簧拉力计上和<span style="font-family:Calibri">b</span>个第二种砝码放在弹簧拉力计上，假设每增加单位重量的砝码，弹簧拉力计的长度增加<span style="font-family:Calibri">1</span>，那么两次称量弹簧拉力计的长度差是多少呢？（假设拉力计不发生非弹性形变）</span><br><a id="more"></a><br>&nbsp;<br><br>&nbsp;<br><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(102,102,102)"><br><span style="font-size:14px">第一行一个整数<span style="font-family:Calibri">T</span>，表示有<span style="font-family:Calibri">T</span>组数据。</span><br><br><span style="font-size:14px">之后<span style="font-family:Calibri">T</span>行，每行数据包含四个正整数，分别表示第一种砝码重量<span style="font-family:Calibri">a</span>，第一种砝码数量<span style="font-family:Calibri">b</span>，第二种砝码重量<span style="font-family:Calibri">c</span>，第二种砝码数量<span style="font-family:Calibri">d</span>。</span><br><br><span style="font-family:Calibri; font-size:14px">T&lt;25</span><br><br><span style="font-family:Calibri; font-size:14px">0&lt;a,b,c,d&lt;=100</span><br><br>&nbsp;<br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(102,102,102)"><br><span style="font-size:14px">对于每组数据，输出一个正整数，表示弹簧拉力计的长度差值。</span><br><br>&nbsp;<br></div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(102,102,102)">3<br><br>1&nbsp;2&nbsp;3&nbsp;4<br><br>1&nbsp;4&nbsp;2&nbsp;2<br><br>1&nbsp;3&nbsp;2&nbsp;1<br><br></div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div style="color:rgb(102,102,102)">10<br><br>0<br><br>1</div><br><div style="color:rgb(102,102,102)"><br><br></div><br><div><span style="font-size:14px; color:#ff0000">这道题比较简单，直接给出代码</span></div><br><pre code_snippet_id="1899448" snippet_file_name="blog_20160925_1_5296299" name="code" class="cpp">#include <iostream><br>#include <cstdio><br>#include <cmath><br><br>using namespace std;<br><br>int main(int argc, char const <em>argv[])<br>{<br>    int T;<br>    scanf(“%d”, &amp;T);<br>    while (T–)<br>    {<br>        int a, b, c, d;<br>        scanf(“%d%d%d%d”, &amp;a, &amp;b, &amp;c, &amp;d);<br>        int ans = abs(a</em>b - c*d);<br>        printf(“%d\n”, ans);<br>    }<br>    return 0;<br>}</cmath></cstdio></iostream></pre><br><br></div>
]]></content>
      <categories>
        <category>基础</category>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>基础</tag>
        <tag>省赛</tag>
      </tags>
  </entry>
  <entry>
    <title>回文距离</title>
    <url>/2015/04/21/e5-9b-9e-e6-96-87-e8-b7-9d-e7-a6-bb/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 回文距离</p>
<ul>
<li><p>编程语言要求：Java C# C C++*   <span class="inv-hard-txt">难度等级：</span><img src="http://image.job.csdn.net/www/star_on.png" alt><img src="http://image.job.csdn.net/www/star_on.png" alt><img src="http://image.job.csdn.net/www/star_of.png" alt><img src="http://image.job.csdn.net/www/star_of.png" alt><img src="http://image.job.csdn.net/www/star_of.png" alt></p>
</li>
<li><p>有效期： 2014-06-06 至 2015-06-06</p>
</li>
<li>答题时长：120分钟</li>
</ul>
<div class="hclub-subdet-contxt"><br>&nbsp; &nbsp;Njzy在对回文数的学习过程中发现了一个有趣的问题.<br><br>这个问题是求一个数的回文距离。一个数的回文距离的定义是它减去一个回文数的绝对值的最小值。<br><br>比如：121的回文距离就是0，因为|121-121|=0,123的回文距离是2，|123-121|=2<br><br>输入描述：<br><br>&nbsp; &nbsp;输入包含多组测试数据，每组测试数据包含一个整数a,<br><br>(0<br><br>输出描述：<br><br>&nbsp; &nbsp;对于每组测试数据输出相应的答案。<br><br><span style="color:#FF0000"><span style="font-size:18px">本题由本人AC，有任何问题请联系<a href="mailto:fjinhao@qq.com" target="_blank" rel="noopener">fjinhao@qq.com</a>。谢谢</span></span><br><br>本题来源：<a href="http://student.csdn.net/mcs/question_detail/609" target="_blank" rel="noopener">高校俱乐部</a><br><a id="more"></a><br><a href="http://student.csdn.net/mcs/question_detail/609" target="_blank" rel="noopener"><span style="font-size:18px; color:#FF0000"><br><br></span></a><br><br><p></p><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>long long judge(long long n)<br>{<br>    long long ret = 0, t = n;<br>    while (t &gt; 0)                    // 将高低位互换<br>    {<br>        ret = ret * 10 + t % 10;<br>        t = t / 10;<br>    };<br><br>    if ( n == ret)<br>    t = 1;<br>    else<br>    t = 0;<br>    return t;<br>}<br><br>int main()<br>{<br>    long long n;<br>    long long c,q;<br>    while ( 1 == scanf(“%lld”,&amp;n) )<br>    {<br>        c = q = n;<br>        if (judge(n))<br>        printf(“0\n”);<br>        else<br>        {<br>            while(!judge(c))<br>            {<br>                c++;<br>            }<br>            while(!judge(q))<br>            {<br>                q–;<br>            }<br>            if(n-q &gt;= c-n)<br>            printf(“%d\n”,c-n);<br>            else if ( n-q &lt; c-n)<br>            printf(“%d\n”,n-q);<br>        }<br>    }<br><br>    return 0;<br>}</pre><br><br><p><br></p></div>

<div class="column_860"><br><div class="inv-whitebg clearfix"></div><br></div>

<div class="column_260"></div>

<div class="main clearfix"><br><div class="column_260"></div><br></div>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_B_阵前第一功</title>
    <url>/2016/09/25/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-b-e9-98-b5-e5-89-8d-e7-ac-ac-e4-b8-80-e5-8a-9f/</url>
    <content><![CDATA[<p>#<br><span style="font-family:SimSun">阵前第一功</span></p>
<p></p><p></p>
<table width="300" style="text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto; font-size:9pt"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:SimSun">Time Limit: 1000 MS</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:SimSun">Memory Limit: 65536 KB</span></td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:SimSun">Total Submissions: 63</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:SimSun">Accepted: 29</span></td><br></tr><br></tbody><br></table>

<p><span style="font-family:SimSun"></span></p>
<p></p>
<div style="text-align:left"><br><br>##<br><br>## <span style="font-family:SimSun">Description</span><br><br><span style="font-family:SimSun; color:rgb(102,102,102)"><br><br></span><br><div style="color:rgb(102,102,102)"><br><span style="font-family:SimSun"><span style="font-size:14px"><strong>A国每个国民都有一定战斗力，每年国家都要对人民的战斗力进行一次排序统计，他们的排序规矩是相同战斗力的排名一样，而且只占一个排序名额。比如，有5个人：100,100,90,90,70.&nbsp;两个100的并列第一，称为第一战斗力，两个90的并列第二，称为第二战斗力，依次类推。。。现在你想查询第K战斗力是多少</strong></span></span><br><span style="font-family:SimSun"><br><a id="more"></a><br></span></div><br><span style="font-family:SimSun; color:rgb(102,102,102)"><br><br></span><br><br>## <span style="font-family:SimSun">Input</span><br><br><span style="font-family:SimSun; color:rgb(102,102,102)"><br><br></span><br><div style="color:rgb(102,102,102)"><br><span style="font-size:14px"><strong><span style="font-family:SimSun">先输入一个整数T，表示T（T&lt;50）组数据。</span></strong></span><br><br><span style="font-size:14px"><strong><span style="font-family:SimSun">每组第一行一个正整数N（1000&gt;N&gt;0），表示表示有N个人。接下里一行N个正整数ai(2^30&gt;=ai&gt;=0)，表示每个人的战斗力。</span></strong></span><br><br><span style="font-family:SimSun"><span style="font-size:14px"><strong>接下输入一个正整数K（N&gt;=K&gt;0）。（保证输入都合法）</strong></span></span><br></div>

<h2 id><a href="#" class="headerlink" title></a><span style="font-family:SimSun"></span></h2><p>Output</p>
<p><span style="font-family:SimSun; color:rgb(102,102,102)"></span></p>
<p></p>
<div style="color:rgb(102,102,102)"><br><span style="font-family:SimSun"><span style="font-size:14px"><strong>输出第K战斗力,输出占一行</strong></span></span><br></div><br><span style="font-family:SimSun; color:rgb(102,102,102)"><br><br></span><br><br>## <span style="font-family:SimSun">Sample Input</span><br><br><span style="font-family:SimSun; color:rgb(102,102,102)"><br><br></span><br><div style="color:rgb(102,102,102)"><span style="font-family:SimSun">2<br><br>5<br><br>100&nbsp;90&nbsp;90&nbsp;100&nbsp;70<br><br>2<br><br>10&nbsp;<br><br>1&nbsp;2&nbsp;3&nbsp;3&nbsp;3&nbsp;400&nbsp;3&nbsp;4&nbsp;3&nbsp;1&nbsp;<br><br>4<br><br></span></div><br><span style="font-family:SimSun; color:rgb(102,102,102)"><br><br></span><br><br>## <span style="font-family:SimSun">Sample Output</span><br><br><span style="font-family:SimSun; color:rgb(102,102,102)"><br><br></span><br><div style="color:rgb(102,102,102)"><span style="font-family:SimSun">90<br><br>2</span></div><br><span style="color:#ff0000">题解：此题只需要排序去重即可，属于简单题</span><br><div><span style="color:#ff0000"><br><br></span></div><br></div>

<pre code_snippet_id="1899466" snippet_file_name="blog_20160925_1_4789602" name="code" class="cpp">#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

int main(int argc, char const *argv[])
{
    int T, n, k, cnt, i;
    scanf("%d", &T);
    while (T--)
    {
        cnt = 0;
        scanf("%d", &n);
        int *a = new int[n];
        for (i=0; i<n; i++) scanf("%d", &a[i]); sort(a, a+n); &k); for (i="n-1;" i>0; i--) {
            if (a[i] != a[i-1]) cnt++;
            if (cnt == k) break;
        }
        printf("%d\n", a[i]);
        delete []a;
    }
    return 0;
}</n;></algorithm></cstdio></iostream></pre>
]]></content>
      <categories>
        <category>基础</category>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>基础</tag>
        <tag>省赛</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_D_梯田AGAIN</title>
    <url>/2016/09/25/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-d-e6-a2-af-e7-94-b0again/</url>
    <content><![CDATA[<p>梯田AGAIN</p>
<p></p><p></p>
<table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left">Time Limit: 5000 MS</td><br><td style="margin:0px; padding:0px; text-align:left">Memory Limit: 65536 KB</td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left">Total Submissions: 95</td><br><td style="margin:0px; padding:0px; text-align:left">Accepted: 21</td><br></tr><br></tbody><br></table>

<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><div>大家还记得去年的梯田吗？土豪YZK在一块小岛上有着一大片n<em>m的梯田，每块1</em>1的田地都有它的高度。奴隶们不甘被YZK剥削，他们联合起来决定发动一场海啸淹掉YZK的部分梯田。<br><br>奴隶们去年尝试了一下，结果发现，由于土质太过松软，水能够透过土地渗入到相邻的梯田，即对于海啸高度h，梯田中所有小于等于h的土地都会由于土质松软而被被淹没。<br><br>现在给你一个n*m的矩阵，代表梯田中每块田地的高度。然后给定q个询问，每个询问给定一个海啸高度h，问在此高度下，不被淹没的梯田数量是多少。<br><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><div>第一行一个整数T，表示测试数据组数。<br><br>对于每组测试数据：<br><br>第一行三个数字n，m，q，表示梯田的行数，列数和询问数。<br><br>之后n行，每行m个数字，表示每块田地的高度，梯田高度不大于1000000。<br><br>之后q行，每行给出一个海啸高度h，问大于这个高度的梯田有多少块。<br><a id="more"></a><br>0&lt;T&lt;20。<br><br>0&lt;n，m&lt;=200。<br><br>0&lt;=q&lt;1000。<br><br>0&lt;=h&lt;=1000000.<br><br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div>对于每个询问，给出一个整数，表示大于这个海啸高度的梯田数量。</div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div>2<br><br>2&nbsp;2&nbsp;2<br><br>1&nbsp;2<br><br>3&nbsp;4<br><br>2<br><br>3<br><br>2&nbsp;3&nbsp;3<br><br>1&nbsp;2&nbsp;3<br><br>3&nbsp;4&nbsp;5<br><br>0<br><br>4<br><br>5<br><br></div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div>​2<br><br>1<br><br>6<br><br>1<br><br>0</div>

<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><div>经测试，此题存在卡输入输出问题，现将时限修改，在此对被卡的同学表示歉意。<br><br>另外，由于测评环境为xp，取消对stdio同步对流式输入输出效率可能是不起作用的，请大家务必注意。若怀疑某题存在卡IO的可能，请使用C式io函数或者用io加速外挂进行Io操作。</div>

<div><br><br></div>

<div><span style="font-size:14px; color:#ff0000">题解：这题题意写的很清楚，可是要注意一点，要是每次都普通查询操作那么就会超时，此题我是放在了一维数组，然后二分查找实现的，个人觉得此代码写的并不完美，欢迎各位朋友提出宝贵改进意见</span></div>

<div><br><br></div>

<div><pre code_snippet_id="1899547" snippet_file_name="blog_20160925_1_9432305" name="code" class="cpp">#include <iostream><br>#include <algorithm><br>#include <cstdio><br><br>using namespace std;<br><br>int a[40010], s;<br><br>int search(int start, int end, int key)<br>{<br>&nbsp; &nbsp; int mid, pos = 0;<br>&nbsp; &nbsp; while (start &lt; end)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; mid = (start + end) / 2;<br>&nbsp; &nbsp; &nbsp; &nbsp; if (a[mid] &gt; key) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = mid;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = end;<br>&nbsp; &nbsp; &nbsp; &nbsp; }else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = mid + 1;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = start;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return pos;<br>}<br><br>int main(int argc, char const <em>argv[])<br>{<br>    int T, n, m, q, h, i, j;<br>    scanf(“%d”, &amp;T);<br>    while (T–)<br>    {<br>        scanf(“%d%d%d”, &amp;n, &amp;m, &amp;q);<br>        s = n </em> m;<br>        for (i=0; i&lt;s; i++)<br>            scanf(“%d”, &amp;a[i]);<br>        sort(a, a+s);<br>        while (q–)<br>        {<br>            scanf(“%d”, &amp;h);<br>            if (h &lt; a[0]) printf(“%d\n”, s);<br>            else if (h &gt; a[s-1]) printf(“%d\n”, 0);<br>            else<br>                printf(“%d\n”, s - search(0, s-1, h));<br>        }<br>    }<br>    return 0;<br>}</cstdio></algorithm></iostream></pre><br><br></div>
]]></content>
      <categories>
        <category>二分法</category>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>省赛</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_C_箭无虚发</title>
    <url>/2016/09/25/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-c-e7-ae-ad-e6-97-a0-e8-99-9a-e5-8f-91/</url>
    <content><![CDATA[<p>#<br>箭无虚发</p>
<p></p><p></p>
<table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Time Limit: 1000 MS</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Memory Limit: 65536 KB</span></td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Total Submissions: 128</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Accepted: 21</span></td><br></tr><br></tbody><br></table>

<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JH苦练10年，终于成为了一个神箭手，在下山之前，大师兄YZ不放心，想考验他，只给他一定时间t，同时给他n支箭，最终根据他的表现，考虑他是否能下山。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每发一次箭，YZ给他4种成绩（优、良、中、差），JH有三种拉弓以及瞄准时间a ,b，c（a&gt;=b&gt;=c）分别能拿优，良，中等级，如果不拉弓不瞄（直接射），只能拿差（不能中靶）了。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在JH想知道，在保证自己弹无虚发（不获得差）的情况下，最多能拿多少个优。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果JH不能做到弹无虚发，输出Oh，my god!&nbsp;<br><br></div><br><a id="more"></a><br>## Input<br><br><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入数据包含T组:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每组数据，第一行为一个整数n，表示总共有n支箭。<br><br>（0&lt;n&lt;=1000）<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后n行，每行包含三个数字a，b，c，分别表示拿对应等级所需要花的时间。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0&lt;c&lt;=b&lt;=a&lt;=1000)<br><br>之后一个数字t，表示JH有考核总时间为t<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0&lt;=t&lt;=1e6)<br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div>对于每组输入，如果JH能箭无虚发，则输出一个数字x，表示最多能拿到的优的数量。如果不能，则输出Oh，my god!<br><br></div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div>3<br><br>1<br><br>3&nbsp;2&nbsp;1<br><br>1<br><br>2<br><br>3&nbsp;2&nbsp;1<br><br>3&nbsp;2&nbsp;1<br><br>4<br><br>2<br><br>3&nbsp;2&nbsp;1<br><br>3&nbsp;2&nbsp;1<br><br>1<br><br></div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div>0<br><br>1<br><br>Oh,my&nbsp;god!</div>

<div><br><br></div>

<div><span style="font-size:14px; color:#ff0000">题解：这道题在做的时候就用到一些技巧了，其实成绩良在此题内属于多余条件，得优的时间&gt;得中的时间。</span></div>

<div><span style="font-size:14px; color:#ff0000">所以一开始全部得中，得到最小花费的时间，如果此时间都大于考核的时间，那么必定会得差</span></div>

<div><span style="font-size:14px; color:#ff0000">然后用贪心法依次往里加一个优试试，如果满足则加入，所以会按得优的时间减去得中的时间a.a-a.c排序，这样保证每次添加进去最小的时间，直到结束或超过考核时间</span></div>

<div><span style="font-size:14px; color:#ff0000">最后就会得出答案了</span></div>

<div><br><br></div>

<div><pre code_snippet_id="1899526" snippet_file_name="blog_20160925_1_2685340" name="code" class="cpp">#include <iostream><br>#include <cstdio><br>#include <algorithm><br><br>using namespace std;<br><br>struct J<br>{<br>    int a, b, c;<br>}a[1002];<br><br>bool cmp(J a, J b)<br>{<br>    return a.a - a.c &lt; b.a - b.c;<br>}<br><br>int main(int argc, char const *argv[])<br>{<br>    int T, n, t, s;<br>    scanf(“%d”, &amp;T);<br>    while (T–)<br>    {<br>        s = 0;<br>        scanf(“%d”, &amp;n);<br>        for (int i=0; i&lt;n; i++) {<br>            scanf(“%d%d%d”, &amp;a[i].a, &amp;a[i].b, &amp;a[i].c);<br>            s += a[i].c;<br>        }<br>        scanf(“%d”, &amp;t); //如果全得“中”的时间（最小花费）&gt;考核时间，就不能做到箭无虚发<br>        if (s &gt; t) printf(“Oh,my god!\n”);<br>        else {<br>            sort(a, a+n, cmp);//排序用到技巧，（得优的时间-得中的时间）按升序排序<br>            int cnt = 0;<br>            for (int i=0; i&lt;n; i++) {<br>                if (s - a[i].c + a[i].a &lt;= t) {<br>                    s = s - a[i].c + a[i].a;//加一个优并减去一个中的时间，贪心策略<br>                    cnt++;<br>                }<br>                else break;<br>            }<br>            printf(“%d\n”, cnt);<br>        }<br>    }<br>    return 0;<br>}<br></algorithm></cstdio></iostream></pre><br><br></div>
]]></content>
      <categories>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>省赛</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_E_转啊转</title>
    <url>/2016/09/25/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-e-e8-bd-ac-e5-95-8a-e8-bd-ac/</url>
    <content><![CDATA[<p>#<br>转啊转</p>
<p></p><p></p>
<table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Time Limit: 1000 MS</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Memory Limit: 65536 KB</span></td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Total Submissions: 59</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Accepted: 15</span></td><br></tr><br></tbody><br></table>

<div style="text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif; color:#666666"></span><br><br>## Description<br><br><div>&nbsp;&nbsp;&nbsp;&nbsp;在二维平面上，有一个固定的圆和一个固定的点（保证该点不在圆上），还有一个动点在圆上以角速度<strong><span style="font-family:Calibri">w</span>绕圆心一直转。在<span style="font-family:Calibri">t</span>时刻，连接该动点与定点成一条直线<span style="font-family:Calibri">k</span>，求直线<span style="font-family:Calibri">k</span>被圆所截线段的长度（即直线<span style="font-family:Calibri">k</span>在圆内部分长度）。</strong><br><span style="font-size:14px"><strong><span style="font-family:Calibri">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>动点初始时刻在圆的三点钟方向（即与<span style="font-family:Calibri">x</span>轴正方向平行），并以逆时针方向绕圆转。</strong></span><br><br><img src="http://acm.hfut.edu.cn/OnlineJudge/UploadFile/201605272027354400000_84B1CBD0D8C922FCE1675B1F6BC6189A.png" alt>​<br><a id="more"></a><br><span style="font-size:14px"><strong><span style="font-family:Calibri">&nbsp;&nbsp;</span></strong></span><br><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><div><br><span style="font-size:14px"><strong><span style="font-family:Calibri">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>先输入一个整数<span style="font-family:Calibri">T</span>，表示<span style="font-family:Calibri">T</span>（<span style="font-family:Calibri">T&lt;50</span>）组数据。</strong></span><br><br><span style="font-size:14px"><strong>每组数据一行七个实数<span style="font-family:Calibri">a,b,r(r&gt;0),x,y,w(w&gt;=0),t(t&gt;=0)&nbsp;</span>分别表示圆的圆心坐标（<span style="font-family:Calibri">a,b</span>），半径<span style="font-family:Calibri">r,</span>固定点坐标<span style="font-family:Calibri">(x,y)</span>，角速度<span style="font-family:Calibri">w,</span>要查询的时刻<span style="font-family:Calibri">t</span>。</strong></span><br><br><span style="font-size:14px"><strong><span style="font-family:Calibri">&nbsp;&nbsp;&nbsp;&nbsp;</span>上述所有数据的绝对值小于<span style="font-family:Calibri">10000</span>。</strong></span><br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div><br><span style="font-size:14px"><strong><span style="font-family:Calibri">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>输出答案占一行，保留<span style="font-family:Calibri">2</span>位小数。</strong></span><br></div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div>1<br><br>1&nbsp;1&nbsp;1&nbsp;3&nbsp;1&nbsp;3&nbsp;0<br><br></div>

<h2 id><a href="#" class="headerlink" title></a><span style="font-family:tahoma,arial,verdana,sans-serif; color:#666666"></span></h2><p>Sample Output</p>
<p><span style="font-family:tahoma,arial,verdana,sans-serif; color:#666666"></span></p>
<p></p>
<div>2.00</div>

<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><div><br><span style="font-size:14px">角速度定义：</span><br><br><span style="font-size:14px"><span style="color:rgb(51,51,51)">一个以弧度为单位的圆（一个圆周为</span><span style="color:rgb(51,51,51)">2π,</span><span style="color:rgb(51,51,51)">即：</span><span style="color:rgb(51,51,51)">360</span><span style="color:rgb(51,51,51)">度</span><span style="color:rgb(51,51,51)">=2π),</span><span style="color:rgb(51,51,51)">在单位时间内所走的弧度即为角速度。</span></span><br></div>

<p></p></div><p></p>
<div style="text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif; font-size:14px; color:#ff0000">这道题在省赛时没有做出来，真的是很亏，考得纯粹的数学题</span></div>

<div style="text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif; font-size:14px; color:#ff0000">题解，这道题也是比较简单的，注意点到直线的公示</span></div>

<div style="text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif; font-size:14px; color:#ff0000">点（a, b）,直线：y=kx+b;</span></div>

<div style="text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif; font-size:14px; color:#ff0000">&lt;span style=”font-family:zuoyeFont_mathFont,”Microsoft Yahei”,宋体,sans-serif; background-color:rgb(255,255,238)”&gt;距离d=|kx-y+b|/√[k²+（-1）²] ;</span><br><br></div>

<div style="text-align:left"><span style="font-family:zuoyeFont_mathFont,Microsoft Yahei,宋体,sans-serif; font-size:14px; color:#ff0000"><span style="background-color:rgb(255,255,238)">然后就是点B的表示方式：B(a+rcos(wt), b+rsin(wt));</span></span></div>

<div style="text-align:left"><span style="font-family:zuoyeFont_mathFont,Microsoft Yahei,宋体,sans-serif; font-size:14px; color:#ff0000"><span style="background-color:rgb(255,255,238)">有这几个就可以把这道题给写好了</span></span></div>

<div style="text-align:left"><span style="font-family:zuoyeFont_mathFont,Microsoft Yahei,宋体,sans-serif; font-size:14px; color:#ff0000"><span style="background-color:rgb(255,255,238)"></span></span><pre code_snippet_id="1899561" snippet_file_name="blog_20160925_1_1769979" name="code" class="cpp">#include <iostream><br>#include <cstdio><br>#include <cmath><br><br>using namespace std;<br><br>int main()<br>{<br>    int T;<br>    scanf(“%d”, &amp;T);<br>    while (T–)<br>    {<br>        double a, b, r, x, y, w, t;<br>        scanf(“%lf%lf%lf%lf%lf%lf%lf”, &amp;a, &amp;b, &amp;r, &amp;x, &amp;y, &amp;w, &amp;t);<br>        double bx = a + r <em> cos(w</em>t);<br>        double by = b + r <em> sin(w</em>t);<br>        double k = (by - y) / (bx - x);//斜率k<br>        double l = y - k <em> x;<br>        double d = pow(k </em> a - b + l, 2) / (k <em> k + 1);//点到直线的距离公式<br>        double ans = sqrt(r </em> r - d) * 2;<br>        printf(“%.2lf\n”, ans);<br>    }<br>    return 0;<br>}<br></cmath></cstdio></iostream></pre><br><br></div>
]]></content>
      <categories>
        <category>数学</category>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>省赛</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_F_吃在工大</title>
    <url>/2016/09/25/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-f-e5-90-83-e5-9c-a8-e5-b7-a5-e5-a4-a7/</url>
    <content><![CDATA[<p>#<br>吃在工大</p>
<p></p><p></p>
<table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Time Limit: 1000 MS</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Memory Limit: 65536 KB</span></td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Total Submissions: 51</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Accepted: 15</span></td><br></tr><br></tbody><br></table>

<div style="text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif"></span><br><br>## Description<br><br><div style="color:rgb(102,102,102)"><strong>&nbsp;&nbsp;&nbsp;&nbsp; JH和他的好朋友YZ两名程序员回访母校合工大，准备在这住一段日子，都说“玩在安大，吃在工大”，JH又是一名典型吃货，于是决定在工大食堂好好吃一段日子，但是，面对美食诱惑：黄焖鸡、风暴干锅、麻辣香锅、奥尔良烤翅…由于时间有限，JH不知道哪顿饭吃哪个菜好。</strong><br><strong>于是YZ为了帮助他解决这个问题，也顺便考考他，给他出了一个问题：“黄焖鸡必须在干锅花菜前面吃，干锅牛肉必须在干锅鱿鱼前面吃….你按这个要求下，就知道吃的顺序啦”。JH抓抓头，分分钟写了个程序搞定，现在，让你来写写看？输出一组JH符合条件下吃的食物的序列。</strong><br><br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;假设JH每顿只吃一种食物，且每顿吃的都不同，食物编号1到N。</strong><br><a id="more"></a><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(102,102,102)"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先输入一个整数T，表示T（T&lt;50）组数据。</strong><br><strong>每组数据第一行输出一个整数，N,M,分别表示有N种食物，总共有M个约束条件，接下来M行每行输入两个正整数a,b(n&gt;=a&gt;0,n&gt;=b&gt;0)，表示食物a必须在食物b之前吃。</strong><br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(102,102,102)"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;各组数据输出答案占一行，输出一组符合条件的序列（要求输出字典序最大的那一组），如果答案不存在，输出“-1”。</strong><br><br></div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(102,102,102)">1<br><br>4&nbsp;3<br><br>1&nbsp;2&nbsp;<br><br>2&nbsp;3<br><br>4&nbsp;3<br><br></div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div style="color:rgb(102,102,102)">4&nbsp;1&nbsp;2&nbsp;3</div><br><div style="color:rgb(102,102,102)"><br><br></div><br><div><span style="font-size:14px; color:#ff0000">此题考得是拓扑排序，一开始做这道题的时候只知道是拓扑排序，当时带了几本书了都写的有，怪自己当初没有好好看书，不知道其中的原理，比赛时照着一个拓扑排序的程序写了，然后测试过了几次，都是正确的，还是不知道怎么改</span></div><br><div><span style="font-size:14px; color:#ff0000">题解：拓扑排序就我理解就是在无环的图中（如果有环一定不能排），先找入度为0的点放入队列，但是找这个点也不是随便找，因为需要满足拓扑条件下时有多个是需要按字典序最大的情况，故我用到了优先队列，这样保证每次从其中取出时最大的，取出后，存入数组，并把取出的这个点所连接的点的入度-1，再次查找入度为0的点，进行此操作，直到队列空。详见程序</span></div><br><div style="color:rgb(102,102,102)"><pre code_snippet_id="1899595" snippet_file_name="blog_20160925_1_1184642" name="code" class="cpp">#include <iostream><br>#include <cstdio><br>#include <cstring><br>#include <vector><br>#include <queue><br><br>using namespace std;<br><br>const int maxn = 10000 + 5;<br>vector<int> g[maxn];<br>int du[maxn], n, m, L[maxn];<br><br>bool toposort()<br>{<br>    memset(du, 0, sizeof(du));<br>    for (int i=0; i&lt;n; i++)<br>        for (int j=0; j&lt;g[i].size(); j++)<br>            du[g[i][j]]++;<br>    int tot = 0;<br>    priority_queue<int> Q;<br>    for (int i=0; i&lt;n; i++)<br>        if (!du[i]) Q.push(i);//入度为0的点存入优先队列<br>    while (!Q.empty()) {<br>        int x = Q.top(); Q.pop();<br>        L[tot++] = x;//取出入度为0的点，并存入数组<br>        for (int j=0; j&lt;g[x].size(); j++){<br>            int t = g[x][j];<br>            du[t]–;//相连的点入度依次减一<br>            if (!du[t])<br>                Q.push(t);//把入度为0的点放入优先队列<br>        }<br>    }<br>    if (tot == n)<br>        return 1;<br>    return 0;<br>}<br><br>int main(int argc, char const *argv[])<br>{<br>    int t;<br>    scanf(“%d”, &amp;t);<br>    while (t–)<br>    {<br>        scanf(“%d%d”, &amp;n, &amp;m);<br>        for(int i=0;i&lt;n;i++)<br>            g[i].clear();<br>        while (m–)<br>        {<br>            int N, M;<br>            scanf(“%d%d”, &amp;N, &amp;M);<br>            g[N-1].push_back(M-1);<br>        }<br>        int first = 0;<br>        if (toposort()) {<br>            for (int i=0; i&lt;n; i++) {<br>                if (first)<br>                    printf(“ “);<br>                first = 1;<br>                printf(“%d”, L[i]+1);<br>            }<br>            printf(“\n”);<br>        }<br>        else<br>            printf(“-1\n”);<br>    }<br>    return 0;<br>}</int></int></queue></vector></cstring></cstdio></iostream></pre><br><br></div>

<p></p></div><p></p>
]]></content>
      <categories>
        <category>拓扑排序</category>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>省赛</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_I_恶魔A+B</title>
    <url>/2016/10/30/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-i-e6-81-b6-e9-ad-94a-2bb/</url>
    <content><![CDATA[<div style="text-align:center"><br><br>恶魔A+B<br><br><table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left">Time Limit: 1000 MS</td><br><td style="margin:0px; padding:0px; text-align:left">Memory Limit: 65536 KB</td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left">Total Submissions: 73</td><br><td style="margin:0px; padding:0px; text-align:left">Accepted: 17</td><br></tr><br></tbody><br></table><br><br></div>

<p>##</p>
<p>Description</p>
<p><span style="white-space:pre"></span>相信大家都做过A+B问题，这个问题简直太简单了，以至于所有的程序员都会做这个题目。</p>
<p>有一天，萌萌哒YZK学姐写了很久很久的代码，以至于在半睡半醒状态看到了恶魔。</p>
<p>恶魔说：愚蠢的程序员啊，不要再做无谓的挣扎了，你再怎么写代码，也改变不了这个世界终将被我统治的结局。</p>
<p>YZK学姐顿时觉得自己被侵犯了，为了程序员的尊严，她要求与恶魔进行决斗，决斗的形式就是写代码。</p>
<p>恶魔给出了一个非常复杂的A+B问题，对于两个长度小于1000的26进制数，它们相加的结果是什么呢？</p>
<p>两人谁先解决这个问题谁就获胜，你能帮助YZK学姐战胜恶魔吗？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行一个整数T，代表测试数据组数，0&lt;T&lt;25。</p>
<p>之后T行，每行两个长度不大于1000的字符串，仅包含a~z和小数点，a~z分别代表数字0~25。<br><a id="more"></a></p>
<p>##</p>
<p>Output</p>
<p>相加的结果，不能包含前后导零（即a）。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2</p>
<p>b b</p>
<p>b.b a.c</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>c</p>
<p>b.d</p>
]]></content>
      <categories>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>省赛</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_G_木条染色</title>
    <url>/2016/09/27/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-g-e6-9c-a8-e6-9d-a1-e6-9f-93-e8-89-b2/</url>
    <content><![CDATA[<p>#<br>木条染色</p>
<p></p><p></p>
<table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Time Limit: 1000 MS</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Memory Limit: 65536 KB</span></td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Total Submissions: 134</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Accepted: 20</span></td><br></tr><br></tbody><br></table>

<div style="text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif"></span><br><br>## Description<br><br><div style="color:rgb(102,102,102)">&nbsp; &nbsp;小明是一个非常浪漫的画家，他喜欢画各种奇奇怪怪的画，虽然没人理解他画的究竟是什么东西。<br>有一天，他突发奇想，对于一根木条，他每次从木条中选取一个区间[l,r]进行染色，经过多次染色后，他想知道在[a,b]区间中有几个未被染色的子区间？<br><br>可惜小明虽然画画非常厉害，但是并不擅长解决这类问题，于是，他拿着这根木条来找你，希望你能够给他帮助。<br><br>假设木条无限长，所有查询都在木条长度范围内，未被染色的子区间是指，木条上染过色的区间的间断部分。<br><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(102,102,102)">第一行一个整数T，代表数据组数。<br>对于每组数据，第一行给出两个整数n，q，分别代表染色的区间个数，以及查询个数。<br><br>之后n行，每行两个整数l，r，表示将l到r的区间进行染色，包含l，r两个节点。<br><br>之后q行，每行两个整数a，b，表示询问a到b总共有多少未被染色的子区间。<br><br>两组数据之间用一个空行隔开。<br><a id="more"></a><br>T&lt;20<br><br>n&lt;10000<br><br>q&lt;100000<br><br>0&lt;=l&lt;r&lt;1000000<br><br>0&lt;=a&lt;=b&lt;1000000<br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(102,102,102)">对于每次询问，输出一个整数，表示查询结果。<br>每组数据之后，请输出一个空行。<br></div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(102,102,102)">2<br><br>2&nbsp;3<br><br>1&nbsp;2<br><br>3&nbsp;4<br><br>1&nbsp;3<br><br>3&nbsp;4<br><br>5&nbsp;5<br><br>3&nbsp;3<br><br>1&nbsp;5<br><br>2&nbsp;8<br><br>5&nbsp;6<br><br>0&nbsp;5<br><br>0&nbsp;9<br><br>9&nbsp;9<br><br></div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div style="color:rgb(102,102,102)">1<br><br>0<br><br>1<br><br>1<br><br>2<br><br>1<br><br></div>

<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><div><span style="color:#666666">对于第一组数据，[0,1)，(2,3)，(4,+)是未染色的子区间，因此查询[1,3]可以找到(2,3)这个子区间，而对于[3,4]不能找到，对于[5,5]可以找到[5,5]。</span><br><br>对于第二组数据，[0,1)和(8,+)是未染色的子区间，因此对于[0,5]只有子区间[0,1)，对于查询[0,9]，有子区间[0,1)和（8,9]，对于查询[9,9]，有[9,9]这个子区间。<br><p style="color:rgb(102,102,102)"><br><br><span style="font-size:14px; color:#ff0000">//这道题还木有做出来，正在努力A中，欢迎各位朋友给出解题思路</span><br><br><span style="color:#ff0000"><span style="font-size:14px">2017-4-29 19:02:19—-补下这道题的题解，这道题用的是线段是+离散化，代码参考如下</span></span><br><br><span style="color:#ff0000"><span style="font-size:14px"><br><br></span></span><br><br><span style="color:#ff0000"><span style="font-size:14px"><br><br></span></span><br><br><span style="color:#ff0000"><span style="font-size:14px"></span></span></p><br><br><pre code_snippet_id="2363556" snippet_file_name="blog_20170429_1_9522696" name="code" class="cpp">#include<cstdio><br>#include<cstring><br>#include<algorithm><br>using namespace std;<br>#define lson i&lt;&lt;1<br>#define rson (i&lt;&lt;1)+1<br>int maxn,t,n,m;<br>int va[500000];<br>int ha[1000005],pre,pre2;<br>struct node{<br>    int x,y;<br>}b[100005];<br>int a[100005];<br>void build(int i,int l,int r)<br>{<br>       va[i] = 1;<br>       if(l==r)return;<br>       build(lson,l,(l+r)/2);<br>       build(rson,(l+r)/2+1,r);<br>}<br>inline void pushUp(int i)<br>{<br>     if(va[lson]==va[rson])va[i] = va[lson];<br>     else va[i] = -1;<br>}<br>inline void pushDown(int i)<br>{<br>    va[lson] = va[i];<br>    va[rson] = va[i];<br>}<br>void update(int i,int l,int r,int L,int R)<br>{<br>     if(l==L&amp;&amp;r==R)<br>     {<br>         va[i] = 0;<br>         return ;<br>     }<br>     if(va[i]!=-1)pushDown(i);<br>     if(R&lt;=(l+r)/2)update(lson,l,(l+r)/2,L,R);<br>     else if(L&gt;=(l+r)/2+1)update(rson,(l+r)/2+1,r,L,R);<br>     else {<br>         update(lson,l,(l+r)/2,L,(l+r)/2);<br>         update(rson,(l+r)/2+1,r,(l+r)/2+1,R);<br>     }<br>     pushUp(i);<br>}<br>int  query(int i,int l,int r,int L,int R)<br>{<br>     if(va[i]!=-1)<br>     {<br>         return va[i];<br>     }<br>     if(R&lt;=(l+r)/2)return query(lson,l,(l+r)/2,L,R);<br>     else if(L&gt;=(l+r)/2+1)return query(rson,(l+r)/2+1,r,L,R);<br>     else return query(lson,l,(l+r)/2,L,(l+r)/2) + query(rson,(l+r)/2+1,r,(l+r)/2+1,R);<br>}<br>inline void init()<br>{<br>        pre = 2;<br>        sort(a,a+2<em>n);<br>        ha[a[0]] = pre;<br>        for(int i=1;i&lt;2</em>n;i++)<br>            if(a[i]&gt;a[i-1])<br>            {<br>                pre+=2;<br>                ha[a[i]] = pre;<br>            }<br>        pre2 = 1;<br>        for(int i=max(a[0]-1,0);i&lt;=a[2<em>n-1]+2;i++)<br>           if(ha[i])<br>           {<br>                  pre2 = ha[i]+1;<br>           }<br>           else ha[i] = pre2;<br>}<br>int main()<br>{<br>    scanf(“%d”,&amp;t);<br>    while(t–)<br>    {<br>        scanf(“%d%d”,&amp;n,&amp;m);<br>        for(int i=0;i&lt;n;i++)<br>        {<br>              scanf(“%d%d”,&amp;a[i</em>2],&amp;a[i<em>2+1]);<br>            b[i].x = a[i</em>2];<br>            b[i].y = a[i<em>2+1];<br>        }<br>        init();<br>        build(1,1,pre2);<br>        for(int i=0;i&lt;n;i++)<br>            update(1,1,pre2,ha[b[i].x],ha[b[i].y]);<br>        for(int i=0;i&lt;m;i++)<br>        {<br>            int c,d;<br>            c = max(c,max(0,a[0]-1));<br>            d = min(a[2</em>i-1]+2,d);<br>            scanf(“%d%d”,&amp;c,&amp;d);<br>            printf(“%d\n”,query(1,1,pre2,ha[c],ha[d]));<br>        }<br>        for(int i=max(a[0]-1,0);i&lt;=a[2*n-1]+2;i++)<br>            ha[i] = 0;<br>        if(t!=0)printf(“\n”);<br>    }<br>    return 0;<br>}</algorithm></cstring></cstdio></pre><br><br></div>

<p></p></div><p></p>
]]></content>
      <categories>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>省赛</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_H_单身晚会</title>
    <url>/2016/09/27/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-h-e5-8d-95-e8-ba-ab-e6-99-9a-e4-bc-9a/</url>
    <content><![CDATA[<p>#<br>单身晚会</p>
<p></p><p></p>
<table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Time Limit: 1000 MS</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Memory Limit: 65536 KB</span></td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Total Submissions: 53</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Accepted: 16</span></td><br></tr><br></tbody><br></table>

<p>&lt;</p>
<p>div style=”text-align:left”&gt;<span style="font-family:tahoma,arial,verdana,sans-serif; color:#666666"></span></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><div>​ZJ和ZCX在一起很久了，两个人都互生爱意，最终决定喜结良缘，从此踏入浪漫的婚姻殿堂。<br>但是，ZJ的好基友们想到以后ZJ就不能经常跟他们一起愉快的玩耍了，都觉得非常伤心难过，于是他们决定在最后一晚为ZJ开一场单身晚会，玩整晚紧张刺激的飞行棋。<br><br>ZJ的好基友居住在城市的各个地方（每个地方不一定只有一个基友），他们需要从各个地方赶到其中一个朋友的家里来参加这最后的单身PARTY，ZJ被基友们的热情深深感动了，决定对基友们来时的路费进行报销。报销规则按照距离来计算。基友们为了帮ZJ省钱，决定在所有人走最短路径的情况下，总距离最小的人的家里开PARTY。<br><br>ZJ想知道基友们走过的总距离是多少，然后他把总共需要报销的钱拿出来，就可以让基友们自己来分配了。但是他算了半天也没算出来总距离是多少，单身PARTY马上就开始了，你能帮帮他吗？<br><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><a id="more"></a>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行一个整数T，表示有T（T&lt;15）组数据<br>每组数据的第一行基友数（包括ZJ）N（N&lt;100），路口P（2&lt;=P&lt;=100）,路口之间道路数C(1&lt;=C&lt;=1450)，（基友的编号为1…N，路口的编号为1…P）<br><br>第二行到第N+1行：编号为1到N的基友们家所在的路口号。<br><br>第N+2行到N+C+1行：每行有三个数：相连的路口A,B，路口间间距D（1&lt;=D&lt;=255），当然，连接是双向的。<br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div>每组数据输出占一行，输出大家必须要走的最小距离和<br><br></div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div>1<br><br>3&nbsp;4&nbsp;5<br><br>2<br><br>3<br><br>4<br><br>1&nbsp;2&nbsp;1<br><br>1&nbsp;3&nbsp;5<br><br>2&nbsp;3&nbsp;7<br><br>2&nbsp;4&nbsp;3<br><br>3&nbsp;4&nbsp;5<br><br></div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div>8</div>

<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><div>经测试，本题数据和题意不符合，现对题意做如下修正：<br><br>选择一个路口（不一定要有人住），使所有人到这个路口的路程和最小化<br><br>这题应该是省赛现场修改题意，但这里用的是原题意，特此说明。对被卡的同学再次表示歉意。对其他题目有疑义的可以发信件给账号instankill询问。</div><br><div><span style="font-size:14px; color:#ff0000"><br><br></span></div><br><div><span style="font-size:14px; color:#ff0000">这道题在省赛中改过题意，重新A时发现自己很多次也提交不过，感觉Hint的注意也写的不是很清晰。</span></div><br><div><span style="font-size:14px; color:#ff0000">题解：这道题是典型的利用Floyd算法求最短路径的问题，有关Floyd算法此处省略，网上有很多，介绍的也很详细。先利用Floyd算法求出任意两个路口的最短路径。最后求任意一个路口到所有基友的距离之和，最后找到最小值，也就是在路口也是可以开party的。一开始也是没明白题意，理解成要在基友家里开party，所以老是Wrong Answer。只要注意这点应该就没有问题了</span></div><br><div><br><br></div><br><div><pre code_snippet_id="1904102" snippet_file_name="blog_20160928_1_8814754" name="code" class="cpp">#include <iostream><br>#include <cstdio><br>#include <cstring><br>typedef long long LL;<br>const LL INF = 1000000000;<br><br>using namespace std;<br><br>int a[101];<br>LL L[101][101];<br>int n, p, c;<br><br>void floyd() //Floyd最短路径算法<br>{<br>    for (int k=1; k&lt;=p; k++)<br>        for (int i=1; i&lt;=p; i++)<br>            for (int j=1; j&lt;=p; j++)<br>                L[i][j] = min(L[i][j], L[i][k]+L[k][j]);<br>}<br><br>int main()<br>{<br>    int t;<br>    scanf(“%d”, &amp;t);<br>    while (t–)<br>    {<br>        scanf(“%d%d%d”, &amp;n, &amp;p, &amp;c);<br>        for (int i=1; i&lt;=n; i++)<br>            scanf(“%d”, &amp;a[i]);<br>        int A, B, D;<br>        for (int i=1; i&lt;=p; i++)<br>            for (int j=1; j&lt;=p; j++)<br>                L[i][j] = INF;<br>        for (int i=1; i&lt;=p; i++)<br>            L[i][i] = 0;<br>        for (int i=0; i&lt;c; i++) {<br>            scanf(“%d%d%d”, &amp;A, &amp;B, &amp;D);<br>            L[A][B] = D;<br>            L[B][A] = D;<br>        }<br>        floyd();<br>        LL Smin = INF, s = 0;<br>        for (int i=1; i&lt;=p; i++) {<br>            s = 0;<br>            for (int j=1; j&lt;=n; j++) {<br>                if (L[i][a[j]] &gt;= INF) //先排除无穷大的边<br>                    goto to; //出现就进入下一次循环<br>                s += L[i][a[j]];<br>            }<br>            Smin = min(Smin, s); //求出每次的最短路径<br>            to:;<br>        }<br>        printf(“%d\n”, Smin);<br>    }<br>    return 0;<br>}<br></cstring></cstdio></iostream></pre><br><br></div>

<p></p>
]]></content>
      <categories>
        <category>最短路</category>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>省赛</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_J_YZK的大别墅</title>
    <url>/2016/10/30/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-j-yzk-e7-9a-84-e5-a4-a7-e5-88-ab-e5-a2-85/</url>
    <content><![CDATA[<p>YZK的大别墅</p>
<p></p><p></p>
<table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left">Time Limit: 1000 MS</td><br><td style="margin:0px; padding:0px; text-align:left">Memory Limit: 65536 KB</td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left">Total Submissions: 24</td><br><td style="margin:0px; padding:0px; text-align:left">Accepted: 12</td><br></tr><br></tbody><br></table>

<p>&lt;</p>
<p>div id=”ext-comp-1069”&gt;</p>
<div id="ext-gen15"><br><div id="ext-gen16"><br><div id="showProblem1361"><br><div id="ext-gen226"><br><div id="ext-gen227"><br><br>## Description<br><a id="more"></a><br><div>土豪YZK最近得到了面积为n*m的一大块土地（高兴ING^_^），他想在这块土地上建造一所房别墅，但是这个别墅必须是方形的。<br>可是，这块土地并非十全十美，上面有很多不平坦的地方（也可以叫瑕疵）。这些瑕疵十分恶心，以至于根本不能在上面盖一砖一瓦。但是却可以挖成人工观赏湖，或者挖成游泳池。<br><br>YZK希望找到一块最大的方形土地来盖别墅，既然是别墅，肯定要有些景观，但是YZK最多只愿意造k个人工湖或游泳池，现在请你来帮助YZK找到面积最大的满足条件的土地。<br><br>给定一个01矩阵，0表示土地可用，1表示土地不可用，输出符合YZK要求的最大土地的面积。<br><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><div>第一行一个整数T，表示有T组测试数据。<br>对于每组测试数据，第一行包含三个整数n，m，k，表示矩阵的行数和列数，以及最多的人工湖或游泳池数量。<br><br>之后n行，每行m个整数，表示矩阵。<br><br>T&lt;25<br><br>0&lt;n,m&lt;100<br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div>对于每组数据输出一行，包含一个整数，表示最大面积。</div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div>2<br><br>2&nbsp;2&nbsp;0<br><br>1&nbsp;0<br><br>0&nbsp;1<br><br>3&nbsp;3&nbsp;1<br><br>1&nbsp;0&nbsp;0<br><br>0&nbsp;0&nbsp;1<br><br>0&nbsp;0&nbsp;1<br><br></div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div>1<br><br>6</div><br></div><br><div id="ext-gen228"></div><br></div><br></div><br></div><br></div><br>
]]></content>
      <categories>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>省赛</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽省2016“京胜杯”程序设计大赛_K_纸上谈兵</title>
    <url>/2016/10/30/e5-ae-89-e5-be-bd-e7-9c-812016-e4-ba-ac-e8-83-9c-e6-9d-af-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-a4-a7-e8-b5-9b-k-e7-ba-b8-e4-b8-8a-e8-b0-88-e5-85-b5/</url>
    <content><![CDATA[<p>纸上谈兵</p>
<p></p><p></p>
<table width="300" style="font-family:tahoma,arial,verdana,sans-serif; font-size:9pt; text-align:center; padding-left:15px; color:rgb(102,102,102); margin:auto"><br><tbody><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Time Limit: 1000 MS</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Memory Limit: 65536 KB</span></td><br></tr><br><tr><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Total Submissions: 3</span></td><br><td style="margin:0px; padding:0px; text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif">Accepted: 1</span></td><br></tr><br></tbody><br></table>

<div style="text-align:left"><span style="font-family:tahoma,arial,verdana,sans-serif; color:#666666"></span><br><br>## Description<br><a id="more"></a><br><div><strong>&nbsp; &nbsp;&nbsp;战国时期，孙膑与庞涓都拜在鬼谷子门下学习。有一日师父鬼谷子想考察他们兵法，对着墙上挂着的一幅当时城池地图（假设城池编号从1到N，相邻城池之间有边相连），让他们自己相互考察：</strong><br><strong>庞涓出题：“如果我给出一组城池间相互约束的关系，你能否给我一个攻城方案，…….”</strong><br><br><strong>孙膑出题：“如果从1号城池出发，到达N号城池，请问最多有几条最近的路？我对不同的最近的路有两种定义，第一种：‘如果两条路径有一条边不相同，就认为这两条路径不同’，第二种‘如果两条路径有一条边相同，就认为相同’，请告诉我在这两种不同定义下，各自答案是多少”</strong><br><br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;由于地图很大，图上大大小小的城池很多，两人对着图一时有点迷糊，这就很尴尬了！</strong><br><br><strong>据说当时缓解这尴尬局面的一位来自未来的神奇少年，背地里相互告诉他们各自的答案，这人莫非就是你？</strong><br><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><div><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先输入一个整数T，表示T（T&lt;50）组数据。</strong><br><strong>每组第一行三个正整数N，M，K（500&gt;N&gt;0，10000&gt;M&gt;0，50000&gt;K&gt;0），表示表示有N个城池，M条边,K组约束关系。</strong><br><br><strong>接下里M行，每行3个正整数a，b，w(N&gt;=a,b&gt;=1,1000000&gt;w&gt;0)，表示a,b之间有条边，长度为w。</strong><br><br><strong>接下来K行，每行有下面几种形式：</strong><br><br><strong>1 a b&nbsp;：表示如果攻打城池a，则必须攻打城池b。</strong><br><br><strong>2 a b&nbsp;：表示城池a,b至少攻打一个。</strong><br><br><strong>3 a b&nbsp;：表示如果城池a攻打了，则城池b不能攻打。</strong><br><br><strong>4 a b&nbsp;：表示如果城池a没有攻打，则城池b必须攻打。</strong><br><br><strong>5 a b&nbsp;：表示城池a与城池b只能都攻打或者都不攻打。&nbsp;</strong><br><br><strong>&nbsp;&nbsp; (N&gt;=a,b&gt;=1)&nbsp; &nbsp;&nbsp;</strong><br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每组数据输出占三行：</strong><br><strong>第一行输出孙膑给的方案，N个数，如果城池i攻打，输出1，反之输出0，这N个数构成的01序列代表一个方案。如果不存在方案，输出“impossible.”</strong><br><br><strong>第二行输出庞涓的第一个解，输出按第一种定义下的最短路；第三行输出庞涓的第二个解，输出按第二种定义下的最短路。如果不存在最短路，输出“-1”</strong><br></div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div>2<br><br>5&nbsp;6&nbsp;5<br><br>1&nbsp;2&nbsp;3<br><br>2&nbsp;4&nbsp;4&nbsp;<br><br>4&nbsp;5&nbsp;1<br><br>1&nbsp;3&nbsp;5<br><br>3&nbsp;4&nbsp;2<br><br>3&nbsp;5&nbsp;3<br><br>1&nbsp;1&nbsp;2<br><br>1&nbsp;2&nbsp;1<br><br>2&nbsp;1&nbsp;2<br><br>3&nbsp;1&nbsp;4<br><br>4&nbsp;3&nbsp;5<br><br>3&nbsp;3&nbsp;5<br><br>1&nbsp;2&nbsp;10<br><br>2&nbsp;3&nbsp;10<br><br>1&nbsp;3&nbsp;20<br><br>1&nbsp;1&nbsp;2<br><br>1&nbsp;2&nbsp;1<br><br>2&nbsp;1&nbsp;2<br><br>3&nbsp;1&nbsp;3<br><br>1&nbsp;2&nbsp;3&nbsp;&nbsp;<br><br></div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div>1&nbsp;1&nbsp;0&nbsp;0&nbsp;1<br><br>3<br><br>2<br><br>impossible.<br><br>2<br><br>2<br><br></div>

<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><div><strong>第一组样例中：孙膑的答案表示&nbsp;攻打1 2 5，不攻打3 4。庞涓的第一个解：1-&gt;2-&gt;4-&gt;5,&nbsp; 1-&gt;3-&gt;4-&gt;5, 1-&gt;3-&gt;5。第二个解：1-&gt;2-&gt;4-&gt;5, 1-&gt;3-&gt;5</strong></div>

<p></p></div><p></p>
]]></content>
      <categories>
        <category>省赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>省赛</tag>
      </tags>
  </entry>
  <entry>
    <title>树、森林和二叉树的转换</title>
    <url>/2016/12/31/e6-a0-91-e3-80-81-e6-a3-ae-e6-9e-97-e5-92-8c-e4-ba-8c-e5-8f-89-e6-a0-91-e7-9a-84-e8-bd-ac-e6-8d-a2/</url>
    <content><![CDATA[<p><strong>树转换为二叉树</strong></p>
<p>（1）加线。在所有兄弟结点之间加一条连线。</p>
<p>（2）去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。</p>
<p>（3）层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）</p>
<p><img src="http://pic002.cnblogs.com/images/2012/457289/2012110416594150.jpg" alt></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p><strong>森林转换为二叉树</strong></p>
<p>（1）把每棵树转换为二叉树。</p>
<p>（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</p>
<p>&nbsp;</p>
<p><img src="http://pic002.cnblogs.com/images/2012/457289/2012110417004247.jpg" alt></p>
<p><strong>二叉树转换为树</strong></p>
<p>是树转换为二叉树的逆过程。</p>
<p>（1）加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。</p>
<p>（2）去线。删除原二叉树中所有结点与其右孩子结点的连线。</p>
<p>（3）层次调整。<br><a id="more"></a><br><img src="http://pic002.cnblogs.com/images/2012/457289/2012110417011138.jpg" alt></p>
<p>&nbsp;</p>
<p><strong>二叉树转换为森林</strong></p>
<p>假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。</p>
<p>（1）从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。</p>
<p>（2）将每棵分离后的二叉树转换为树。</p>
<p>&nbsp;</p>
<p><img src="http://pic002.cnblogs.com/images/2012/457289/2012110417014911.jpg" alt></p>
<p><strong>Reference</strong>:</p>
<p>[1] 《大话数据结构》</p>
<p><a href="http://www.cnblogs.com/zhuyf87/archive/2012/11/04/2753950.html" target="_blank" rel="noopener">原文出处</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛入门经典 习题2-10 排列(permutation)</title>
    <url>/2015/08/30/e7-ae-97-e6-b3-95-e7-ab-9e-e8-b5-9b-e5-85-a5-e9-97-a8-e7-bb-8f-e5-85-b8-e4-b9-a0-e9-a2-982-10-e6-8e-92-e5-88-97permutation/</url>
    <content><![CDATA[<h1 id="nbsp-习题2-10-排列-permutation"><a href="#nbsp-习题2-10-排列-permutation" class="headerlink" title="&nbsp;习题2-10 排列(permutation)"></a>&nbsp;习题2-10 排列(permutation)</h1><h1 id="用1-2-3，…，9组成3个三位数-nbsp-abc-def-nbsp-和ghi-每个数字恰好使用一次，要求-nbsp-abc-def-ghi-1-2-3。输出所有解。提示：不必太动脑筋。"><a href="#用1-2-3，…，9组成3个三位数-nbsp-abc-def-nbsp-和ghi-每个数字恰好使用一次，要求-nbsp-abc-def-ghi-1-2-3。输出所有解。提示：不必太动脑筋。" class="headerlink" title="用1,2,3，…，9组成3个三位数&nbsp;abc, def,&nbsp;和ghi,每个数字恰好使用一次，要求&nbsp;abc:def:ghi = 1:2:3。输出所有解。提示：不必太动脑筋。"></a><span style="font-size:18px">用1,2,3，…，9组成3个三位数&nbsp;abc, def,&nbsp;和ghi,每个数字恰好使用一次，要求&nbsp;abc:def:ghi = 1:2:3。输出所有解。提示：不必太动脑筋。</span></h1><p><span style="font-family:KaiTi_GB2312; font-size:14px; color:#330033"><strong>解题思路：</strong></span></p>
<ul>
<li><span style="font-size:14px; color:#330033">首先abc最小值只能为123，最大值329，才符合题意。</span></li>
<li><span style="color:#FF0000"><span style="font-size:14px; color:#330033">此题重点判断1—9中每个数字都需出现，不能重复。解决方法：利用数组a[1],..,a[9]分别表示1,2…,9是否出现，出现记为1，否则记为0，只需判断a[1]+…+a[9] == 9,如果为真，则每个数字出现，且不重复。</span></span></li>
</ul>
<p><span style="font-size:14px; color:#FF0000">代码如下：</span></p>
<p><span style="color:#FF0000"><span style="font-size:14px; color:#330033"></span></span></p><br><a id="more"></a><br>&lt;<p></p>
<p>pre name=”code” class=”cpp”&gt;#include &lt;stdio.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main()<br>{<br>    int i, count = 0, j, k, a[10], c;//用i表示abc,j表示def,k表示ghi<br>    memset(a, 0, sizeof(a));//初始化数组，全部为零<br>    for ( i=123; i&lt;=329; i++ )<br>    {<br>        j = i_2;<br>        k = i_3;<br>        a[i/100] = a[i/10%10] = a[i%10] = 1;//分别标记出现过的数字<br>        a[j/100] = a[j/10%10] = a[j%10] = 1;<br>        a[k/100] = a[k/10%10] = a[k%10] = 1;<br>        for ( c=0; c&lt;10; c++ )<br>            count += a[c];<br>        if ( count == 9 ) //只有1到9每个数字被标记结果才为9<br>            printf(“%d %d %d\n”, i, j, k);<br>        count = 0;<br>        memset(a, 0, sizeof(a));<br>    }</p>
<pre><code>return 0;
</code></pre><p>}</p>
]]></content>
      <categories>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>安徽科技学院2016-2017-1学期2013信息与计算科学12班期末测试_题解</title>
    <url>/2016/11/04/e5-ae-89-e5-be-bd-e7-a7-91-e6-8a-80-e5-ad-a6-e9-99-a22016-2017-1-e5-ad-a6-e6-9c-9f2013-e4-bf-a1-e6-81-af-e4-b8-8e-e8-ae-a1-e7-ae-97-e7-a7-91-e5-ad-a612-e7-8f-ad-e6-9c-9f-e6-9c-ab-e6-b5-8b-e8-af-95-e/</url>
    <content><![CDATA[<pre><code>    &amp;lt;div class=&quot;markdown_views&quot;&amp;gt;&amp;lt;h1 id=&quot;2016-2017-1学期2013信息与计算科学12班算法分析与设计期末测试&quot;&amp;gt;2016-2017-1学期2013信息与计算科学12班&amp;lt;算法分析与设计&amp;gt;期末测试&amp;lt;/h1&amp;gt;
`&lt;/pre&gt;

[Contest Link](https://oj.ahstu.cc/JudgeOnline/contest.php?cid=1043)

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th align=&quot;left&quot;&gt;Problem ID&lt;/th&gt;
  &lt;th&gt;Title&lt;/th&gt;
  &lt;th&gt;Source&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
  &lt;td align=&quot;left&quot;&gt;1183&lt;/td&gt;
  &lt;td&gt;Problem  A   公约数和公倍数&lt;/td&gt;
  &lt;td&gt;基础&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td align=&quot;left&quot;&gt;1268&lt;/td&gt;
  &lt;td&gt;Problem  B   逆反A*B&lt;/td&gt;
  &lt;td&gt;icpc4th@ahstu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td align=&quot;left&quot;&gt;1426&lt;/td&gt;
  &lt;td&gt;Problem  C   子串和&lt;/td&gt;
  &lt;td&gt;NYOJ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td align=&quot;left&quot;&gt;1264&lt;/td&gt;
  &lt;td&gt;Problem  D   图书馆占位&lt;/td&gt;
  &lt;td&gt;icpc4th@ahstu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td align=&quot;left&quot;&gt;1527&lt;/td&gt;
  &lt;td&gt;Problem  E   快看，有人捡到钱了！！！&lt;/td&gt;
  &lt;td&gt;wwy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td align=&quot;left&quot;&gt;1528&lt;/td&gt;
  &lt;td&gt;Problem  F    蚂蚁&lt;/td&gt;
  &lt;td&gt;nyoj&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td align=&quot;left&quot;&gt;1529&lt;/td&gt;
  &lt;td&gt;Problem  G   寻找最大数&lt;/td&gt;
  &lt;td&gt;nyoj改编&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td align=&quot;left&quot;&gt;1530&lt;/td&gt;
  &lt;td&gt;Problem  H   神童的烦恼&lt;/td&gt;
  &lt;td&gt;nyoj改编&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td align=&quot;left&quot;&gt;1531&lt;/td&gt;
  &lt;td&gt;Problem  I   Grasshopper&lt;/td&gt;
  &lt;td&gt;Codeforces改编&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

* * *

## Problem  A  公约数和公倍数

### Description

小明被一个问题给难住了，现在需要你帮帮忙。问题是：给出两个整数，求出它们的最大公约数和最小公倍数。

### Input

第一行输入一个大于0的整数n(n&amp;lt;=20)，示有n组测试数据随后的n行输入两个整数i,j(i,j小于32767)。

### Output

输出每组测试数据的最大公约数和最小公倍数
</code></pre><a id="more"></a>
<pre><code>### Sample Input

&lt;pre&gt;`3
6 6
12 11
33 22
`&lt;/pre&gt;

### Sample Output

&lt;pre&gt;`6 6
1 132
11 66
`&lt;/pre&gt;

**题解**：这道题属于简单题，下面直接给出代码

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;stdio.h&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; gcd(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; b ? gcd(b, a%b) : a;
}
&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; t, a, b;
    &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;t);
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (t--)
    {
        &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d%d&quot;&lt;/span&gt;, &amp;a, &amp;b);
        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\n&quot;&lt;/span&gt;, gcd(a, b), a*b/gcd(a, b));
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
}`&lt;/pre&gt;

## Problem  B  逆反A*B

### Description

给定A B计算A_B的结果C，不过这里面都要反过来啦！  

举例：52_52=526 因为52表示25（逆反数)25*25=652，  

A B 不超过10000

### Input

输入A,B

### Output

计算A B的逆反数的积的逆反数C

### Sample Input

&lt;pre&gt;`52 52
30 30
1 1
`&lt;/pre&gt;

### Sample Output

&lt;pre&gt;`526
9
1
`&lt;/pre&gt;

**题解**：这道题也是道简单题，详见代码，关键写一个逆反数的转换函数即可

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;stdio.h&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; f(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; n?f(n/&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,a*&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;+n%&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;):a;
}
&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a,b;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(~&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d%d&quot;&lt;/span&gt;,&amp;a,&amp;b))
        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,f(f(a,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)*f(b,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;),&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;));
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
}`&lt;/pre&gt;

## Problem  C  子串和

### Description

给定一整型数列{a1,a2…,an}，找出连续非空子串{ax,ax+1,…,ay}，使得该子序列的和最大，其中，1&amp;lt;=x&amp;lt;=y&amp;lt;=n。

### Input

第一行是一个整数N(N&amp;lt;=10)表示测试数据的组数）

每组测试数据的第一行是一个整数n表示序列中共有n个整数，随后的一行里有n个整数I(-100=

### Output

对于每组测试数据输出和最大的连续子串的和。

### Sample Input

&lt;pre&gt;`1
5
1 2 -1 3 -2
`&lt;/pre&gt;

### Sample Output

&lt;pre&gt;`5
`&lt;/pre&gt;

### Hint

输入数据很多,推荐使用scanf进行输入

**题解**：经典算法，对数列进行一次扫描并求和，保存其thisSum，并更新最大和maxSum，若是当前和thisSum&amp;lt;0，则置thisSum=0从当前位置开始累加，因为负数加上一个数肯定是会变小的，最终的maxSum就是最大值

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &amp;lt;stdio.h&gt;  &lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main()

{

    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; T, n, x;
    &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;T);
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(T--)
    {
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; thisSum=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, maxSum=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;n);
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++)

        {

            &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;x);

            thisSum += x;
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(thisSum &gt; maxSum)

                maxSum = thisSum;

            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(thisSum &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)

                thisSum = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        }

        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;, maxSum);

    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;

}  `&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.Scanner;

&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(String[] args) {
        Scanner cin = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Scanner(System.in);
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; t = cin.nextInt();
        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (t-- &gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n = cin.nextInt();
            &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; maxSum = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, thisSum = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&lt;n; i++) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; data = cin.nextInt();
                thisSum += data;
                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (thisSum &gt; maxSum)
                    maxSum = thisSum;
                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (thisSum &lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)
                    thisSum = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
            }
            System.out.println(maxSum);
        }
        cin.close();
    }
}`&lt;/pre&gt;

## Problem  D  图书馆占位

### Description

图书馆占位的很厉害，只要去晚了一会就没有位置了。有些人占着位置却不来自习，这就造成了资源的浪费。现在我们的问题是一天当中有n个同学可能会来到同一个座位，假设上面有人则另外找座位，若没有人，则就可以占据此位置，直至你离开为止。为了最大化利用图书馆资源，我们要求的问题是一个位置最多能够被几个同学来用过。

### Input

多组测试数据  

第一行为n个同学 (1 &amp;lt;=n&amp;lt;=10000)  

接下来n行就是每个同学的进入图书馆的时间和离开图书馆的时间，为了简化问题，我们假设时间值为整数。

### Output

输出一个座位最多被几位同学占据。

### Sample Input

&lt;pre&gt;`6
1 3
2 4
3 6
7 9
5 7
10 11
`&lt;/pre&gt;

### Sample Output

&lt;pre&gt;`4
`&lt;/pre&gt;

**题解**：此题用贪心法求解，首先对所有同学离开图书馆的先后进行排序，然后对此序列进行遍历，只要离开图书馆的时间小于第二个同学进入图书馆的时间，这个位置可坐人数+1，遍历完毕也即得到此位置最多可以容纳的人数

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;iostream&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;vector&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;algorithm&gt;&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;;

&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; A {
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; start, end;

    &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&lt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; A &amp;a) &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;-&gt;end &lt; a.end;
    }
};

&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main() {
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n; &lt;span class=&quot;hljs-built_in&quot;&gt;cin&lt;/span&gt; &gt;&gt; n;) {
        &lt;span class=&quot;hljs-stl_container&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&lt;A&gt;&lt;/span&gt; v(n);
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &lt; n; i++)
            &lt;span class=&quot;hljs-built_in&quot;&gt;cin&lt;/span&gt; &gt;&gt; v[i].start &gt;&gt; v[i].end;
        sort(v.begin(), v.end());
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; tot = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, start = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-stl_container&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&lt;A&gt;&lt;/span&gt;::iterator it = v.begin(); it != v.end(); ++it) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (it-&gt;start &gt;= start) {
                ++tot;
                start = it-&gt;end;
            }
        }
        &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &lt;&lt; tot &lt;&lt; endl;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
}`&lt;/pre&gt;

## Problem  E  快看，有人捡到钱了！！！    

### Description

老赵喜欢吃烧烤，在一次和同学们吃完烧烤回来的路上，老赵一不小心捡了一百块，同学们强烈要求老赵买蛋糕庆祝，老赵爽快的扔了两百给蛋糕店，让他们做一个球形的大蛋糕。现在老赵拿起了刀叉准备和同学们瓜分这个蛋糕，一刀下去蛋糕成了两块，然后n个同学每人都来一刀。

现在老赵问同学们，n个人切完以后蛋糕最多有多少块。（能ac的送thinkpaid）。

### Input

多组输入，每行一个整数n，n个同学

### Output

对于每个整数n，输出一个整数s（n个人切完蛋糕最多有s块）

### Sample Input

&lt;pre&gt;`1
2
`&lt;/pre&gt;

### Sample Output

&lt;pre&gt;`4
8
`&lt;/pre&gt;

**题解**：这道题有一定难度，此题属于平面分割空间问题，需要运用递推关系，具体请查阅相关资料。

公式是**f(n)=(n^3+5n)/6+1**；

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;stdio.h&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;math.h&gt;&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (~&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;n)) {
        n++;
        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;, (n*n*n+&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;*n)/&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
}`&lt;/pre&gt;

## Problem  F  蚂蚁

### Description

n只蚂蚁义每秒1cm的速度在长为Lcm的杆子上爬行。当蚂蚁爬到杆子的端点就会掉下去。由于杆子太细，两只蚂蚁相遇时，他们不能交错通过，只能各反向回去。对于每只蚂蚁，我们知道它距离杆子左端的距离xi，但不知道它当时的朝向，计算所有蚂蚁落下杆子的最短时间和最长时间。

1&amp;lt;=L&amp;lt;=10^6

1&amp;lt;=n&amp;lt;=10^6;

0&amp;lt;=xi&amp;lt;=L;

### Input

多组输入，第一行L和n，接下来n个xi(L为杆子的长度，n只蚂蚁，及每只蚂蚁距离杆子左端的距离xi)

### Output

输出蚂蚁落下杆子的最短时间和最长时间

### Sample Input

&lt;pre&gt;`10 3
2 6 7
`&lt;/pre&gt;

### Sample Output

&lt;pre&gt;`4 8
`&lt;/pre&gt;

**题解**：这道题只要考虑清楚后其实也很好解，不需要考虑掉头情况，因为蚂蚁速度一样，即是说蚂蚁掉头对此题不产生影响。也可以这样理解，在远处观察这些蚂蚁的运动，一群蚂蚁运动时，因为速度是一样的，所以当蚂蚁碰撞而掉头时，看上去和两个点“对穿而过”没有任何区别，这样，不论最长时间还是最短时间，都只要对每只蚂蚁检查一次就好了，这是O(n)时间的算法。于是问题得解。

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;iostream&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;cstdio&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;algorithm&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;;
&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; L, n, minT, maxT, a;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (~&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d%d&quot;&lt;/span&gt;, &amp;L, &amp;n))
    {
        minT = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; maxT = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&lt;n; i++) {
            &lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;a);
            minT = max(minT, min(a, L-a));
            maxT = max(maxT, max(a, L-a));
        }
        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\n&quot;&lt;/span&gt;, minT, maxT);
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
}`&lt;/pre&gt;

## Problem  G  寻找最大数

### Description

给出一个整数n每次可以移动相邻数位上的数字，最多移动k次，得到一个新的整数，求这个新的整数的最大值是多少。

### Input

多组测试数据。

每组测试数据占一行，每行有两个数N和K (1 ≤ N≤ 10^18; 0 ≤ K ≤ 100).

### Output

每组测试数据的输出占一行，输出移动后得到的新的整数的最大值。

### Sample Input

&lt;pre&gt;`1990 1
100 0
9090000078001234 6
`&lt;/pre&gt;

### Sample Output

&lt;pre&gt;`9190
100
9907000008001234
`&lt;/pre&gt;

**题解**：一个数交换每次相邻两位数，因为高位数字越大数字结果就越大。可以交换k次，所以可以依次在当前位置到当前的第k位找到最大数并交换到当前位置，每交换一次k–

重复上述步骤，直到k=0结束，这样得到数字也即使最大数

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;stdio.h&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;string.h&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;], max;
&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; k, i, j, index;

&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; solve()
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; len = &lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(a);
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&lt;len &amp;&amp; k; i++) {
        index = i; max = a[i];
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (j=i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; j&lt;len &amp;&amp; j&lt;=i+k; j++) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (max &lt; a[j]) {
                index = j;
                max = a[j];
            }
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (j=index; j&gt;i; j--) {
            a[j] = a[j-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];
            k--;
        }
        a[i] = max;
    }
    &lt;span class=&quot;hljs-built_in&quot;&gt;puts&lt;/span&gt;(a);
}

&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (~&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s %d&quot;&lt;/span&gt;, a, &amp;k))
    {
        solve();
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
}`&lt;/pre&gt;

## Problem  H  神童的烦恼

### Description

数学神童小明终于把0到100000000的Fibonacci数列（f[0]=0,f[1]=1;f[i] = f[i-1]+f&amp;lt;a href=&quot;&quot;i&quot;&gt;=2”&gt;i-2&lt;/a&gt;）的值全部给背了下来。

接下来，CodeStar决定要考考他，于是每问他一个数字，他就要把答案说出来，不过有的数字太长了。所以规定超过4位的只要说出前4位（高4位）就可以了，可是CodeStar自己又记不住。于是他决定编写一个程序来测验小明说的是否正确。

### Input

输入若干数字n(0 &amp;lt;= n &amp;lt;= 100000000)，每个数字一行。读到文件尾结束。

### Output

输出f[n]的前4个数字（若不足4个数字，就全部输出）。

### Sample Input

&lt;pre&gt;`0
1
2
3
4
5
35
36
37
38
39
40
`&lt;/pre&gt;

### Sample Output

&lt;pre&gt;`0
1
1
2
3
5
9227
1493
2415
3908
6324
1023
`&lt;/pre&gt;

**题解**：这道题需要用到斐波那契数列的通项公式

![斐波拉契数列通项公式](http://img.blog.csdn.net/20161105010722003)

log10f(n)=n_log10((1+√5)/2)-log10√5+&lt;em&gt;log10(1-((1-√5)/(1+√5))n_) 后一部分随着n的增大快速的就趋近余0，是高阶无穷小. 可以忽略。所以有**log10f(n) ≈n&lt;/em&gt;log10((1+√5)/2)-log10√5**

此题要求斐波拉契前4位，由此可以得出pow(10,log10f(n)+3-整数部分)，在对其取整即为结果。需要注意的是斐波拉契前较小项因为浮点误差所以应该事先求出

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &amp;lt;stdio.h&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n, i;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; fib[&lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;]={&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;};
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; i&amp;lt;=&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;; i++)
        fib[i] = fib[i-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]+fib[i-&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];

&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;while&amp;lt;/span&amp;gt; (~&amp;lt;span class=&quot;hljs-built_in&quot;&amp;gt;scanf&amp;lt;/span&amp;gt;(&amp;lt;span class=&quot;hljs-string&quot;&amp;gt;&quot;%d&quot;&amp;lt;/span&amp;gt;, &amp;amp;n))
{
    &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;if&amp;lt;/span&amp;gt; (n &amp;lt;= &amp;lt;span class=&quot;hljs-number&quot;&amp;gt;20&amp;lt;/span&amp;gt;)
        &amp;lt;span class=&quot;hljs-built_in&quot;&amp;gt;printf&amp;lt;/span&amp;gt;(&amp;lt;span class=&quot;hljs-string&quot;&amp;gt;&quot;%d\n&quot;&amp;lt;/span&amp;gt;, fib[n]);
    &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;else&amp;lt;/span&amp;gt; {
        &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;double&amp;lt;/span&amp;gt; f=n*&amp;lt;span class=&quot;hljs-built_in&quot;&amp;gt;log10&amp;lt;/span&amp;gt;((&amp;lt;span class=&quot;hljs-built_in&quot;&amp;gt;sqrt&amp;lt;/span&amp;gt;(&amp;lt;span class=&quot;hljs-number&quot;&amp;gt;5&amp;lt;/span&amp;gt;)+&amp;lt;span class=&quot;hljs-number&quot;&amp;gt;1&amp;lt;/span&amp;gt;)*&amp;lt;span class=&quot;hljs-number&quot;&amp;gt;.5&amp;lt;/span&amp;gt;)-&amp;lt;span class=&quot;hljs-built_in&quot;&amp;gt;log10&amp;lt;/span&amp;gt;(&amp;lt;span class=&quot;hljs-built_in&quot;&amp;gt;sqrt&amp;lt;/span&amp;gt;(&amp;lt;span class=&quot;hljs-number&quot;&amp;gt;5&amp;lt;/span&amp;gt;));
        f = f+&amp;lt;span class=&quot;hljs-number&quot;&amp;gt;3&amp;lt;/span&amp;gt;-&amp;lt;span class=&quot;hljs-built_in&quot;&amp;gt;floor&amp;lt;/span&amp;gt;(f);
        &amp;lt;span class=&quot;hljs-built_in&quot;&amp;gt;printf&amp;lt;/span&amp;gt;(&amp;lt;span class=&quot;hljs-string&quot;&amp;gt;&quot;%d\n&quot;&amp;lt;/span&amp;gt;, (&amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;int&amp;lt;/span&amp;gt;)&amp;lt;span class=&quot;hljs-built_in&quot;&amp;gt;pow&amp;lt;/span&amp;gt;(&amp;lt;span class=&quot;hljs-number&quot;&amp;gt;10&amp;lt;/span&amp;gt;, f));
    }
}
&amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;hljs-number&quot;&amp;gt;0&amp;lt;/span&amp;gt;;
`&lt;/pre&gt;

}&lt;/code&gt;&lt;/pre&gt;

## Problem  I  Grasshopper

### Description

One day, the Grasshopper was jumping on the lawn and found a piece of paper with a string. Grasshopper became interested what is the minimum jump ability he should have in order to be able to reach the far end of the string, jumping only on vowels of the English alphabet. Jump ability is the maximum possible length of his jump.

Formally, consider that at the begginning the Grasshopper is located directly in front of the leftmost character of the string. His goal is to reach the position right after the rightmost character of the string. In one jump the Grasshopper could jump to the right any distance from 1 to the value of his jump ability.

![算法设计与分析Grasshopper](https://oj.ahstu.cc/JudgeOnline/upload/image/20161103/20161103005924_69817.png)

The picture corresponds to the first example.

The following letters are vowels: ‘A’, ‘E’, ‘I’, ‘O’, ‘U’ and ‘Y’.

### Input

Input contains multiple test cases.The first line contains non-empty string consisting of capital English letters. It is guaranteed that the length of the string does not exceed 100.

### Output

Print single integer a — the minimum jump ability of the Grasshopper (in the number of symbols) that is needed to overcome the given string, jumping only on vowels.

### Sample Input

&lt;pre&gt;`ABABBBACFEYUKOTT
AAA
`&lt;/pre&gt;

### Sample Output

&lt;pre&gt;`4
1
`&lt;/pre&gt;

**题解**：这道题是比较容易的一道题，主要是英语题于是大家都没有做了，思路很简单，找到一个序列中跨越元音字母（’A’, ‘E’, ‘I’, ‘O’, ‘U’, ‘Y’）的最大长度，看图例就能很好明白，直接给出代码

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;iostream&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;cstdio&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;cstring&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#include &lt;string&gt;&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;;

&lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; is(&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; c)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;] = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;A&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;E&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;I&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;O&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;U&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;Y&apos;&lt;/span&gt;};
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;; i++)
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (a[i] == c)
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;
}

&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; s[&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;];
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (~&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s&quot;&lt;/span&gt;, s))
    {
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; m = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, mx = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(s); i++) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (is(s[i])) {
                m = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
            }&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; m++;
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (mx &amp;lt; m)
                mx = m;
        }
        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;, mx);
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
}`&lt;/pre&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;`&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.Scanner;

&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt; {&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(String[] args) {
        Scanner cin = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Scanner(System.in);
        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (cin.hasNext()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;[] a = cin.next().toCharArray();
            &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; len = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, max = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;a.length; i++) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (f(a[i])) {
                    len = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
                }&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;
                    len++;
                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (len &gt; max)
                    max = len;
            }
            System.out.println(max);
        }
        cin.close();
    }

&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;private&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;boolean&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;hljs-title&quot;&amp;gt;f&amp;lt;/span&amp;gt;(&amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;char&amp;lt;/span&amp;gt; c) {
    &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;char&amp;lt;/span&amp;gt; a[] = {&amp;lt;span class=&quot;hljs-string&quot;&amp;gt;&apos;A&apos;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;hljs-string&quot;&amp;gt;&apos;E&apos;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;hljs-string&quot;&amp;gt;&apos;I&apos;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;hljs-string&quot;&amp;gt;&apos;O&apos;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;hljs-string&quot;&amp;gt;&apos;U&apos;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;hljs-string&quot;&amp;gt;&apos;Y&apos;&amp;lt;/span&amp;gt;};
    &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;for&amp;lt;/span&amp;gt; (&amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;int&amp;lt;/span&amp;gt; i=&amp;lt;span class=&quot;hljs-number&quot;&amp;gt;0&amp;lt;/span&amp;gt;; i&amp;lt;a.length; i++)
        &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;if&amp;lt;/span&amp;gt; (a[i] == c)
            &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;true&amp;lt;/span&amp;gt;;
    &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;hljs-keyword&quot;&amp;gt;false&amp;lt;/span&amp;gt;;
}
</code></pre><p>}</p>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>校赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>期末</tag>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>弱校ACM奋斗史</title>
    <url>/2016/12/12/e5-bc-b1-e6-a0-a1acm-e5-a5-8b-e6-96-97-e5-8f-b2/</url>
    <content><![CDATA[<div class="entry" style="margin: 26px 0pt 0pt; padding: 0pt; color: #4d4d4f;"><br><br><strong>看到这篇文章, 已是大三了, 我的ACM之路也即将走向终点, 感慨自己还是不够努力, 给自己的大学留下诸多遗憾. 和他们相比, 我差的就是太远了, 值得高兴的是我们学校有一个好老师—–赵靖老师, 在赵老师的高瞻远瞩下, 安科的acm事业快速发展, 愿学弟学妹要多加油, 为学校赢得更得更多的荣誉, 更多的是给自己一个挑战, 谁说弱校就不能引人夺目, 因此转载发此文与acmer共勉, 大家加油!</strong><br><br><span style="margin: 0pt; padding: 0pt;">这是一篇老文章，不过由于无法找到最初的发文地址，这里就不能粘贴原文网址了。本站转载此文与ACMer们共勉。</span><span id="more-369" style="margin: 0pt; padding: 0pt;"></span><br><br>题解：还记得2年前的一个晚上，我和一个女孩一起写完了这篇文章。写完后，她哭了，我笑了。然后，她走了，我哭了。2年后，我又找到她，这次，我没有让她走掉，她成了我的新娘。<br><br>不知道什么时候，开始知道ACM；也不知道什么时候，开始喜欢上ACM。但是，我知道，我喜欢上了，而且不会后悔。我是大一的时候进的学校ACM队，那个时候，一切都是冰冷的，华东理工大学，在别人的眼里，只是每次给别人垫底的学校，次次如此。<br>但是，我们不甘心，我们从不甘心，当我们主力队员中的一个，一个月拼命集训，瘦了很多的时候，突然，我有一种哭的冲动。我问他，为什么？他告诉我：我喜欢ACM。也许是个傻傻的理由，但是就是这句话让我一直留在了这里，并且为了这个梦奋斗着。<br>也许是天资的原因，第一次，我们失败了，彻底的失败了，在上海输的好惨，也使得我们第二年的经费雪上加霜。曾经的梦想，曾经的努力，似乎在一刹那间被否定了。也就在那个时候，有人说了一句：我们只有大一，我们的路还长，于是，我就坚持了下来。<br>现在看看大一时候的我们，真的是什么都不会的一些人。<br>到了大二，我们更加努力的集训，在北京之前，我们第一次尝试了全天集训的滋味。30天90袋跑面20袋咸菜，每天4个小时的睡眠。当时我觉得我们一定会崩溃的，当我每次快要崩溃的时候，总会记起当时我们的话：“我们才大一，我们喜欢ACM，我们还有的拼，我们能拼。”于是，就奇迹一样的继续做题。<br>现在想起来，那真的是个奇迹，LIANG HH居然可以一个月只在床上躺了6个晚上，平均每天睡2个小时。<br>就这样，我们在北京的时候，绝对意外的拿了第5名的成绩，当时的感觉绝对不是语言可以形容的，当时只是在想：我们终于证明自己了。<br>但是，这也是要代价的，LIANGHH回来就垮了，其他的人也不是很好受。但是，队长还是决定了去印度拼一下。决定的结果是：继续集训。那些日子我不愿意再回忆，也不愿意再来一次，但是，如果我必须要再来一次的话，我相信，我不会犹豫，因为：我喜欢ACM。<br>在印度的出现绝对不是一个奇迹，也不是运气，里面包含了苦涩，无奈，还有很多很多，当然最多的还是欣喜。<br>至于总决赛么，呵呵，就是去玩玩，也没有别的意思了。<br>我真的希望<br>大家加油！！！<br><a id="more"></a><br>不是因为别的原因，因为我们都曾经迷惑，无助，我们没有别人那么强的教练，没有别人那么好的基础，但是，我们都绝对不能放弃。绝对不能，因为，当我们坐在赛场上的时候，不管你是不是愿意，在你上空飘动的始终是你的校旗，别误会，我不是说什么要“为了学校争光”，那种话是用来哄小孩子的。我只想问大家，如果是你，坐在电脑前<del>，你的背后有多少人在看着你？你的身上寄托的是什么？<br>是希望，是所有喜欢ACM的同学对你的希望，希望有这么一天，ACM也可以象其他的东西一样被其他的人所肯定，而不是什么需要被人怜悯的东西！！！！！！！！！<br>是信任，是所有曾经帮助过你和被你帮助过你的人对你的信任，想想为了经费而受尽了苦的人们，想想其他曾经一起集训的队员们的信任。他们信任你，你们会是最好的。只要你们尽力了，你们就是英雄。不过，没有人同情失败的英雄吧。所以，我们必须成功。<br>还有，是耻辱，是一种被轻视和忽视的耻辱，不知道你们有没有这样的经历，当初我们想找一个比我们水平高的学校共同学习一下，谁知道竟然换来的是一句：“就你们？”也许你们没有遇到过想我们一样尴尬的场面，不过，我相信，这种感觉在你们心里也很深刻吧。从很多地方都能体会到。<br><br>如果，现在我们寄托了这些东西的话，谁还会告诉我：我们不该奋斗呢？<br>如果可以，我宁愿安静的呆在一个不为人知的小角落，平平淡淡的过了这大学四年的生活，至少不会这么累。<br>如果可以，我宁愿在开始的时候，就找一个可以依靠的地方，傻傻的什么都不想，幸福的过了这四年。<br>如果可以，我宁愿只做一个ACM的看客，静静的品味他们成功的喜悦，分担失败的痛苦。<br><br>如果可以，我宁愿早早的放弃着艰苦的训练，因为我实在不愿意再做这样一个噩梦。<br>如果、可以…………<br>但是，只是如果……<br>而且，决不可以！！<br>当我们弱校的人喜欢上ACM的时候，就应该有这种觉悟！<br>如果，要后退，那么，就你就不要参加ACM，因为，你不适合。ACM比的并不仅仅是写程序的水平，而更多是三个人的综合素质。没有胆小的人可以赢得ACM的青睐，没有退缩的人可以赢得比赛的胜利。我们这些人，水平本来就有限，也没有什么很出色专业教练。那么如果我们连一拼的勇气都没有了。我们还剩下什么？<br>如果可以，让我再次站在大一时候的海报前，我还是会小声的说：“去试试吧，也许很好玩呢</del>”<br>谢谢大家看了这么多，是不是烦了？呵呵，最后，我只希望大家能+U，同时弱校的队员，<br><br>我希望我们能互相帮助。<br>大家<del>~</del><del>~加油</del><del>~</del>~~<br><br><div class="ujian-hook" style="margin: 0pt; padding: 0pt;"></div><br><div style="margin: 0pt; padding: 0pt; clear: both;"></div><br><div class="clear" style="margin: 0pt; padding: 0pt; clear: both; visibility: hidden;"></div><br></div>
]]></content>
      <categories>
        <category>网摘</category>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>绝对值最小</title>
    <url>/2015/04/22/e7-bb-9d-e5-af-b9-e5-80-bc-e6-9c-80-e5-b0-8f/</url>
    <content><![CDATA[<h2 id="绝对值最小"><a href="#绝对值最小" class="headerlink" title="绝对值最小"></a>绝对值最小</h2><h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情:"></a>题目详情:</h2><p><span class="her_c_con"></span><br><span style="line-height:1.5">给你一个数组A[n],请你计算出ans=min(|A[i]+A[j]|)(0&lt;=i,j&lt;n). &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p>
<div class="her_format_right"><br><br></div>

<p>例如：A={1， 4， -3}，</p>
<p>则：</p>
<p>|A[0] + A[0]| = |1 + 1| = 2.</p>
<p>|A[0] + A[1]| = |1 + 4| = 5.</p>
<p>|A[0] + A[2]| = |1 + (-3)| = 2.</p>
<p>|A[1] + A[1]| = |4 + 4| = 8.</p>
<p>|A[1] + A[2]| = |4 + (-3)| = 1.</p>
<p>|A[2] + A[2]| = |(-3) + (-3)| = 6.</p>
<p>所以ans=1.</p>
<p>输入描述：</p>
<p>有多组测数数据，每组数据有两行，第一行包含一个正整数n(0&lt;n&lt;=100000),第二行包含n个整数，分别表示A[0],A[1]，A[2],….,A[n-1]，（|A[i]|&lt;2^30）。</p>
<p>输入以文件结束。</p>
<p>输出描述：</p>
<p>对于每组数据，输出相应的答案。</p>
<h2 id="答题说明"><a href="#答题说明" class="headerlink" title="答题说明:"></a>答题说明:</h2><p>输入样例：</p>
<p>3</p>
<p>1 4 -3</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>-1 -2 -5</p>
<p>3</p>
<p>1 2 3</p>
<p>2</p>
<p>0 5<br><a id="more"></a><br>输出样例：</p>
<p>1</p>
<p>4</p>
<p>2</p>
<p>2</p>
<p>0</p>
<p><span style="line-height:1.5"></span></p>
<div class="her_format_right"><br><br>### 发布公司:<br><br><a href="http://hero.csdn.net/OnlineCompiler/Index?ID=587&amp;ExamID=582&amp;ExamResultID=239327&amp;ExamNum=2&amp;random=7194225&amp;from=211&amp;PaperID=0" target="_blank" rel="noopener"><img src="http://hire.job.csdn.net/image/AttachFile?fileid=38411" alt="CSDN" title="CSDN"></a><br><div class="her_baid">CSDN</div><br><div class="her_nddj"><br><div class="her_xxfl">难度等级:</div><br><span title="一般"><img src="http://image.job.csdn.net/www/star_on.png" alt><img src="http://image.job.csdn.net/www/star_on.png" alt><img src="http://image.job.csdn.net/www/star_on.png" alt><img src="http://image.job.csdn.net/www/star_of.png" alt><img src="http://image.job.csdn.net/www/star_of.png" alt><br></span></div><br><div class="her_duiqi">答题时长: <span class="juhuang">120 分钟</span> </div><br><div class="her_yuyan">编程语言要求: <span class="juhuang">C C++ Java C#<br><br></span></div><br></div>

<p><span style="font-size:18px; color:#FF0000">此题由本人AC，不规范之处，有更好的解题思路</span></p>
<p><span style="font-size:18px; color:#FF0000">还请大家多多指教，谢谢！</span></p>
<p><span style="font-size:18px; color:#FF0000">有任何问题请联系<a href="mailto:fjinhao@qq.com" target="_blank" rel="noopener">fjinhao@qq.com</a></span></p>
<p>下面附上代码</p>
<p></p><p></p>
<pre name="code" class="cpp">#include <stdio.h>
#include <math.h>
#define N 100000

int absm(int *p,int n)
{
    int i, j, min = -1,q = 0;
    for ( i=0; i<n; ++i ) { for ( j="i;" j<n; ++j q="abs(p[i]" + p[j]); if (min> q || min == -1) {
                min = q;
             }
        }
    }
    return min;
}
int main()
{
    int n, a[N],i,min;
    while ( 1 == scanf("%d", &n))
    {
        for ( i=0; i<n; ++i ) { scanf("%d",&a[i]); } min="absm(a,n);" printf("%d\n",min); return 0; }< pre>
</n;></n;></math.h></stdio.h></pre>]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集详解（转）</title>
    <url>/2017/07/03/e5-b9-b6-e6-9f-a5-e9-9b-86-e8-af-a6-e8-a7-a3-ef-bc-88-e8-bd-ac-ef-bc-89/</url>
    <content><![CDATA[<div id="article_content" class="article_content tracking-ad" style="margin:35px 0px; line-height:35px"><br><br><span style="font-family:Arial,宋体; font-size:18px">很好的一篇文章</span><br><br><span style="font-family:Arial,宋体; font-size:18px"><a href="http://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="noopener">原文链接</a></span><br><br><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">并查集是我暑假从高手那里学到的一招，觉得真是太精妙的设计了。以前我无法解决的一类问题竟然可以用如此简单高效的方法搞定。不分享出来真是对不起party了。（party：我靠，关我嘛事啊？我跟你很熟么？）</span></span></span><br><br><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">来看一个实例，<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">HDU1232畅通工程</a><br><br></span></span></span><br><br><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路……</span></span></span><br><a id="more"></a><br><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">以下面这组数据输入数据来说明</span></span></span><br><br><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">4 2 1 3 4 3</span></span></span><br><br><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">第一行告诉你，一共有4个点，2条路。下面两行告诉你，1、3之间有条路，4、3之间有条路。那么整幅图就被分成了1-3-4和2两部分。只要再加一条路，把2和其他任意一个点连起来，畅通工程就实现了，那么这个这组数据的输出结果就是1。好了，现在编程实现这个功能吧，城镇有几百个，路有不知道多少条，而且可能有回路。<br> 这可如何是好？</span></span></span><br><br><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">我以前也不会呀，自从用了并查集之后，嗨，效果还真好！我们全家都用它！</span></span></span><br><br><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。</span></span></span><br><br><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px"></span></span></span><br><br>&lt;div class=”dp-highlighter bg_cpp” style=”color:rgb(85,85,85); font-family:Consolas,”Courier New”,Courier,mono,serif; background-color:rgb(231,229,220); width:924.656px; overflow:hidden; padding-top:1px; position:relative; border-color:rgb(204,204,204); margin:18px 0px!important”&gt;<br><div class="bar" style="padding-left:45px"><br><div class="tools" style="padding:3px 8px 10px 10px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left:3px solid rgb(108,226,108)"><br><span style="font-size:18px"><strong>[cpp]</strong>&nbsp;<a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="view plain" target="_blank" rel="noopener">view<br> plain</a><span>&nbsp;<a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="copy" target="_blank" rel="noopener">copy</a></span></span><br><div style="position:absolute; left:479px; top:949px; width:18px; height:18px; z-index:99"><br></div><br><span style="font-size:18px"><span></span></span></div><br></div>

<ol>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px"><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;pre[1000&nbsp;];&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px"><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;find(</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//查找根节点</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">{&nbsp;&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;r=x;&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">while</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;(&nbsp;pre[r]&nbsp;!=&nbsp;r&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//返回根节点&nbsp;r</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=pre[r];&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;i=x&nbsp;,&nbsp;j&nbsp;;&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">while</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(&nbsp;i&nbsp;!=&nbsp;r&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//路径压缩</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;pre[&nbsp;i&nbsp;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//&nbsp;在改变上级之前用临时变量&nbsp;&nbsp;j&nbsp;记录下他的值&nbsp;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pre[&nbsp;i&nbsp;]=&nbsp;r&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//把上级改为根节点</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=j;&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">return</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;r&nbsp;;&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">}&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;</span></span><br></li></ol></div><br><span style="font-size:18px">

<p></p></span><p></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px"></span></span></span></p>
&lt;div class=”dp-highlighter bg_cpp” style=”color:rgb(85,85,85); font-family:Consolas,”Courier New”,Courier,mono,serif; background-color:rgb(231,229,220); width:924.656px; overflow:hidden; padding-top:1px; position:relative; border-color:rgb(204,204,204); margin:18px 0px!important”&gt;<br><div class="bar" style="padding-left:45px"><br><div class="tools" style="padding:3px 8px 10px 10px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left:3px solid rgb(108,226,108)"><br><span style="font-size:18px"><strong>[cpp]</strong>&nbsp;<a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="view plain" target="_blank" rel="noopener">view<br> plain</a><span>&nbsp;<a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="copy" target="_blank" rel="noopener">copy</a></span></span><br><div style="position:absolute; left:479px; top:1359px; width:18px; height:18px; z-index:99"><br></div><br><span style="font-size:18px"><span></span></span></div><br></div>

<ol>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px"><span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">void</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;join(</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;x,</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//判断x&nbsp;y是否连通，</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//如果已经连通，就不用管了&nbsp;如果不连通，就把它们所在的连通分支合并起,</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">{&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;fx=find(x),fy=find(y);&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">if</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(fx!=fy)&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pre[fx&nbsp;]=fy;&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">}&nbsp;&nbsp;</span></span><br><br><span style="font-size:18px"></span></li>
</ol>
<p></p>
<p><span style="font-size:18px"><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"></span></span>&nbsp;</span></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">为了解释并查集的原理，我将举一个更有爱的例子。 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</span></span></span></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</span></span></span></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</span></span></span></p>
<p><span style="font-size:18px"><img src="http://hi.csdn.net/attachment/201107/29/0_1311901712oy9f.gif" alt></span></p>
<p><span style="font-size:18px"><span style="font-family:宋体; color:rgb(174,180,118)"></span></span></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。<br> find这个函数就是找掌门用的，意义再清楚不过了（路径压缩<a href="http://lib.csdn.net/base/datastructure" title="算法与数据结构知识库" target="_blank" rel="noopener">算法</a>先不论，后面再说）。</span></span></span></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px"></span></span></span></p>
&lt;div class=”dp-highlighter bg_cpp” style=”color:rgb(85,85,85); font-family:Consolas,”Courier New”,Courier,mono,serif; background-color:rgb(231,229,220); width:924.656px; overflow:hidden; padding-top:1px; position:relative; border-color:rgb(204,204,204); margin:18px 0px!important”&gt;<br><div class="bar" style="padding-left:45px"><br><div class="tools" style="padding:3px 8px 10px 10px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left:3px solid rgb(108,226,108)"><br><span style="font-size:18px"><strong>[cpp]</strong>&nbsp;<a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="view plain" target="_blank" rel="noopener">view<br> plain</a><span>&nbsp;<a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="copy" target="_blank" rel="noopener">copy</a></span></span><br><div style="position:absolute; left:479px; top:2634px; width:18px; height:18px; z-index:99"><br></div><br><span style="font-size:18px"><span></span></span></div><br></div>

<ol>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px"><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;find(</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//查找我（x）的掌门</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">{&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;r=x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//委托&nbsp;r&nbsp;去找掌门</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">while</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;(pre[r&nbsp;]!=r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门&nbsp;=&nbsp;=）</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;r=pre[r&nbsp;]&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//&nbsp;r&nbsp;就接着找他的上级，直到找到掌门为止。</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">return</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;r&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//掌门驾到~~~</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">}&nbsp;&nbsp;</span></span><br><br><span style="font-size:18px"></span></li>
</ol>
<p></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？</span></span></span></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px"></span></span></span></p>
&lt;div class=”dp-highlighter bg_cpp” style=”color:rgb(85,85,85); font-family:Consolas,”Courier New”,Courier,mono,serif; background-color:rgb(231,229,220); width:924.656px; overflow:hidden; padding-top:1px; position:relative; border-color:rgb(204,204,204); margin:18px 0px!important”&gt;<br><div class="bar" style="padding-left:45px"><br><div class="tools" style="padding:3px 8px 10px 10px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left:3px solid rgb(108,226,108)"><br><span style="font-size:18px"><strong>[cpp]</strong>&nbsp;<a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="view plain" target="_blank" rel="noopener">view<br> plain</a><span>&nbsp;<a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="copy" target="_blank" rel="noopener">copy</a></span></span><br><div style="position:absolute; left:479px; top:3144px; width:18px; height:18px; z-index:99"><br></div><br><span style="font-size:18px"><span></span></span></div><br></div>

<ol>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px"><span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">void</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;join(</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;x,</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//我想让虚竹和周芷若做朋友</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">{&nbsp;&nbsp;</span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;fx=find(x),fy=find(y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">if</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(fx!=fy)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//玄慈和灭绝显然不是同一个人</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;pre[fx&nbsp;]=fy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//方丈只好委委屈屈地当了师太的手下啦</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></span></li>
<li><span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span style="font-size:18px">}&nbsp;&nbsp;</span></span><br><br><span style="font-size:18px"></span></li>
</ol>
<p></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px">再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。<br> 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。”<br> “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。</span></span></span></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-family:Arial,宋体; color:rgb(0,0,0)"><span style="font-size:18px"></span></span></span></p>
<p></p>
<p><span style="font-family:宋体; color:rgb(174,180,118)"><span style="font-size:18px"><img src="http://hi.csdn.net/attachment/201107/29/0_131190167189S8.gif" alt></span></span></p>
<p></p>
&lt;div class=”bdsharebuttonbox tracking-ad bdshare-button-style0-16” style=”zoom:1; font-family:”microsoft yahei”; float:right”&gt;<br><a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" target="_blank" rel="noopener"></a><a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="分享到QQ空间" target="_blank" rel="noopener"></a><a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="分享到新浪微博" target="_blank" rel="noopener"></a><a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="分享到腾讯微博" target="_blank" rel="noopener"></a><a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="分享到人人网" target="_blank" rel="noopener"></a><a href="http://blog.csdn.net/liujian20150808/article/details/50848646#" title="分享到微信" target="_blank" rel="noopener"></a>

&lt;div id=”digg” style=”text-align:center; margin-top:44px; font-family:”microsoft yahei””&gt;<br><span style="font-size:18px"></span><br><dl id="btnDigg" class="digg digg_enable" style="display:inline-block; width:72px; color:rgb(255,255,255); margin:0px; vertical-align:middle; padding:7px 0px; background:rgb(255,153,0)"><br></dl><br>
]]></content>
      <categories>
        <category>并查集</category>
        <category>算法学习</category>
        <category>网摘</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo(next主题) + gitment评论系统搭建的一些问题</title>
    <url>/2017/08/06/gitment-issue/</url>
    <content><![CDATA[<h2 id="hexo-next主题-gitment评论系统搭建的一些问题"><a href="#hexo-next主题-gitment评论系统搭建的一些问题" class="headerlink" title="hexo(next主题) + gitment评论系统搭建的一些问题"></a>hexo(next主题) + gitment评论系统搭建的一些问题</h2><ul>
<li>最近在转移我的博客，想从以前的csdn和wordpress的博客转移到hexo, hexo 比较精简，也不需要购买服务器完全足够个人博客的搭建，因此开始转移<br>在搭建时遇到很多问题<a id="more"></a></li>
<li>这次在评论系统的搭建时遇到不少坑，一开始准备使用以前用过的多说，结果网站已经挂了，准备用disqus,结果又因为墙的问题，又转移到了畅言，但是感觉还是不够精简，与博客不搭，偶然遇到了gitment这的系统，感觉不错，够简洁，而且支持markdown语法，只是只能是github用户登录评论有些坑，但是出于折腾的心还是开始了</li>
</ul>
<hr>
<p><strong>本文采用的是hexo博客系统+next主题</strong></p>
<blockquote>
<p>步骤参考<br><a href="https://www.juhe.cn/news/index/id/1852" target="_blank" rel="noopener">https://www.juhe.cn/news/index/id/1852</a></p>
</blockquote>
<p>但是再搭建的时候还是有一些莫名奇妙的错误，<br>首先是</p>
<ul>
<li>按步骤做了但是还是没有评论框，结果最后发现是_config.yml文件的问题<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: Finhoo</span><br><span class="line">  repo: Finhoo.github.io</span><br><span class="line">  ClientID: xxxxxxxx</span><br><span class="line">  ClientSecret: xxxxxxxx</span><br><span class="line">  lazy: false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里的代码是复制的结果没有缩进，结果后面发现几个问题都是大同小异</p>
<ul>
<li>还有就是有评论框但是Not Found问题，找了很久也是没有找到，最后发现是comments.swig文件中的变量定义部分也是没有缩进</li>
</ul>
<p>好了，费了好大劲，终于好了</p>
<hr>
<p>update by fayne at 2018-3-30 23:18:56<br>详细配置见gitment评论，可以参考配置</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitment</tag>
        <tag>hexo-next</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>优化hexo访问速度-将hexo部署到云主机VPS</title>
    <url>/2017/08/11/hexo-aliyun/</url>
    <content><![CDATA[<h3 id="写在开始"><a href="#写在开始" class="headerlink" title="写在开始"></a>写在开始</h3><p>一开始将自己<code>hexo</code>部署到<code>github</code>，结果发现打开页面速度有点慢，然后又将其同时部署到<code>coding</code>,实现双线路访问，国内解析记录到<code>coding</code>，国外解析到<code>github</code>，这样确实网站的速度能提高不少，但是国内访问因为是经过<code>coding</code>，所以打开网站会有广告，这点不能容忍，于是想到自己的服务器也还空闲着，于是想到可以部署到自己的服务器上，折腾开始<br><a id="more"></a><br><a href="http://www.fayne.cn">演示站点</a></p>
<h3 id="部署总览"><a href="#部署总览" class="headerlink" title="部署总览"></a>部署总览</h3><ul>
<li>个人使用的环境<ul>
<li>本地环境： <code>Windows10</code>(64位)</li>
<li>云主机：阿里云ECS(<code>CentOS</code> 7.2 64位)</li>
</ul>
</li>
<li>整个部署过程<ul>
<li>本地环境搭建（<code>git</code>，<code>NodeJs</code>，<code>hexo</code>..）</li>
<li>云主机环境搭建（<code>git</code>，<code>Nginx</code>）</li>
<li>设置解析（<code>dnspod</code>）</li>
<li>使用git自动化部署博客</li>
</ul>
</li>
</ul>
<h3 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建</h3><ul>
<li>安装git</li>
<li>安装hexo(这些步骤省略）</li>
<li>生成ssh公钥（之前生成过的也就不用再执行了，比如部署在github上填写过rsa密钥就不需要再进行这一步了）<ul>
<li>在命令行终端执行如下命令<br><code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></li>
<li>生成的文件默认在<code>~/.ssh</code>目录中，看到有<code>id_rsa</code>，<code>id_rsa.pub</code>这些文件即可</li>
</ul>
</li>
</ul>
<h3 id="云主机环境搭建"><a href="#云主机环境搭建" class="headerlink" title="云主机环境搭建"></a>云主机环境搭建</h3><ul>
<li><p>安装git及nodejs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install git</span><br><span class="line"><span class="comment">#安装NodeJS</span></span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_5.x | bash -</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建git账户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser git</span><br><span class="line">chmod 740 /etc/sudoers</span><br><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure>
<ul>
<li><p>添加内容<br>找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加以下内容</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存退出并改回权限</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置git账户密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>切换至<code>git</code>用户，创建 <code>~/.ssh</code> 文件夹和 <code>~/.ssh/authorized_keys</code> 文件，并赋予相应的权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line">vim ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment">#然后将本地电脑中执行 cat ~/.ssh/id_rsa.pub | pbcopy ,将公钥复制粘贴到</span></span><br><span class="line">authorized_keys</span><br><span class="line">chmod 600 ~/.ssh/authorzied_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure>
<ul>
<li>在本地终端中测试是否能免密登录<code>git</code><br><code>ssh -v git@SERVER</code></li>
<li>其中<code>SERVER</code>为填写自己的云主机<code>IP</code></li>
</ul>
</li>
<li><p>创建目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># repo 作为为git仓库目录</span></span><br><span class="line">mkdir -R /var/repo</span><br><span class="line"><span class="comment"># hexo 作为网站根目录</span></span><br><span class="line">mkdir -R /var/www/hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置<code>nginx</code>（当然<code>Apache</code>也是可以的，<code>nginx</code>的安装步骤省略）</p>
<ul>
<li>首先输入<code>ngixn -t</code>找到配置文件，我的是在<code>/etc/nginx/nginx.conf</code>，配置<code>SERVER</code></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        <span class="comment"># server_name 填写自己的域名</span></span><br><span class="line">        server_name  www.fayne.cn;</span><br><span class="line">        <span class="comment"># 这里root填写自己的网站根目录</span></span><br><span class="line">        root         /var/www/hexo;</span><br><span class="line">        index index.html index.php index.htm;</span><br><span class="line">        <span class="comment">#/usr/local/tomcat/webapps/Forum</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line">         location / &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置解析"><a href="#设置解析" class="headerlink" title="设置解析"></a>设置解析</h3><ul>
<li>在<code>dnspod</code>设置解析记录，设置解析<code>A</code>记录<code>www</code>解析到服务器<code>IP地址</code>, 解析线路默认</li>
<li>设置<code>CNAME</code>解析使<code>www</code>解析到<code>xxx.github.io</code>，解析线路国外，这里的<code>xxx</code>为<code>hexo</code>部署在<code>github</code>的仓库名称，这样保证了在国外访问速度也是极佳的</li>
</ul>
<h3 id="使用git自动化部署博客"><a href="#使用git自动化部署博客" class="headerlink" title="使用git自动化部署博客"></a>使用<code>git</code>自动化部署博客</h3><p>自动化部署主要用到了<code>git</code>-<code>hooks</code>同步</p>
<ul>
<li><p>服务器建立裸库，这里要用<code>git</code>用户登录，确保<code>git</code>用户拥有仓库所有权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">cd /var/repo/</span><br><span class="line">git init --bare blog.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 git-hooks 同步网站根目录<br>在这里我们使用的是 <code>post-update</code>这个钩子（也有可能是<code>post-receive</code>，具体进入文件就知道了），当git有收发的时候就会调用这个钩子。 在 <code>/var/repo/blog.git</code> 裸库的 <code>hooks</code>文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /var/repo/blog.git/hooks/post-update</span><br><span class="line"># 编辑文件，写入以下内容</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout -f</span><br></pre></td></tr></table></figure>
<p> 保存后，要赋予这个文件可执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x post-update</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置<code>_config.yml</code>,完成自动化部署<br>打开<code>_config.yml</code>, 找到<code>deploy</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:Finhoo/Finhoo.github.io.git</span><br><span class="line">    www: git@www.fayne.cn:/var/repo/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>保存后，即可测试部署</p>
<pre><code>hexo clean &amp;&amp; hexo g -d
</code></pre></li>
<li>至此，我们已经成功部完成，并且访问自己的服务器端比访问<code>github</code>快多了，国外速度也是很好</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>我在部署过程中，执行 <code>hexo d</code>发现部署老是出错，什么权限不允许之类的，这里我们需要检查我们在上述的git操作部署是否使用了<code>git</code>用户操作，若是没有，需要给相应的目录更改用户组<br>使用<code>chown -R git:git /var/repo/</code>这条命令递归的将<code>repo</code>目录及其子目录用户组设置为<code>git</code>，同时<code>chown -R git:git /var/www/hexo</code>，这样即可解决此类问题</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://segmentfault.com/a/1190000005723321" target="_blank" rel="noopener">阿里云VPS搭建自己的的Hexo博客</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>github</tag>
        <tag>nginx</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>[置顶]        2017“久源软件杯”安徽科技学院第八届程序设计大赛 - 题解</title>
    <url>/2017/04/23/e7-bd-ae-e9-a1-b6-2017-e4-b9-85-e6-ba-90-e8-bd-af-e4-bb-b6-e6-9d-af-e5-ae-89-e5-be-bd-e7-a7-91-e6-8a-80-e5-ad-a6-e9-99-a2-e7-ac-ac-e5-85-ab-e5-b1-8a-e7-a8-8b-e5-ba-8f/</url>
    <content><![CDATA[<div><br><br>### Contest1068 - 2017“久源软件杯”安徽科技学院第八届程序设计大赛<br><br><div><br><br>关于举办“久源软件杯”<br><br>安徽科技学院第八届程序设计大赛通知<br><br></div><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ACM&nbsp;国际大学生程序设计竞赛&nbsp;(International Collegiate Programming Contest）是由美国计算机协会（ACM）主办的一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的著名竞赛。2010年以来，我校参与了历届安徽省&nbsp;ACM&nbsp;程序设计竞赛，并取得了优异的成绩。为选拔省ACM&nbsp;参赛队员，特举办“久源软件杯”&nbsp;安徽科技学院第八届计算机程序设计大赛，热忱欢迎广大程序设计爱好者踊跃参加。<br><br>&nbsp;<br><br><strong>主办方：</strong>安徽科技学院教务处、信息与网络工程学院<br><br><strong>承办方：</strong>信息与网络工程学院计算机系<br><br><strong>赞助方：</strong>无锡久源软件股份有限公司（独家赞助）<br><br>&nbsp;<br><br>一、&nbsp;比赛时间：<strong>2017&nbsp;年&nbsp;4&nbsp;月&nbsp;22（周六）上午&nbsp;8:00～12:00</strong><br><br>二、比赛地点：计算机与网络实验中心（力行楼六楼）<br><br>三、参赛对象：14～16&nbsp;级计算机、网络、信息、电子等专业<br><br>四、&nbsp;报名方式（免费报名参赛）：<br><br>（1）报名网站：&nbsp;<a href="https://oj.ahstu.cc/JudgeOnline/contest_join.php?cid=1068" target="_blank" rel="noopener">https://oj.ahstu.cc/JudgeOnline/contest_join.php?cid=1068</a><br><br>（2）请加入比赛&nbsp;QQ&nbsp;群：391668336（安科ACM官方群）<br><br>（3）&nbsp;报名时间：2017&nbsp;年&nbsp;4&nbsp;月&nbsp;10日至&nbsp;4月&nbsp;21&nbsp;日<br><br>五、比赛设奖：设一等奖8%、二等奖12%、三等奖15%、优秀奖若干<br><br>（1）一二三等奖都有丰厚的物质奖励<br><br>（2）一二等奖同学直接进入省ACM赛集训<br><br>六、竞赛相关：<br><a id="more"></a><br>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;竞赛语言：C/C++/JAVA环境：DevCpp /CodeBlock /Eclipse<br><br>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比赛试题：采用&nbsp;ICPC&nbsp;样式——赛题&nbsp;8～10&nbsp;道<br><br>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;练习与比赛网站（AOJ）：<a href="https://oj.ahstu.cc/" target="_blank" rel="noopener">https://oj.ahstu.cc/</a><br><br>&nbsp;<br><br>相关竞赛辅导将随后展开，请关注群通知。<br><br>&nbsp;<br><br>教务处、信息与网络工程学院<br><br>2017&nbsp;年&nbsp;4月&nbsp;11&nbsp;日<br><br><div style="text-align:center"><br><br></div><br><div style="text-align:center">Start Time:&nbsp;<span style="color:rgb(153,51,153)">2017-04-22 08:00:00</span>&nbsp;End Time:&nbsp;<span style="color:rgb(153,51,153)">2017-04-22 12:00:00</span></div><br><div style="text-align:center">Current Time:&nbsp;<span style="color:rgb(153,51,153)">2017-4-22 22:28:34</span>&nbsp;Status:<span style="color:red">Ended</span>&nbsp;&nbsp;&nbsp;<span style="color:blue">Public&nbsp;</span></div><br><span style="color:blue"></span><br><div style="text-align:center">[<a href="https://oj.ahstu.cc/JudgeOnline/status.php?cid=1068" target="_blank" rel="noopener">Status</a>] [<a href="https://oj.ahstu.cc/JudgeOnline/contestrank.php?cid=1068" target="_blank" rel="noopener">Standing</a>]<br> [<a href="https://oj.ahstu.cc/JudgeOnline/conteststatistics.php?cid=1068" target="_blank" rel="noopener">Statistics</a>]</div><br></div>

<p><span style="font-size:14px"></span></p>
<div style="text-align:center"><br>&lt;div style=”font-family:”Helvetica Neue”,Helvetica,Arial,sans-serif; font-size:14px”&gt;<br><span class="blue" style="color:blue">[<a href="https://oj.ahstu.cc/JudgeOnline/status.php?cid=1068" target="_blank" rel="noopener">Status</a>] [<a href="https://oj.ahstu.cc/JudgeOnline/contestrank.php?cid=1068" target="_blank" rel="noopener">Standing</a>]<br> [<a href="https://oj.ahstu.cc/JudgeOnline/conteststatistics.php?cid=1068" target="_blank" rel="noopener">Statistics</a>]</span></div><br>&lt;table id=”problemset” width=”90%” style=”text-align:center; border-collapse:collapse; width:1158px; margin-left:83.7969px; font-family:”Helvetica Neue”,Helvetica,Arial,sans-serif”&gt;<br><thead><br><tr align="center" class="toprow" style="color:rgb(25,8,8); font-weight:bold; white-space:nowrap; background:rgb(81,81,81)"><br><td width="5" style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>&nbsp;</td><br><td width="10%" style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a target="_blank" style="font-family:Arial; font-size:18px; margin:15px">Problem ID</a></td><br><td width="60%" style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a target="_blank" style="font-family:Arial; font-size:18px; margin:15px">Title</a></td><br><td width="10%" style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a target="_blank" style="font-family:Arial; font-size:18px; margin:15px">Source</a></td><br><td width="5%" style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a target="_blank" style="font-family:Arial; font-size:18px; margin:15px">AC</a></td><br><td width="5%" style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a target="_blank" style="font-family:Arial; font-size:18px; margin:15px">Submit</a></td><br></tr><br></thead><br><tbody><br><tr class="evenrow" style="background:rgb(249,249,249); white-space:nowrap"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><span style="color:red">N</span></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1847 Problem &nbsp;A</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1847" target="_blank" rel="noopener">A -bits</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>2</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>48</td><br></tr><br><tr class="oddrow" style="white-space:nowrap"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><span style="color:green">Y</span></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1848 Problem &nbsp;B</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1848" target="_blank" rel="noopener">B-黄金矿工</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>4</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>16</td><br></tr><br><tr class="evenrow" style="background:rgb(249,249,249); white-space:nowrap"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>&nbsp;</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1849 Problem &nbsp;C</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1849" target="_blank" rel="noopener">C-皇后的争斗</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>3</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>5</td><br></tr><br><tr class="oddrow" style="white-space:nowrap; background-color:rgb(228,240,248)"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>&nbsp;</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1850 Problem &nbsp;D</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1850" target="_blank" rel="noopener">D-纸盘游戏</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>4</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>48</td><br></tr><br><tr class="evenrow" style="background:rgb(249,249,249); white-space:nowrap"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><span style="color:red">N</span></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1851 Problem &nbsp;E</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1851" target="_blank" rel="noopener">E-平均数</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>2</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>117</td><br></tr><br><tr class="oddrow" style="white-space:nowrap"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><span style="color:green">Y</span></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1852 Problem &nbsp;F</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1852" target="_blank" rel="noopener">F-刹车</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>99</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>156</td><br></tr><br><tr class="evenrow" style="background:rgb(249,249,249); white-space:nowrap"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>&nbsp;</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1853 Problem &nbsp;G</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1853" target="_blank" rel="noopener">G-圆组</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>2</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>35</td><br></tr><br><tr class="oddrow" style="white-space:nowrap"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><span style="color:green">Y</span></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1854 Problem &nbsp;H</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1854" target="_blank" rel="noopener">H-曲线长度</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>34</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>56</td><br></tr><br><tr class="evenrow" style="background:rgb(249,249,249); white-space:nowrap"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><span style="color:green">Y</span></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1855 Problem &nbsp;I</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1855" target="_blank" rel="noopener">I-相交点</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>63</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>70</td><br></tr><br><tr class="oddrow" style="white-space:nowrap"><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><span style="color:green">Y</span></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>1856 Problem &nbsp;J</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1856" target="_blank" rel="noopener">J-老赵的挑逗</a></td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>icpc08th</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>45</td><br><td style="padding:3px 10px; border:1px solid rgb(221,221,221); line-height:1.42857"><br>159</td><br></tr><br></tbody><br><br><div style="text-align:left"><br><br></div><br>

<p><span style="color:#ff0000"></span></p>
<p></p>
<center><br><br><div><br><br>## 1847: A -bits<br><br><span style="color:green">Time Limit:&nbsp;</span><span style="color:#ff0000">1 Sec&nbsp;&nbsp;</span><span style="color:green">Memory Limit:&nbsp;</span><span style="color:#ff0000">128 MB</span><br><br><span style="color:green">Submit:&nbsp;</span><span style="color:#ff0000">48&nbsp;&nbsp;</span><span style="color:green">Solved:&nbsp;</span><span style="color:#ff0000">2</span><br><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1846" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1847" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1847" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1847" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1847&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1848" target="_blank" rel="noopener">下一题</a></div><br><br></center>

<div><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>定义F(n)为n的二进制表示中，“连续两个1出现的次数”例如&nbsp;F(27)=2（27的二进制位11011）输入整数n（0&lt;=n&lt;=2<sup>63&nbsp;</sup>-2）求S&nbsp;= F(0)+F(1)+…+F(n)的值<br><br></div>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>多组输入，每行输入n，当n=-1时结束输入<br><br></div>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>输出每行输入对应的S值<br><br></div>

<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(51,51,51)">0615202122-1</div>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><div style="color:rgb(51,51,51)">Case 1: 0</div><br><div style="color:rgb(51,51,51)">Case 2: 2</div><br><div style="color:rgb(51,51,51)">Case 3: 12</div><br><div style="color:rgb(51,51,51)">Case 4: 13</div><br><div style="color:rgb(51,51,51)">Case 5: 13</div><br><div style="color:rgb(51,51,51)">Case 6: 14</div><br></div>

<div style="color:rgb(51,51,51)"><br><br></div>

<div><span style="font-size:14px; color:#ff0000">这道题一开始感觉挺简单，可是不是这么简单，首先需要用到长整型long long，然后需要考虑时间问题</span></div>

<div style="color:rgb(51,51,51)"><br><br></div>

<div style="color:rgb(51,51,51)"><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_1_7278298" name="code" class="cpp">#include <cstdio><br>#include <cstring><br>#include <algorithm><br>#include <iostream><br>using namespace std;<br><br>long long aa,bb;<br><br>void cal(long long n) {<br>    bb += n;<br>    if (bb &gt;= (1000000000000ll)) {<br>        aa += bb / (1000000000000ll);<br>        bb %= (1000000000000ll);<br>    }<br>}<br><br>int main() {<br>    freopen(“a.in”,”r”,stdin);<br>    freopen(“a.out”,”w”,stdout);<br>    int cas = 1;<br>    long long n;<br>    long long a,b,c,m;<br>    while (cin &gt;&gt; n &amp;&amp; n &gt;= 0) {<br>        aa = bb = 0;<br>        m = 1, a = n;<br>        for (int i = 0; i &lt; 62; i++) {<br>            cal((n&gt;&gt;2)*m);<br>            if ((n &amp; 3) == 3)<br>                cal((a&amp;((1ll&lt;&lt;i)-1))+1);<br>            m &lt;&lt;= 1;<br>            n &gt;&gt;= 1;<br>        }<br>        printf(“Case %d: “, cas++);<br>        if(aa) {<br>            cout &lt;&lt; aa;<br>            printf(“%012lld\n”,bb);<br>        }<br>        else cout&lt;&lt;bb&lt;&lt;endl;<br>    }<br>    return 0;<br>}</iostream></algorithm></cstring></cstdio></pre><br><br></div>

<div style="color:rgb(51,51,51)"><br><br></div>

<div><br><center style="color:rgb(51,51,51)"><br><div><br><br>## 1848: B-黄金矿工<br><br><span style="color:green">Time Limit:&nbsp;</span>1 Sec&nbsp;&nbsp;<span style="color:green">Memory Limit:&nbsp;</span>128 MB<br><br><span style="color:green">Submit:&nbsp;</span>16&nbsp;&nbsp;<span style="color:green">Solved:&nbsp;</span>4<br><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1847" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1848" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1848" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1848" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1848&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1849" target="_blank" rel="noopener">下一题</a></div><br></center><br><div style="color:rgb(51,51,51)"><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>在上个世纪前，安科的后山曾经是一个黄金矿山（现在无力吐槽）。在山上住着是n个矿工，他们辛苦一年终于到了发年终奖励的时候了，公司的CEO vyoung先生决定将一块黄金发给最有价值矿工，不过这就很让他头痛了，这些矿工每个人都是非常卖力的工作的。无奈，vyoung决定让上帝来决定。他让n课矿工围坐在一起成一个圈，第一次淘汰第m个，以后每数k个数淘汰一个，最后一个留下的将获得这块金块。<br><br></div>

<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>输入包含多组数据。每组数据包含三个整数&nbsp;n,k,m(&lt;=2n&lt;=10000,1&lt;=k&lt;=10000,1&lt;=m&lt;=n)<br><br>输入结束标志为n=k=m=0<br><br></div>

<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>对于每组数据输出最后被留下来的人<br><br></div>

<p>##</p>
<p>##<br>Sample Input</p>
<p>8 5 3</p>
<p>100 9999 98</p>
<p>10000 10000 10000</p>
<p>0 0 0</p>
<p>Sample Output</p>
<p>1</p>
<p>93</p>
<p>2019</p>
<div style="color:rgb(51,51,51)"></div><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div><span style="font-size:14px; color:#ff0000">模板题，较为简单</span></div><br><div><span style="font-size:14px; color:#ff0000"><br><br></span></div><br><div><span style="font-size:14px; color:#ff0000"></span><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_2_3068584" name="code" class="cpp">#include<cstdio><br><br>int main()<br>{<br>    freopen(“a.in”,”r”,stdin);<br>    freopen(“a.out”,”w”,stdout);<br>  int n,m,k,f;<br>  while(scanf(“%d%d%d”,&amp;n,&amp;k,&amp;m)==3&amp;&amp;n)<br>  {<br>    f=0;<br>    for(int i=2;i&lt;=n;i++)f=(f+k)%i;<br>    f=(m-k+1+f)%n;<br>    if(f&lt;=0)f+=n;<br>    printf(“%d\n”,f);<br>  }<br>}<br></cstdio></pre><br><br></div><br><div><br><br></div><br></div>

<div><br><div id="main" style="color:rgb(51,51,51)"><br><center><br><div><br><br>## 1849: C-皇后的争斗<br><br><span style="color:green">Time Limit:&nbsp;</span>1 Sec&nbsp;&nbsp;<span style="color:green">Memory Limit:&nbsp;</span>128 MB<br><br><span style="color:green">Submit:&nbsp;</span>5&nbsp;&nbsp;<span style="color:green">Solved:&nbsp;</span>3<br><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1848" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1849" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1849" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1849" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1849&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1850" target="_blank" rel="noopener">下一题</a></div><br></center><br><div><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>在国际象棋中，两个皇后相互攻击只会是在同一行，同一列，或者同一对角线上。现在给出一个nxm的棋盘，问有多少种方法放置两个相互攻击的皇后<br><br></div>

<h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>多组输入，每组输入包含两个整数n,m（0&lt;=n,m&lt;=10<sup>6</sup>）输入结束的标志为n=m=0<br><br></div>

<h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>对于每组输入，输出对应的方案数<br><br></div>

<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(51,51,51)">100 223</div>

<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h2><div style="color:rgb(51,51,51)">10907100</div><br></div><br></div><br><center><br><br><span style="font-size:14px; color:#ff0000">这道题还是不是很理解，不过下面一个代码就一个公式就解决了，挺郁闷的</span><br><br><span style="font-size:14px; color:#ff0000"></span><br><br><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_3_9829981" name="code" class="cpp">#include<iostream><br>#include<cstdio><br>#include<algorithm><br><br>using namespace std;<br><br>int main()<br>{   freopen(“a.in”,”r”,stdin);<br>    freopen(“a.out”,”w”,stdout);<br>    unsigned long long n,m;<br>    while(cin&gt;&gt;n&gt;&gt;m){<br>        if(!n&amp;&amp;!m)break;<br>        if(n&gt;m)swap(n,m);<br>        cout&lt;&lt;n<em>m</em>(m+n-2)+2<em>n</em>(n-1)<em>(3</em>m-n-1)/3&lt;&lt;endl;<br>    }<br><br>    return 0;<br>}<br></algorithm></cstdio></iostream></pre><br><br><div><span style="font-size:14px"><br><br></span></div>

<h2 id="1850-D-纸盘游戏"><a href="#1850-D-纸盘游戏" class="headerlink" title="1850: D-纸盘游戏"></a>1850: D-纸盘游戏</h2><p><span style="color:green">Time Limit:&nbsp;</span><span style="color:#333333">1 Sec&nbsp;&nbsp;</span><span style="color:green">Memory Limit:&nbsp;</span><span style="color:#333333">128 MB</span></p>
<p><span style="color:green">Submit:&nbsp;</span><span style="color:#333333">48&nbsp;&nbsp;</span><span style="color:green">Solved:&nbsp;</span><span style="color:#333333">4</span></p>
<p><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1849" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1850" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1850" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1850" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1850&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1851" target="_blank" rel="noopener">下一题</a></p></center><p></p>
<div style="color:rgb(51,51,51)"><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。<br><br>“升级”？“双扣”？“红五”？还是“斗地主”？<br><br>当然都不是！那多俗啊~<br><br>作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的：<br><br>1、&nbsp;&nbsp;总共n张牌;<br><br>2、&nbsp;&nbsp;双方轮流抓牌；<br><br>3、&nbsp;&nbsp;每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）<br><br>4、&nbsp;&nbsp;抓完牌，胜负结果也出来了：最后抓完牌的人为胜者；<br><br>假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是Kiki先抓牌，请问谁能赢呢？<br><br>当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。<br><br>Good luck in CET-4 everybody!<br><br></div>

<h2 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n（1&lt;=n&lt;=1000）。<br><br></div>

<h2 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>如果Kiki能赢的话，请输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。<br><br></div><br></div>

<p></p></div><p></p>
<div><span style="font-size:14px; color:#ff0000">这道题也是，看了代码少的简直难以置信，考察的博弈论。</span><br><br>&lt;span style=”font-family:”Times New Roman””&gt;<span style="font-size:14px; color:#ff0000">容易找到规律，最佳策略是通过取1或2张牌，使留给对手的牌数总是3的倍数，这时对手不可能一次取光，而你就可以将除以3的余数部分取光。</span><br><br>&lt;span style=”font-family:”Times New Roman””&gt;<span style="font-size:14px; color:#ff0000">这样一来就必然胜利。</span><br><br>&lt;span style=”font-family:”Times New Roman””&gt;<span style="font-size:14px; color:#ff0000"></span><br><br><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_4_3211071" name="code" class="cpp">#include<iostream><br>#include<cstdio><br>using namespace std;<br>int main(void)<br>{<br>    freopen(“a.in”,”r”,stdin);<br>    freopen(“a.out”,”w”,stdout);<br>    int n;<br>    while(scanf(“%d”,&amp;n)==1)<br>    {<br>        if(n%3==0)<br>            cout&lt;&lt;”Cici”&lt;&lt;endl;<br>        else<br>            cout&lt;&lt;”Kiki”&lt;&lt;endl;<br>    }<br>    return 0;<br>}<br></cstdio></iostream></pre><br><br></div>

<div style="color:rgb(51,51,51)"><br><br></div>

<div><br><center style="color:rgb(51,51,51)"><br><div><br><br>## 1851: E-平均数<br><br><span style="color:green">Time Limit:&nbsp;</span>1 Sec&nbsp;&nbsp;<span style="color:green">Memory Limit:&nbsp;</span>128 MB<br><br><span style="color:green">Submit:&nbsp;</span>117&nbsp;&nbsp;<span style="color:green">Solved:&nbsp;</span>2<br><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1850" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1851" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1851" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1851" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1851&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1852" target="_blank" rel="noopener">下一题</a></div><br></center><br><div style="color:rgb(51,51,51)"><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>给出n个数，每相邻两个数求一次平均数得到n-1个数，在经过n-1次操作后，剩下1个数，求这个数是多少。<br><br></div>

<h2 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>多组输入，先输入T，表示有T组测试数据&nbsp;每行输入一个n（0&lt;=n&lt;=50000），接下来一行输入n个数a[i],(-1000&lt;=a[i]&lt;=1000)<br><br></div>

<h2 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>对每组输入输出最后得到的一个数(保留小数点后三位)<br><br></div>

<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(51,51,51)">4110.421.0 2.231 2 351 2 3 4 5</div><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div><span style="color:#ff0000">&lt;span style=”font-family:”Helvetica Neue”,Arial,”Hiragino Sans GB”,STHeiti,SimSun,”WenQuanYi Micro Hei”,”Microsoft YaHei”,sans-serif; font-size:14px; white-space:pre-wrap”&gt;解题思路：类似与杨辉三角，第i个数起始被加了</span>&lt;span class=”mathjax” style=”font-family:”Helvetica Neue”,Arial,”Hiragino Sans GB”,STHeiti,SimSun,”WenQuanYi Micro Hei”,”Microsoft YaHei”,sans-serif; font-size:14px; white-space:pre-wrap; display:inline-block; margin:0px”&gt;<span class="MathJax_Preview"></span><span style="white-space:nowrap"><span style="width:3.753em; display:inline-block"><span style="display:inline-block; position:relative; width:3.098em; height:0px; font-size:17px"><span style="position:absolute; top:-3.092em; left:0.003em"><span style="font-family:STIXGeneral-Italic,serif">C<span style="display:inline-block; overflow:hidden; height:1px; width:0.003em"></span></span><span style="vertical-align:-0.235em"><span style="font-size:18px; font-family:STIXSizeOneSym,serif">(</span></span><span style="padding-left:0.122em; padding-right:0.122em"><span style="display:inline-block; position:relative; width:1.193em; height:0px"><span style="position:absolute; top:-2.676em; left:10.0156px; margin-left:-0.592em"><span style="font-size:12px; font-family:STIXGeneral-Italic,serif">n</span><span style="font-size:12px; font-family:STIXGeneral-Regular,serif">−</span><span style="font-size:12px; font-family:STIXGeneral-Regular,serif">1</span><span style="display:inline-block; width:0px; height:2.265em"></span></span><span style="position:absolute; top:-1.902em; left:10.0156px; margin-left:-0.473em"><span style="font-size:12px; font-family:STIXGeneral-Italic,serif">i</span><span style="font-size:12px; font-family:STIXGeneral-Regular,serif">−</span><span style="font-size:12px; font-family:STIXGeneral-Regular,serif">1</span><span style="display:inline-block; width:0px; height:2.265em"></span></span></span></span><span style="vertical-align:-0.235em"><span style="font-size:18px; font-family:STIXSizeOneSym,serif">)</span></span><span style="display:inline-block; width:0px; height:3.098em"></span></span></span><span style="border-left-width:0.004em; border-left-style:solid; display:inline-block; overflow:hidden; width:0px; height:1.789em; vertical-align:-0.568em"></span></span></span>&lt;span style=”font-family:”Helvetica Neue”,Arial,”Hiragino Sans GB”,STHeiti,SimSun,”WenQuanYi Micro Hei”,”Microsoft YaHei”,sans-serif; font-size:14px; white-space:pre-wrap”&gt;次。总共有&lt;span class=”mathjax” style=”font-family:”Helvetica Neue”,Arial,”Hiragino Sans GB”,STHeiti,SimSun,”WenQuanYi Micro Hei”,”Microsoft YaHei”,sans-serif; font-size:14px; white-space:pre-wrap; display:inline-block; margin:0px”&gt;<span class="MathJax_Preview"></span><span style="white-space:nowrap"><span style="width:2.265em; display:inline-block"><span style="display:inline-block; position:relative; width:1.848em; height:0px; font-size:17px"><span style="position:absolute; top:-2.199em; left:0.003em"><span style="display:inline-block; position:relative; width:1.789em; height:0px"><span style="position:absolute; top:-2.557em; left:0.003em"><span style="font-family:STIXGeneral-Regular,serif">2</span><span style="display:inline-block; width:0px; height:2.562em"></span></span><span style="position:absolute; top:-2.676em; left:0.539em"><span style="font-size:12px; font-family:STIXGeneral-Italic,serif">n</span><span style="font-size:12px; font-family:STIXGeneral-Regular,serif">−</span><span style="font-size:12px; font-family:STIXGeneral-Regular,serif">1</span><span style="display:inline-block; width:0px; height:2.265em"></span></span></span><span style="display:inline-block; width:0px; height:2.205em"></span></span></span><span style="border-left-width:0.004em; border-left-style:solid; display:inline-block; overflow:hidden; width:0px; height:1.218em; vertical-align:-0.068em"></span></span></span>&lt;span style=”font-family:”Helvetica Neue”,Arial,”Hiragino Sans GB”,STHeiti,SimSun,”WenQuanYi Micro Hei”,”Microsoft YaHei”,sans-serif; font-size:14px; white-space:pre-wrap”&gt;个数相加。但是因为n有50000，&lt;span class=”mathjax” style=”font-family:”Helvetica Neue”,Arial,”Hiragino Sans GB”,STHeiti,SimSun,”WenQuanYi Micro Hei”,”Microsoft YaHei”,sans-serif; font-size:14px; white-space:pre-wrap; display:inline-block; margin:0px”&gt;<span class="MathJax_Preview"></span><span style="white-space:nowrap"><span style="width:2.979em; display:inline-block"><span style="display:inline-block; position:relative; width:2.443em; height:0px; font-size:17px"><span style="position:absolute; top:-2.199em; left:0.003em"><span style="display:inline-block; position:relative; width:2.384em; height:0px"><span style="position:absolute; top:-2.557em; left:0.003em"><span style="font-family:STIXGeneral-Regular,serif">2</span><span style="display:inline-block; width:0px; height:2.562em"></span></span><span style="position:absolute; top:-2.676em; left:0.539em"><span style="font-size:12px; font-family:STIXGeneral-Regular,serif">50000</span><span style="display:inline-block; width:0px; height:2.265em"></span></span></span><span style="display:inline-block; width:0px; height:2.205em"></span></span></span><span style="border-left-width:0.004em; border-left-style:solid; display:inline-block; overflow:hidden; width:0px; height:1.218em; vertical-align:-0.068em"></span></span></span>&lt;span style=”font-family:”Helvetica Neue”,Arial,”Hiragino Sans GB”,STHeiti,SimSun,”WenQuanYi Micro Hei”,”Microsoft YaHei”,sans-serif; font-size:14px; white-space:pre-wrap”&gt;根本存不下，所以借助log函数。<br><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div style="color:rgb(51,51,51)"><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_5_2480723" name="code" class="cpp">#include <iostream><br>#include <cstring><br>#include <cstdlib><br>#include <set><br>#include <cstdio><br>#include <string><br>#include <vector><br>#include <map><br>#include <cmath><br>#include <algorithm><br><br>#define LL long long<br>#define LLU unsigned long long<br><br>using namespace std;<br><br>double log_C[50005],a[50005];<br><br>int main()<br>{<br>    int n,T;<br>    scanf(“%d”,&amp;T);<br>    for (int kcase=1;kcase&lt;=T;++kcase)<br>    {<br>        scanf(“%d”,&amp;n);<br>        for (int i=0;i&lt;n;++i)<br>            scanf(“%lf”,&amp;a[i]);<br>        log_C[0]=log10(1);<br>        for (int i=1;i&lt;n;++i)<br>            log_C[i]=log_C[i-1]+log10(n-i)-log10(i);//,printf(“%lf %lf\n”,log_C[i],pow(10,log_C[i]));<br>        double ans=0.0;<br>        for (int i=0;i&lt;n;++i)<br>            if (a[i]&lt;0)<br>                ans-=pow(10,log_C[i]+log10(-a[i])-log10(2)<em>(n-1));<br>            else<br>                ans+=pow(10,log_C[i]+log10(a[i])-log10(2)</em>(n-1));<br>        printf(“Case #%d: %.3lf\n”,kcase,ans);<br>    }<br>    return 0;<br>}<br></algorithm></cmath></map></vector></string></cstdio></set></cstdlib></cstring></iostream></pre><br><br></div><br><div id="main"><br><center style="color:rgb(51,51,51)"><br><div><br><br>## 1852: F-刹车<br><br><span style="color:green">Time Limit:&nbsp;</span>1 Sec&nbsp;&nbsp;<span style="color:green">Memory Limit:&nbsp;</span>128 MB<br><br><span style="color:green">Submit:&nbsp;</span>156&nbsp;&nbsp;<span style="color:green">Solved:&nbsp;</span>99<br><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1851" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1852" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1852" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1852" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1852&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1853" target="_blank" rel="noopener">下一题</a></div><br></center><br><div style="color:rgb(51,51,51)"><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>汽车一每小时n km的速度行驶，到某处需要减速停车。设汽车以等加速度&nbsp;a m/s<sup>2 &nbsp;</sup>刹车。问从开始刹车，到停车，汽车驶过多少距离。<br><br></div>

<h2 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>多组输入，每行输入n&nbsp;（0&lt;=n&lt;=400）,a(-10&lt;=a&lt;=10)<br><br></div>

<h2 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>对于每组输入，输出汽车到停下驶过的距离（单位：米）(小数点后保留三位)<br><br></div>

<h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(51,51,51)">36 -5</div><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div><span style="font-size:14px; color:#ff0000">简单题</span></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div style="color:rgb(51,51,51)"><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_6_7082529" name="code" class="cpp">#include<iostream><br>#include<cstdio><br>using namespace std;<br><br>int main(){<br>    // freopen(“a.in”,”r”,stdin);<br>      //  freopen(“a.out”,”w”,stdout);<br>int a,n;<br>while(cin&gt;&gt;n&gt;&gt;a){<br><br>    double v0 = n<em>1000</em>1.0/3600;<br>    double t = v0<em>1.0/(a</em>-1);<br>    double s = v0<em>t + 0.5</em>a<em>t</em>t;<br>    printf(“%.3f\n”,s);<br>}<br>return 0;<br>}<br></cstdio></iostream></pre><br><br></div><br><div><br><center style="color:rgb(51,51,51)"><br><div><br><br>## 1853: G-圆组<br><br><span style="color:green">Time Limit:&nbsp;</span>1 Sec&nbsp;&nbsp;<span style="color:green">Memory Limit:&nbsp;</span>128 MB<br><br><span style="color:green">Submit:&nbsp;</span>35&nbsp;&nbsp;<span style="color:green">Solved:&nbsp;</span>2<br><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1852" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1853" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1853" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1853" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1853&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1854" target="_blank" rel="noopener">下一题</a></div><br></center><br><div style="color:rgb(51,51,51)"><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>给出n个圆的圆心和半径，相交的圆算在同一组中，如圆1和圆2和圆3相交，则圆1,2,3在同一组中。求总共有几组圆。<br><br></div>

<h2 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>多组输入，第一行输入n，表示有n（0&lt;=n&lt;=1000）个圆，接下来n行，每行输入&nbsp;圆心坐标&nbsp;x，y，半径r&nbsp;（都是int型）<br><br></div>

<h2 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>对每组输入输出总共圆的组数<br><br></div>

<h2 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(51,51,51)">42 0 10 2 1-2 0 10 -2 1</div>

<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h2><div style="color:rgb(51,51,51)">4</div><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div><span style="font-size:14px; color:#ff0000">题目较为简单，遍历判断任意两个圆，并查集进行操作即可</span></div>

<p></p></div><p></p>
<div style="color:rgb(51,51,51)"><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_7_3320538" name="code" class="cpp">#include <iostream><br>#include <vector><br>#include <cstdio><br>#include <cstring><br>#include <cstdlib><br>#include <cmath><br>using namespace std;<br><br>typedef struct round {<br>    int x;<br>    int y;<br>    int r;<br>};<br>int n;<br>const int maxn  = 1000+10;<br>//int mp[maxn][maxn];<br>int f[maxn];<br>vector<struct round>V;<br>int findset(int x){<br>    return x==f[x]?x:f[x] = findset(f[x]);<br>}<br>void init(){<br>    V.clear();<br>    for(int i=0;i&lt;maxn;i++)<br>        f[i]=i;<br>for(int i=0;i&lt;n;i++){<br>    int x0,y0,R;<br>    scanf(“%d%d%d”,&amp;x0,&amp;y0,&amp;R);<br>    struct round s;<br>    s.x = x0;<br>    s.y = y0;<br>    s.r = R;<br>    V.push_back(s);<br>}<br>}<br><br>void Union(int a,int b){<br>    int x = findset(a);<br>    int y = findset(b);<br>    if(x!=y)<br>        f[y]=x;<br>}<br>double  dis(struct round a,struct round b){<br>    double s = sqrt(1.0<em>(a.x-b.x)</em>(a.x-b.x)+(a.y-b.y)*(a.y-b.y));<br>    return s;<br>}<br>bool charge(struct round a,struct round b){<br>    return dis(a,b)&lt;(a.r+b.r);<br>}<br>void solve(){<br>    for(int i=0;i&lt;n;i++){<br>        for(int j=0;j&lt;n;j++){<br>            if(charge(V[i],V[j])&amp;&amp;i!=j){<br>               // cout&lt;&lt;dis(V[i],V[j])&lt;&lt;endl;<br>                Union(i,j);<br>            }<br>        }<br>    }<br>    int s = 0;<br>    for(int i=0;i&lt;n;i++)<br>        if(f[i]==i)s++;<br>        printf(“%d\n”,s);<br>}<br>int main(){<br>    freopen(“a.in”,”r”,stdin);<br>    freopen(“a.out”,”w”,stdout);<br>    while(~scanf(“%d”,&amp;n)){<br>        init();<br>        solve();<br>    }<br>    return 0;<br>}<br></struct></cmath></cstdlib></cstring></cstdio></vector></iostream></pre><br><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div style="color:rgb(51,51,51)"><br><center><br><div><br><br>## 1854: H-曲线长度<br><br><span style="color:green">Time Limit:&nbsp;</span>1 Sec&nbsp;&nbsp;<span style="color:green">Memory Limit:&nbsp;</span>128 MB<br><br><span style="color:green">Submit:&nbsp;</span>56&nbsp;&nbsp;<span style="color:green">Solved:&nbsp;</span>34<br><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1853" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1854" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1854" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1854" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1854&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1855" target="_blank" rel="noopener">下一题</a></div><br></center><br><div><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>计算曲线y &nbsp;= x<sup>3/2</sup><sup>&nbsp;&nbsp;</sup>上相应于ab的一段弧长（-100&lt;a,b&lt;100，a,b均为int）<br><br></div>

<h2 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>多组输入，每组包含两个数，a,b<br><br></div>

<h2 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>对于每组输入，输出对应区间的弧长，结果小数点后保留三位<br><br></div>

<h2 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(51,51,51)">1 2</div>

<h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output"></a>Sample Output</h2><div style="color:rgb(51,51,51)">1.578</div><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div style="color:rgb(51,51,51)"><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_8_2033782" name="code" class="cpp">#include<iostream><br>#include<cmath><br>#include<cstdio><br>using namespace std;<br><br>int main(){<br>    //freopen(“a.in”,”r”,stdin);<br>   // freopen(“a.out”,”w”,stdout);<br>int a,b;<br>while(cin&gt;&gt;a&gt;&gt;b){<br>       // double d = 3.0/2;<br>double s = 2.0/3<em>(pow((1+b)</em>1.0,1.5)-pow((1+a)*1.0,1.5));<br><br>printf(“%.3f\n”,s);<br><br>}<br>return 0;<br>}<br><br></cstdio></cmath></iostream></pre><br><br></div><br></div><br><div style="color:rgb(51,51,51)"><br><div id="broadcast" style="color:red"><marquee id="broadcast" style="text-align:center; height:50px; position:static; visibility:visible; width:1287px; z-index:4"><br><br></marquee></div><br><div id="main"><br><center><br><div><br><br>## 1855: I-相交点<br><br><span style="color:green">Time Limit:&nbsp;</span>1 Sec&nbsp;&nbsp;<span style="color:green">Memory Limit:&nbsp;</span>128 MB<br><br><span style="color:green">Submit:&nbsp;</span>70&nbsp;&nbsp;<span style="color:green">Solved:&nbsp;</span>63<br><br><a target="_blank" href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1854" style="color:rgb(51,51,51)">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1855" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1855" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1855" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1855&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1856" target="_blank" rel="noopener">下一题</a></div><br></center><br><div><br><br>## Description<br><br><div style="color:rgb(51,51,51)"><br><br>圆1&nbsp;圆心坐标（-1,0）半径为1.5，圆2圆心坐标为（2,0）半径为2，求这两个圆的交点坐标，结果保留小数点后三位<br><br></div>

<h2 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h2><h2 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>顺序输出两个点坐标,输出格式如下<br><br>x1 y1<br><br>x2 y2<br><br><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_9_2175486" name="code" class="cpp">#include<iostream><br>#include<cmath><br>#include<cstdio><br><br>using namespace std;<br><br>int main()<br>{<br>    freopen(“a.out”,”w”,stdout);<br>    int x1 = -1,y1 = 0,r1 = 1.5;<br>    int x2 = 2,y2 = 0, r2 = 2;<br>    double mid = 1.0<em>(x2+x1)/2;<br>    double x  = 2 - mid;<br>    double y = sqrt(4-x</em>x<em>1.0);<br>    printf(“%.3f %.3f\n%.3f %.3f\n”,x,y,x,y</em>-1);<br>    return 0;<br>}<br></cstdio></cmath></iostream></pre><br><br></div><br></div><br></div>

<p></p></div><p></p>
<div style="color:rgb(51,51,51)"><br><br></div><br><div style="color:rgb(51,51,51)"><br><center><br><div><br><br>## 1856: J-老赵的挑逗<br><br><span style="color:green">Time Limit:&nbsp;</span>1 Sec&nbsp;&nbsp;<span style="color:green">Memory Limit:&nbsp;</span>128 MB<br><br><span style="color:green">Submit:&nbsp;</span>159&nbsp;&nbsp;<span style="color:green">Solved:&nbsp;</span>45<br><br><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1855" target="_blank" rel="noopener">上一题</a><a href="https://oj.ahstu.cc/JudgeOnline/submitpage.php?id=1856" target="_blank" rel="noopener">Submit</a><a href="https://oj.ahstu.cc/JudgeOnline/problemstatus.php?id=1856" target="_blank" rel="noopener">Status</a><a target="_blank" id="oj-gene" style="color:rgb(51,51,51)">标签打分</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/problem_edit.php?id=1856" target="_blank" rel="noopener">编辑题目信息</a><a href="https://oj.ahstu.cc/JudgeOnline/admin/quixplorer/index.php?action=list&amp;dir=1856&amp;order=name&amp;srt=yes" target="_blank" rel="noopener">编辑测试数据</a><a href="https://oj.ahstu.cc/JudgeOnline/problem.php?id=1857" target="_blank" rel="noopener">下一题</a></div><br></center><br><div><br><br>## Description<br><br><div style="color:rgb(51,51,51)">精通数学的老赵现在想难为一下喜爱编程的童鞋们，现在给出一个三角形的三条边a,b,c求出这个三角形的内切圆和外接圆的面积<br><br></div>

<h2 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h2><div style="color:rgb(51,51,51)"><br><br>多组输入，每行包括三个整数数a,b,c<br><br></div>

<h2 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h2><div style="color:rgb(51,51,51)"><br><br>没有每组输入输出对应三角形的内切圆和外界圆面积（结果保留小数点后三位）<br><br></div>

<h2 id="Sample-Input-6"><a href="#Sample-Input-6" class="headerlink" title="Sample Input"></a>Sample Input</h2><div style="color:rgb(51,51,51)">3 4 5</div>

<h2 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output"></a>Sample Output</h2><div style="color:rgb(51,51,51)">3.142 19.635</div><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div style="color:rgb(51,51,51)"><pre code_snippet_id="2350366" snippet_file_name="blog_20170423_10_8413494" name="code" class="cpp">#include<iostream><br>#include<cmath><br>#include<cstdio><br>using namespace std;<br><br>double cacu(double r){<br>double pi = atan(1)<em>4;<br>return pi</em>r<em>r;<br>}<br>int main(){<br>  //  freopen(“a.in”,”r”,stdin);<br>   // freopen(“a.out”,”w”,stdout);<br>int a,b,c;<br>while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c){<br>    double p = 1.0</em>(a+b+c)/2;<br>    double temp = p<em>(p-a)</em>(p-b)<em>(p-c);<br>    double s = sqrt(temp);<br>    double R = 1.0</em>a<em>b</em>c/(4<em>s);<br>    double r = 2</em>s/(a+b+c);<br>    double S1 = cacu(r);<br>    double S2 = cacu(R);<br>    printf(“%.3f %.3f\n”,S1,S2);<br>}<br>return 0;<br>}<br></cstdio></cmath></iostream></pre><br><br>附上终榜</div><br><div style="color:rgb(51,51,51)"><a href="https://oj.ahstu.cc/JudgeOnline/contestrank.php?cid=1068" target="_blank" rel="noopener">https://oj.ahstu.cc/JudgeOnline/contestrank.php?cid=1068</a><br><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div style="color:rgb(51,51,51)"><br><br></div><br><div style="text-align:center; color:rgb(51,51,51)"><img src="http://img.blog.csdn.net/20170423105535273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmppbmhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br><br></div><br><div style="color:rgb(51,51,51)"><br><br></div>

<p></p></div><br></div><br><span style="color:rgb(255,0,0); font-size:18px">属于我参加的最后一届校赛了，简单总结下这次校赛吧，这次校赛考的大部分都是数学题，比赛刚开始时，不知道题目是pdf文档，有点意思，一开始做A题，考的二进制，感觉有思路，于是写，结果老是通不过样例，写的挺着急的，当时好多同学都AC好几题了，有点慌了，再换下一题，一看就是约瑟夫环问题，挺好的，准备的有模板，然后写上去就AC了，C题D题跳过，感觉没什么好的思路，E题平均数，随便写了一下也AC了，接着写F题，写了写也AC了，感觉时间比较充足，不是很慌了，又返回去写A题，终于也AC了。。结果临时说题目全部重判了，重判了，结果全都WA了，全部WA，名次一下掉到了最后。我当时有什么办法呢，我也很绝望啊。算了吧，感觉这次成绩会很差，已经这样了，那慢慢写吧，接着看A题，感觉数据量有点大，似乎有点麻烦，还是看B题吧，于是再写了一遍约瑟夫环问题，因为材料准备充足，找了个纯数学方法写了一遍，然后就AC了，然后F题，真是不知道是什么问题，过了很久，用c++再提交了一遍然后就过了，很是无语啊，不过还好F题最后还是重判了，不过真的也花了点时间找问题。再看I题相交点，因为很多都AC了这题，乍一看感觉很是麻烦啊，没有样例，又过了很久才知道这题就一组数据，输出结果就好了，我却还在找什么输入输出格式。。。然后AC了I题，接着写J，什么内切圆和外接圆面积的问题，怎么这么多数学啊，公式什么的早已经忘了，慢慢推吧，感觉一时半会又推不出。。。内切圆是找材料写好的，最后还是通过余弦定理求出外接圆的半径，于是AC了，然后H题，H题求弧长，是考定积分的，一开始没有怎么写，算了很久然后却积分不出来，最后发现积分里有地方写错了，挺简单的积分被我弄得很复杂，修改了一下，可是还是通不过样例，输出了一串奇怪的串，我相信这次写的不会有问题，可是还是不对，时间就快要结束了，不会我这道题也写不出来吧，，最后发现程序中一个变量用了两次，似乎值已经改变了，其实很早就发现了，可是我就是觉得那样也是不会有问题的，最后还是AC了，这道题。还剩10多分钟，觉得自己没有什么时间写接下来的几题了，虽然至少有一题还是有清晰的思路，还是没有写了，然后后就这样结束了。</span></div><p></p>
<div><span style="font-size:18px; color:#ff0000">总之，感觉还是实力有很多不足吧，希望自己能不断努力学习，还有就是觉得有时自己有点钻牛角尖，导致浪费很多时间。</span></div>

<div><span style="font-size:18px; color:#ff0000">校赛结束了，准备省赛了，舞台很大，我还是很渺小，加油吧！</span></div>
]]></content>
      <categories>
        <category>AKOJ</category>
        <category>校赛</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>校赛</tag>
      </tags>
  </entry>
  <entry>
    <title>谁比较2</title>
    <url>/2015/04/18/e8-b0-81-e6-af-94-e8-be-832/</url>
    <content><![CDATA[<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">定义一个整数N中的2的指数为N二的级别，比如4=2^2则4的二度为2,6=2^1*a则6的二度为1</span></p>
<p>你的任务就是给出a,b中谁更2</p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">给出a,b 都是正数且不超过10000000</span></p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">给出a,b中谁更2</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">4 6
17 4
4 12</span></pre>

<p><strong><span style="font-size:24px; color:#333399">Sample Output</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">>
<
=
</span></pre>
<a id="more"></a>
**<span style="font-size:24px; color:#333399">Source</span>**

**<span style="font-size:24px; color:#333399"></span>**

<pre code_snippet_id="647099" snippet_file_name="blog_20150418_1_4841312" name="code" class="cpp">#include <stdio.h>
#include <stdlib.h>
int f(long a)
{
    int c = 0;
    while (a %2 == 0)
    {
        c++;
        a /= 2;
    }
    return c;
}

int main()
{
    int a,b;
    while ( 2 == scanf("%d%d",&a,&b))
    {
        if ( f(a)>f(b))
            printf(">\n");
        if (f(a)==f(b))
            printf("=\n");
        if (f(a)<f(b)) printf("<\n"); } return 0; }< pre>

<pre code_snippet_id="647099" snippet_file_name="blog_20150418_2_6348372" name="code" class="cpp">//标准代码
#include <stdio.h>
#include <stdlib.h>
int f(int n){
  int s = 0;
  while (n % 2 == 0)
    s++, n /= 2;
  return s;
}
int n, m;
void solve(){
  int flag = f(n) - f(m);
  if (flag > 0)
    puts(">");
  else if (flag == 0)
    puts("=");
  else
    puts("<"); } int main(){ while (~scanf("%d %d ", &n, &m)) solve(); return 0; }< pre>
</");></stdlib.h></stdio.h></pre></f(b))></stdlib.h></stdio.h></pre>]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS学习笔记 - OC语法</title>
    <url>/2020/12/01/ios-tourist-01/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/06a51b7fadee146d19d623adb1cec34d21f35993.png" alt="objc"></p>
<a id="more"></a>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="一个-NSObject-对象占用多少内存？"><a href="#一个-NSObject-对象占用多少内存？" class="headerlink" title="一个 NSObject 对象占用多少内存？"></a>一个 NSObject 对象占用多少内存？</h3><ul>
<li>系统分配了 16 个字节给 NSObject 对象（通过 malloc_size 函数获得）</li>
<li>但 NSObject 对象内部只使用了 8 个字节的空间（64bit 环境下，可以通过 class_getInstanceSize 函数获得）</li>
</ul>
<h3 id="对象的-isa-指针指向哪里？"><a href="#对象的-isa-指针指向哪里？" class="headerlink" title="对象的 isa 指针指向哪里？"></a>对象的 isa 指针指向哪里？</h3><ul>
<li>instance 对象的 isa 指向 class 对象</li>
<li>class 对象的 isa 指向 meta-class 对象</li>
<li>meta-class 对象的 isa 指向基类的 meta-class 对象</li>
</ul>
<h3 id="OC-的类信息存放在哪里？"><a href="#OC-的类信息存放在哪里？" class="headerlink" title="OC 的类信息存放在哪里？"></a>OC 的类信息存放在哪里？</h3><ul>
<li>对象方法、属性、成员变量、协议信息，存放在 class 对象中</li>
<li>类方法，存放在 meta-class 对象中</li>
<li>成员变量的具体值，存放在 instance 对象</li>
</ul>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><h3 id="iOS-用什么方式实现对一个对象的-KVO？-KVO-的本质是什么？"><a href="#iOS-用什么方式实现对一个对象的-KVO？-KVO-的本质是什么？" class="headerlink" title="iOS 用什么方式实现对一个对象的 KVO？(KVO 的本质是什么？)"></a>iOS 用什么方式实现对一个对象的 KVO？(KVO 的本质是什么？)</h3><ul>
<li>利用 RuntimeAPI 动态生成一个子类，并且让 instance 对象的 isa 指向这个全新的子类</li>
<li>当修改 instance 对象的属性时，会调用 Foundation 的_NSSetXXXValueAndNotify 函数<ul>
<li>willChangeValueForKey:</li>
<li>父类原来的 setter</li>
<li>didChangeValueForKey:</li>
</ul>
</li>
<li>内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</li>
</ul>
<h3 id="如何手动触发-KVO？"><a href="#如何手动触发-KVO？" class="headerlink" title="如何手动触发 KVO？"></a>如何手动触发 KVO？</h3><ul>
<li>手动调用 willChangeValueForKey:和 didChangeValueForKey:</li>
</ul>
<h3 id="直接修改成员变量会触发-KVO-么？"><a href="#直接修改成员变量会触发-KVO-么？" class="headerlink" title="直接修改成员变量会触发 KVO 么？"></a>直接修改成员变量会触发 KVO 么？</h3><ul>
<li>不会触发 KVO</li>
</ul>
<h3 id="通过-KVC-修改属性会触发-KVO-么？"><a href="#通过-KVC-修改属性会触发-KVO-么？" class="headerlink" title="通过 KVC 修改属性会触发 KVO 么？"></a>通过 KVC 修改属性会触发 KVO 么？</h3><ul>
<li>会触发 KVO</li>
</ul>
<h3 id="KVC-的赋值和取值过程是怎样的？原理是什么？"><a href="#KVC-的赋值和取值过程是怎样的？原理是什么？" class="headerlink" title="KVC 的赋值和取值过程是怎样的？原理是什么？"></a>KVC 的赋值和取值过程是怎样的？原理是什么？</h3><h3 id="Category-的使用场合是什么？"><a href="#Category-的使用场合是什么？" class="headerlink" title="Category 的使用场合是什么？"></a>Category 的使用场合是什么？</h3><h3 id="Category-的实现原理"><a href="#Category-的实现原理" class="headerlink" title="Category 的实现原理"></a>Category 的实现原理</h3><ul>
<li>Category 编译之后的底层结构是 struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息</li>
<li>在程序运行的时候，runtime 会将 Category 的数据，合并到类信息中（类对象、元类对象中）</li>
</ul>
<h3 id="Category-和-Class-Extension-的区别是什么？"><a href="#Category-和-Class-Extension-的区别是什么？" class="headerlink" title="Category 和 Class Extension 的区别是什么？"></a>Category 和 Class Extension 的区别是什么？</h3><ul>
<li>Class Extension 在编译的时候，它的数据就已经包含在类信息中</li>
<li>Category 是在运行时，才会将数据合并到类信息中</li>
</ul>
<h3 id="Category-中有-load-方法吗？load-方法是什么时候调用的？load-方法能继承吗？"><a href="#Category-中有-load-方法吗？load-方法是什么时候调用的？load-方法能继承吗？" class="headerlink" title="Category 中有 load 方法吗？load 方法是什么时候调用的？load 方法能继承吗？"></a>Category 中有 load 方法吗？load 方法是什么时候调用的？load 方法能继承吗？</h3><ul>
<li>有 load 方法</li>
<li>load 方法在 runtime 加载类、分类的时候调用</li>
<li>load 方法可以继承，但是一般情况下不会主动去调用 load 方法，都是让系统自动调用</li>
</ul>
<h3 id="load、initialize-方法的区别什么？它们在-category-中的调用的顺序？以及出现继承时他们之间的调用过程？"><a href="#load、initialize-方法的区别什么？它们在-category-中的调用的顺序？以及出现继承时他们之间的调用过程？" class="headerlink" title="load、initialize 方法的区别什么？它们在 category 中的调用的顺序？以及出现继承时他们之间的调用过程？"></a>load、initialize 方法的区别什么？它们在 category 中的调用的顺序？以及出现继承时他们之间的调用过程？</h3><h3 id="Category-能否添加成员变量？如果可以，如何给-Category-添加成员变量？"><a href="#Category-能否添加成员变量？如果可以，如何给-Category-添加成员变量？" class="headerlink" title="Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量？"></a>Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量？</h3><ul>
<li>不能直接给 Category 添加成员变量，但是可以间接实现 Category 有成员变量的效果</li>
</ul>
<h3 id="block-的原理是怎样的？本质是什么？"><a href="#block-的原理是怎样的？本质是什么？" class="headerlink" title="block 的原理是怎样的？本质是什么？"></a>block 的原理是怎样的？本质是什么？</h3><ul>
<li>封装了函数调用以及调用环境的 OC 对象</li>
</ul>
<h3 id="block-的作用是什么？有什么使用注意点？"><a href="#block-的作用是什么？有什么使用注意点？" class="headerlink" title="__block 的作用是什么？有什么使用注意点？"></a>__block 的作用是什么？有什么使用注意点？</h3><h3 id="block-的属性修饰词为什么是-copy？使用-block-有哪些使用注意？"><a href="#block-的属性修饰词为什么是-copy？使用-block-有哪些使用注意？" class="headerlink" title="block 的属性修饰词为什么是 copy？使用 block 有哪些使用注意？"></a>block 的属性修饰词为什么是 copy？使用 block 有哪些使用注意？</h3><ul>
<li>block 一旦没有进行 copy 操作，就不会在堆上</li>
<li>使用注意：循环引用问题</li>
</ul>
<h3 id="block-在修改-NSMutableArray，需不需要添加-block？"><a href="#block-在修改-NSMutableArray，需不需要添加-block？" class="headerlink" title="block 在修改 NSMutableArray，需不需要添加__block？"></a>block 在修改 NSMutableArray，需不需要添加__block？</h3><p>我们平时编写的 Objective-C 代码，底层实现其实都是 C\C++代码</p>
<pre class="mermaid">graph LR
A[Objective-C] --> B[C\C++] --> C[汇编语言] --> D[机器语言]</pre>

<p>所以 Objective-C 的面向对象都是基于 C\C++的数据结构实现的</p>
<blockquote>
<p>思考：Objective-C 的对象、类主要是基于 C\C++的什么数据结构实现的？</p>
</blockquote>
<ul>
<li>结构体</li>
</ul>
<h3 id="将-Objective-C-代码转换为-C-C-代码"><a href="#将-Objective-C-代码转换为-C-C-代码" class="headerlink" title="将 Objective-C 代码转换为 C\C++代码"></a>将 Objective-C 代码转换为 C\C++代码</h3><p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的CPP文件</code></p>
<ul>
<li>如果需要链接其他框架，使用-framework 参数。比如-framework UIKit</li>
</ul>
<h2 id="对象的本质"><a href="#对象的本质" class="headerlink" title="对象的本质"></a>对象的本质</h2><h3 id="思考：一个-OC-对象在内存中是如何布局的？"><a href="#思考：一个-OC-对象在内存中是如何布局的？" class="headerlink" title="思考：一个 OC 对象在内存中是如何布局的？"></a>思考：一个 OC 对象在内存中是如何布局的？</h3><h3 id="NSObject-的底层实现"><a href="#NSObject-的底层实现" class="headerlink" title="NSObject 的底层实现"></a>NSObject 的底层实现</h3>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>gitment</tag>
        <tag>hexo-next</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS侧滑假死卡顿问题分析</title>
    <url>/2021/11/04/ios-suspended-swipe-pop/</url>
    <content><![CDATA[<p><img src="https://docs-assets.developer.apple.com/published/f06f30fa63/UIViewController_Class_Reference_2x_ddcaa00c-87d8-4c85-961e-ccfb9fa4aac2.png" alt="示例"></p>
<a id="more"></a>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>最近做项目时发现了一个奇怪的问题，App 不知道什么操作就什么也不能操作了，点什么都没有反应，后来经过反复测试，发现是在首页先侧滑一下，然后点击跳转其他页面，然后就卡死了</p>
<h2 id="卡顿原因分析"><a href="#卡顿原因分析" class="headerlink" title="卡顿原因分析"></a>卡顿原因分析</h2><h3 id="操作路径"><a href="#操作路径" class="headerlink" title="操作路径"></a>操作路径</h3><div id="flowchart-0" class="flow-chart"></div>

<h3 id="阅读页生命周期分析"><a href="#阅读页生命周期分析" class="headerlink" title="阅读页生命周期分析"></a>阅读页生命周期分析</h3><h4 id="正常跳转"><a href="#正常跳转" class="headerlink" title="正常跳转"></a>正常跳转</h4><pre><code>2021-10-28 10:52:07.772485+0800 WKStudent[9327:4048460] WKReaderContainer: viewWillAppear
2021-10-28 10:52:08.305771+0800 WKStudent[9327:4048460] WKReaderContainer: viewDidAppear
</code></pre><h4 id="出现卡顿时"><a href="#出现卡顿时" class="headerlink" title="出现卡顿时"></a>出现卡顿时</h4><pre><code>2021-10-28 10:52:09.620765+0800 WKStudent[9327:4048460] WKReaderContainer: viewWillAppear
</code></pre><h4 id="生命周期对比"><a href="#生命周期对比" class="headerlink" title="生命周期对比"></a>生命周期对比</h4><p>首页：<code>viewWillDisappear</code>-&gt;<br>阅读页：<code>viewDidLoad</code>-&gt;<code>viewWillAppear</code>-&gt;</p>
<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>点击跳转路由时实际已经跳转了，但是页面没有显示出来，上面的日志来看，是因为阅读页的<code>viewDidAppear</code>方法没有执行，所有没有显示在 UIWindow 上，同样的，首页的生命周期也会有问题，正常情况时，跳转时<code>viewWillDisappear</code>执行后立即会走<code>viewDidDisappear</code>，但是如果出现卡顿，就只会走<code>viewWillDisappear</code>。<br>iOS 系统如果是自定义了侧滑事件，那么在首页进行侧滑操作就会出现这个 bug，应该是个系统 bug。</p>
<h2 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h2><h3 id="方案一（在-BaseViewController-中禁用首页侧滑事件，现有方案）"><a href="#方案一（在-BaseViewController-中禁用首页侧滑事件，现有方案）" class="headerlink" title="方案一（在 BaseViewController 中禁用首页侧滑事件，现有方案）"></a>方案一（在 BaseViewController 中禁用首页侧滑事件，现有方案）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    if ([self.navigationController.viewControllers count] &gt; 1) &#123;</span><br><span class="line">        self.navigationController.interactivePopGestureRecognizer.enabled = YES;</span><br><span class="line">        self.navigationController.interactivePopGestureRecognizer.delegate = self;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        self.navigationController.interactivePopGestureRecognizer.enabled = NO;</span><br><span class="line">        self.navigationController.interactivePopGestureRecognizer.delegate = self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是为什么还是会卡顿呢？上述有什么问题</p>
<h4 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h4><p><code>self.navigationController.interactivePopGestureRecognizer.enabled = NO;</code> 无效</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>在回调中，输出<code>gestureRecognizer</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123;</span><br><span class="line">    NSLog(@&quot;gestureRecognizer:%@&quot;, gestureRecognizer);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>otherGestureRecognizer</code>结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;_UIParallaxTransitionPanGestureRecognizer: 0x108a75b70; state = Possible; delaysTouchesBegan = YES; view = &lt;UILayoutContainerView 0x108a67830&gt;; target= &lt;(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition 0x108a750c0&gt;)&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>从结果上看，在 App 中即使设置了不响应侧滑的代码，依然会出现<code>_UINavigationInteractiveTransition</code>的<code>handleNavigationTransition</code>的侧滑事件，因此造成了异常</p>
<h4 id="尝试（反向推）"><a href="#尝试（反向推）" class="headerlink" title="尝试（反向推）"></a>尝试（反向推）</h4><h5 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;BaseViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface BaseViewController ()&lt;UIGestureRecognizerDelegate&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BaseViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.navigationController.interactivePopGestureRecognizer.delegate = self;</span><br><span class="line">    self.navigationController.interactivePopGestureRecognizer.enabled = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123;</span><br><span class="line">    NSLog(@&quot;gestureRecognizer:%@&quot;, gestureRecognizer);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h5><p>以上代码是不会输出任何日志的，也就是说，<code>interactivePopGestureRecognizer.enabled</code>设置为 NO 按常理来说是不会有调用。修改上述代码，复现其卡顿</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;BaseViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface BaseViewController ()&lt;UIGestureRecognizerDelegate&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BaseViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.navigationController.interactivePopGestureRecognizer.delegate = self;</span><br><span class="line">    self.navigationController.interactivePopGestureRecognizer.enabled = YES; // 修改为可以接收响应事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123;</span><br><span class="line">    NSLog(@&quot;gestureRecognizer:%@&quot;, gestureRecognizer);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-10-31 22:37:17.379692+0800 TestApp[12400:5058768] gestureRecognizer:&lt;_UIParallaxTransitionPanGestureRecognizer: 0x108a75b70; state = Possible; delaysTouchesBegan = YES; view = &lt;UILayoutContainerView 0x108a67830&gt;; target= &lt;(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition 0x108a750c0&gt;)&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>在这样的情况下，如果进行 push 操作，就会导致 app 卡顿。和上面情况一致，都是因为相应了系统的<code>handleNavigationTransition</code>事件</p>
<h3 id="方案二（在-BaseViewController-中禁用首页侧滑事件，回调中解决）"><a href="#方案二（在-BaseViewController-中禁用首页侧滑事件，回调中解决）" class="headerlink" title="方案二（在 BaseViewController 中禁用首页侧滑事件，回调中解决）"></a>方案二（在 BaseViewController 中禁用首页侧滑事件，回调中解决）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // ...</span><br><span class="line">    self.navigationController.interactivePopGestureRecognizer.delegate = self;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123;</span><br><span class="line">    if ([self.navigationController.viewControllers count] &gt; 1) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的方案是全部交由我们自己处理是否要响应侧滑事件，当然上述还是有问题，应该是只针对侧滑做上面的操作</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>找到所有对侧滑<code>delegate</code>作处理的地方，特别是首页<br><code>self.navigationController.interactivePopGestureRecognizer.delegate = nil</code></li>
<li>在<code>BaseViewController</code>中重写写自己侧滑实现</li>
<li>如果有自己的手势处理，比如其他多手势操作需要注意侧滑情况的处理，主要是首页判断</li>
<li>三方库的检查，如果涉及到与滑动有关的库，特别是首页，比如 PagerView，我们 App 首页就是层级太多了(含有 ChildViewController 的需要特别注意)，排查其他比较麻烦。如果使用三方库或者自己实现了其他的操作，需要多进行自测，以规避此 bug</li>
</ul>
<h3 id="卡顿-假死情况二"><a href="#卡顿-假死情况二" class="headerlink" title="卡顿/假死情况二"></a>卡顿/假死情况二</h3><p>还有个卡顿是在 push 时同时进行侧滑操作<br>A 页面(首页)-&gt;B 页面，同时进行侧滑</p>
<ul>
<li>页面 A 的生命周期：<code>viewWillDisappear</code>-&gt;<code>viewDidDisappear</code>-&gt;<code>viewWillAppear</code></li>
<li>页面 B 的生命周期：<code>viewWillAppear</code>-&gt;<code>viewDidAppear</code>-&gt;<code>viewWillDisappear</code></li>
</ul>
<p>通过日志得知原因是页面 A 的<code>viewDidAppear</code>和页面 B 的<code>viewDidDisappear</code>没有走，所以给我们看到的是停留在第二个页面</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>判断如果页面当前生命周期是否是<code>viewDidAppear</code>，如果不是就不进行侧滑操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    self.isViewDidAppear = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    self.isViewDidAppear = YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    self.isViewDidAppear = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123;</span><br><span class="line">    // 防止还没有push完成就进行侧滑操作，这会导致假死bug</span><br><span class="line">    if (self.isViewDidAppear) &#123;</span><br><span class="line">        return [self.navigationController.viewControllers count] &gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h3><ul>
<li>对于第一种情况导致<code>interactivePopGestureRecognizer.enabled=NO</code> 失效的原因不明</li>
<li>猜想：可能的原因是因为 ChildViewController，首页层级太多，还有其他多个滑动事件，导致响应了侧滑事件<br><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
e=>end: 结束
op=>operation: 进入首页
cond=>condition: 路由跳转前是否进行侧滑?
fz=>operation: 卡顿/假死
nl=>operation: 正常
st->op->cond
cond(yes)->fz
cond(no)->nl
cond2=>condition: 是否退出后台再重新进?
cond2(yes)->nl
cond2(no)->fz
fz->cond2
nl->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>interactivePopGestureRecognizer</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+valine评论系统(评论无效+头像不显示问题解决)</title>
    <url>/2019/01/08/new-comment-valine/</url>
    <content><![CDATA[<p>之前使用的gitment，由于众所周知的原因，国内速度太慢了，而且评论账号得要是github账号，不是很方便，突然看到valine这个评论系统，感觉挺简洁的，于是就用上了…  </p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>但是配置时遇到了问题，这里mark下，我使用的这个hexo版本是自带valine评论的，所以只需要在_config中开启即可，但是开启是有评论框了，但是评论完成一刷新就没有了，这让我很无奈，后来在网上查找原因，发现是新版本中字段名称改了，修改就OK了<br>修改位置<br><a id="more"></a><br><code>themes\next\layout\_third-party\comments\valine.swig</code> 15行左右，将appId和appKey分别替换为app_id和app_key即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Valine(&#123;</span><br><span class="line">    el: &apos;#comments&apos; ,</span><br><span class="line">    verify: &#123;&#123; theme.valine.verify &#125;&#125;,</span><br><span class="line">    notify: &#123;&#123; theme.valine.notify &#125;&#125;,</span><br><span class="line">    app_id: &apos;&#123;&#123; theme.valine.appid &#125;&#125;&apos;,</span><br><span class="line">    app_key: &apos;&#123;&#123; theme.valine.appkey &#125;&#125;&apos;,</span><br><span class="line">    placeholder: &apos;&#123;&#123; theme.valine.placeholder &#125;&#125;&apos;,</span><br><span class="line">    avatar:&apos;&#123;&#123; theme.valine.avatar &#125;&#125;&apos;,</span><br><span class="line">    guest_info:guest,</span><br><span class="line">    pageSize:&apos;&#123;&#123; theme.valine.pageSize &#125;&#125;&apos; || 10,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>关于头像显示问题，注册了<a href="http://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a>，之前看文档说是七天的同步时间，结果一直也没有显示头像，检查查看头像链接，发现把<code>&amp;v=1.3.4</code>去掉就可以了，于是下载js文件<a href="https://unpkg.com/valine@1.3.4/dist/Valine.min.js" target="_blank" rel="noopener">valine</a>，下载后然后编辑，搜索关键字<code>&amp;v=</code>，找到<code>g.params=&quot;?d=&quot;+(i.indexOf(a)&gt;-1?a:&quot;mp&quot;)+&quot;&amp;v=&quot;+o+d</code>，将<code>&quot;&amp;v=&quot;+o+d</code>删除即可，然后上传到七牛云，将cdn地址替换，头像就顺利显示了</p>
<h2 id="评论FAQ"><a href="#评论FAQ" class="headerlink" title="评论FAQ"></a>评论FAQ</h2><ul>
<li>关于评论刷新后消失的问题<br>这类问题解决较为容易，出现这类的问题一般是appId和appKey没有在js文件中找到原因，或者就是就是leancloud没有获取到正确的id和key<br>检查方法，默认的valine的js路径一般是<a href="//unpkg.com/valine/dist/Valine.min.js">//unpkg.com/valine/dist/Valine.min.js</a>，要是没有配置过，路径在<code>themes\next\layout\_third-party\comments\valine.swig</code>中<br><img src="https://cdn.fayne.cn/image/valineQA.png" alt="FQA"><br>图中椭圆中为默认路径，如果在_config.yml中配置过Valine地址，则地址为方框中的地址<br><img src="https://cdn.fayne.cn/image/js-url.png" alt="js"><br>打开js地址， 查找appId或者app_id，如果能找到就说明就没有问题，配置也就是配置这个能找到的变量名，我的配置文件就是使用的app_id和app_key，修改好了就能正常评论了</li>
</ul>
<blockquote>
<p>根据评论中<code>@yutouwd</code>找到的解决办法，可能是hexo版本的自带的流量统计和valine冲突了，可以尝试升级hexo版本。感谢@yutouwd提供的解决方案</p>
</blockquote>
<ul>
<li>关于评论头像不显示的问题<br>原因就是链接后跟了个<code>&amp;v=1.3.4</code>，解决就是将这段删掉就可以了，具体到js文件就是删掉<code>&amp;v=&quot;+o+d</code>即可，如果嫌太麻烦可以直接用我的<a href="https://cdn.fayne.cn/js/Valine.min.js" target="_blank" rel="noopener">https://cdn.fayne.cn/js/Valine.min.js</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>valine</tag>
      </tags>
  </entry>
  <entry>
    <title>F数圈圈</title>
    <url>/2015/04/18/f-e6-95-b0-e5-9c-88-e5-9c-88/</url>
    <content><![CDATA[<p><strong><span style="font-size:24px; color:#333399">Description</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">幼儿园的小朋友对数字其实不是很感兴趣，他们更感兴趣的是形状，现在给你一个数字，小朋友都会数出其中一共有多少圆圈圈</span></p>
<p></p>
<p><strong><span style="font-size:24px; color:#333399">Input</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">一个数字n长度不超过19位</span></p>
<p><strong><span style="font-size:24px; color:#333399">Output</span></strong></p>
<p><span style="font-family:Times New Roman; font-size:14px">输出其中的圈圈数总数</span></p>
<p><strong><span style="font-size:24px; color:#333399">Sample Input</span></strong></p>
<pre><span style="font-family:Times New Roman; font-size:14px">14589
20869
12357</span></pre>
<a id="more"></a>
**<span style="font-size:24px; color:#333399">Sample Output</span>**

**<span style="font-size:24px; color:#333399">Hint</span>**

<span style="font-family:Times New Roman; font-size:14px">3

5

0</span>

<span style="font-family:Times New Roman; font-size:14px"></span>

<pre code_snippet_id="647097" snippet_file_name="blog_20150418_1_8119207" name="code" class="cpp">#include <stdio.h>
#include <string.h>
int sc(char m)
{
    int s = 0;
    if ( m == '6'||m == '9' || m == '0')
        s = 1;
    if ( m == '8')
        s = 2;
    return s;
}

int main()
{
    char a[20];
    int k, s,i;
    while ( 1 == scanf("%s",a))
    {
        s = 0;
        k = strlen(a);
        for (i=0; i<k; ++i) s +="sc(a[i]);" printf("%d\n",s); } return 0; }< pre>

<pre name="code" class="cpp">//标准代码
#include <stdio.h>
#include <stdlib.h>
int q[] = {
  1, 0, 0, 0, 0, 0, 1, 0, 2, 1,
};
int main(){
  long long n;
  int s;
  freopen("A.in", "r", stdin);
  freopen("A.out", "w", stdout);
  while (~scanf("%I64d", &n)){
    s = 0;
    while (n)
      s += q[n % 10], n /= 10;
    printf("%d\n", s);
  }
  return 0;
}</stdlib.h></stdio.h></pre>
</k;></string.h></stdio.h></pre>]]></content>
      <categories>
        <category>AKOJ</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>akoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Mook第八周习题 单词长度（4分）(1)题</title>
    <url>/2015/04/20/mook-e7-ac-ac-e5-85-ab-e5-91-a8-e4-b9-a0-e9-a2-98-e5-8d-95-e8-af-8d-e9-95-bf-e5-ba-a6-ef-bc-884-e5-88-86-ef-bc-891-e9-a2-98/</url>
    <content><![CDATA[<div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_4"><br><strong>题目内容：</strong><br><br>你的程序要读入一行文本，其中以空格分隔为若干个单词，以‘.’结束。你要输出这行文本中每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如“it’s”算一个单词，长度为4。注意，行中可能出现连续的空格。<br><br><strong>输入格式:</strong><br><br>输入在一行中给出一行文本，以‘.’结束，结尾的句号不能计算在最后一个单词的长度内。<br><br><strong>输出格式：</strong><br><br>在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。<br><br><strong>输入样例：</strong><br><br>It’s great to see you here.<br><br><strong>输出样例：</strong><br><a id="more"></a><br>4 5 2 3 3 4<br></div>

<div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div>

<p></p><p></p>
<pre name="code" class="cpp">#include <stdio.h>
int main()
{   int i=0;
    char a;
    while(1){
        scanf("%c",&a);
        if(a == '.'){
                        if(i!=0){
                                printf("%d",i);
                        }
                        printf("\n");
                        break;
                }
        if(a==' '){
                        if(i!=0){
                                printf("%d ",i);
                                i=0;
                        }
                }
        else{
                i+=1;
        }
    }
return 0;
}
</stdio.h></pre>
]]></content>
      <categories>
        <category>MOOC</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一下</title>
    <url>/2018/03/30/new-day/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码无效, 请检查并重试" data-whm="这些内容无法验证，但您仍然可以查看"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="输入密码，查看文章" /><label>输入密码，查看文章</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="8d711ea756b2855ad6a021b51204550481181474c200101fd29740daa9a7d574">5393d9cd48cf4ad629c25c2765d478ff918c3f927f5a06f7a62ff39ee7e52eb92c122b11915a1e384b8a2ea52a4880f24ffcec437a6a2d1f8b6efa9a671b1d4375a16b10426c90abd8530548245b0f01f4357c4cb1b2364effb6cbda32154fbe1808e8446ee65dc9349a4d799c7c98880474ea8e75c5912556acb47fb27c9d2e883e38fd5c51e5988d6dbbd2ffc7b73f44d3bf824d853cc57e61876b766be5a671d3a97c8b1054dfbcac8678a324658c2136b6bfa5d4fd1b31488f940e7e3981ec7197a9f22e8e6d662012c6891a33d8a25231b270b5d5a35d4215bedd8a9b033d4ce6b6512dc72556c1130d6a28d8acf2e577b066feb5279dc12ff3cdc9f3d4c9ceac65efd34a7a2472efab91b0e3feb1a59a2764b724846bfabc7f37908226f5338b3c1e4497d01b8551804d837a941a14691d57976a09bc80317fca6afe7502578634cbb9cb34aa42c84f47c2c2095e8882253f439f258fe096fe74955bc53803ee1521bedc4b8939b45d119dcfd7ba2a1a14a9644a1e96d44dd3140e8b6240e9fdaea0d504375422d1173eea17ed9ee6d7e7048c0df7a8f8ca5a1d5cf012d84ded26b977a94182507ad0bc0a0edc6c9245c41cb0a9eea027400ba79b73f9be6a29fbce3c13983c768517747658fda06f865ec22986ce4ae589bde68074116f68edc0cb910a944273a35b948f5f245c7e3be2d66325bbb1b9af9422c3c862c46af9b735a585f5da61943b71366ac7bde5447b51a188b58bf247f81676a285457238165bf59ded3d9078da50259a23464741eef83a78f3c22fdcb2e304ef3e5bed4063789a6cabe66240661e54389bd18019b56698fb89e9b0540d241d76ea3c71bfbc9c226fb5f2da162d6e2eaf7ee3f6c97f8c97a6a4d8189b6763f8d0de578ba8ac04b3240b3b3d855d7e14cb7637c8124336489d2437d95b535046e6fd3df0488626a8bb7e2962bdb7ec753b35025c1b9b1cc5332482ee85e749df09b59936a921c8e0402b79683f86181037b6072247892f45f14a69384bbc0f3fb6191666919f5b2cc8fab76deb29664c90b8f2b8adafcf2aea1e2768e3d41b10e8f4278524f15799383214b74a8aa44e7b56aca047143f851b5ac2d2197d47267edc8d82ecd0cbf150e4ab0c7e1f3882e69ac35afeb340ec501dbc9211b005a27d93d247d3e85cb9d51bde8968bd2908e9f6163ccd488448c4195212a9c8f1e97850c9fd09764efcb79b9c90c638c144f9ae24f3aaa87810ae7614fb6fc84165f29935055870c7456b41f91ef799454b57cea7077cd84b3bf734473ff4958a4bcdb4a47b44274007df05bce1d6f41ffecc7a5d927ff3e24d8ca5ebaa245e50d3d20c41b9fe8f7fdca81c0b3f7c0f3e7c3abf7e1c81b1d4e297bba93607acba71d43ed2caf6363b0b92d516fdc00658c613dd522067f08a788f9cca001af030124e4ccad68f7c16a285d6f7020f3e3a88649a5511fb063f0c8bedece6b3aee25ec545c934e3e0aa84c67da105d709ca197859a7dd586617d1cff3a47c161bdb914d20adef50fba59cfea892299a5453955f6395c55d93fd3d7483c513b48550d52e0fc896d0e38095cadc5ed2f2984de629f8923755b3dc0668b0b86cd72e771239728d276f03d889930ee32c098f29762c377ef25e77619e5c6573423c47638c57923a915b19b5986ea37e91e8c0df1e694f965f9f3856949f21dd74ce9b3e292b1b8ced18dd64cdca8cbe03c4ce3003f36cd11b1c607035862cc6eee05ca98054028c80079b22118cb5ca85c2e0b861ca1f21153b9e030896e6fc42ed12623080cfc536b346c51cb87f7dcd962796d9e5c3ad19db24c475dc9b24146393409d92f411b903b655fd3706a7fd987ca7345b6715bdab4003ef4fba5765dee40e87fc55f9e2b150dbf463cc0b11b339189ce2d9b85608af50ed71043206e396bbc179d49cdc0cfcd149892bd4cacf438a4bd23bfb29755f86c2cc26d90b25448ef2f75757607d78f2fff8a973b97463f0918b6dd972d4da426ac7af1f9179240b1291fba71e4c7e07fe06d2e7b22e9bb17bc4a0b6b10d85c13baef186d0d67b17f49fb6bdbb7639368271440e6fa7d70534afbfe89c825458b77008dd0dd7b33bd49a83b1f4bf0add14b5bf2600510382308b10d044a2363cb6b340ec28a6796a55fc40cf5465b6c9c46dfa0d37c30f68c266434773fbc3f73a77def5fe19fa7b65633c0f6f6041f515af522726ec4e654619f350871a4ce1a7429ba32abde1ef3256c0ffc69a8375fe0894dcae40541a08d1208204d38fc125c62ff0709351e658e86fdfc7d8cb5d0ae628637fc1e6f2f62ee123b83274748851b523ef540cc7f1eb927caf874ef0970d735f095ba9be7d3616ef14d83d37e7f78a870b7219004b78a871c17c4be333cc426e2e547c8ad55e939155ef2bf590547787ee1a8bf0fa28ef5f2492e1c4732cc605db239c81e3b776a7729ac4ba34d2330e2af7056aac0c98e626ab47b7067cf5794feaa0d2876f5d37cbba69fc47122af72a70e7249f3fb7076131bf4fc2190d7b6017e50195b0135d88e8e11d531bc4b01e3594b7f5eadd78f40e1aedb001cf8ac746ad3e288ddae6eb8a51b196223ca6d50cd6e00b2fc2fbefde62b12b80e4cd0f816c548abc55e46de2cd086dbf4b111be979d5849f930f02e3bdd0bf976474280c359963dbad8cc320da33fae6d6973025bf675e4265b652ea493d1bc85899016adef2ff6d7c8db3ee86182af89c298a951b3e7d4aeaf8e704fb3eb0bf9e3c1565ca7d112c6f5959ad316458a3b84b06fae1c02acf21efa54f0e07b13fea85a93c5503ae659fabeafca6aae71f6cd8bf6ba8becc01fceb7c2afacb16e2d448cc9a7acc553f454a5177b26f313c729dc45d3da33ad9c4f9d3335b013bfe212c7cc068b612940f58086da17a5aaae69f3753ba48472c29e2e6291c42549fe765dca5b515f982fe29828e6fdf28ed29d388d0eea7f66aa03be5626708f21eed36eef1a153fa60667a48ee709e9a43341c6058b0a62a189b179dd5d4f5684daab769ccfd4414b69fc1ba21469ce4c28325dafdb2aa4c39e462cd83d4e3b56ac1b359ec6e5f019a49c7a809039fa789aad38d35f4159fa21ea14938367e60bbcdfe86c8ca1d03e1926728308812beb00c77741ab6ebc473e5999ba06c58878adff3f751c3f0a0093a417933e3127e4230a87832467bedd426f4a2566f162de4303ad7afaed2009ff36b7cf03f557fb1d9a373fa99d749b1ce46fe9732effbcc78b60c275ac6fad11b13d95021ea21d477870170a7687390db6f556a1b999528f0f280e6306b2544512d8d2d4a0e0d828c6c6c6b9ab77fc1adb6ab145b9731cdd456c949b6a75347b31d407e8b585347ba6267fb9cc99bd88371b9d1f646b62cbb991b87697440f3821030f12a0cb0aac86a378692433cec2a84f2e64acc5009a73122b0c583d7609adbdaa59a484ab5e53ee9ed6566f26c231e9887236fffe6c3ed279d13b31f6aaaf284be620cb933838f8091a40381b2d15525d5163380bf8186b69b476b15b5a2f336b05cccbbb956a347d038e87e961cf6274f8e4287e649fda466873bc045113f8b4bc61a03682348f11d4a2ab1b9efde8532462c9fb208e858c262e5acdb92b839ed2dfc6be77a29dd4ca1ba0dde150187dc1b37635dea07451ba7be2858ed6a10c90592c2bf94d43bf919a80979ad545c9e4c5478a4fda4f76679e6479e3fb3ed1a0ef54d682b332c19164bb6060c1112df1d85d3110848ad44e40b491e223dc9fd385a0daaf24ff9db497905ca6722e562a3f26a7c25c4ecba1436ea3a8ec7fc77e645eaf19ff6c772d88ccd896df5c7554b46123594e7e6215a33378bac68395ab017b7ccdf28fb29d2ff0efaa6d961a168414e92c9ebb084629c70303fb6d274c4c3434f85d2f68ea64decc7cb5d33fd07cd87e5892d3e926014b739e6dfe2e7da0be0ad66bc92e05233b0a620b79d40e9a511c13eb84d603462a9baeebd72afd718134aab0dc6560c77c309108b41bad9c2d1ea131b84f440cd1f445f569b2029607944d93bf4c1bda805da1a07d9b594091b8ad962f74b0be35d147aa922dee53722a5cb6a54ac5536197c545728607c72e619b7d97bd2c3ca7eb098</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置http强制跳转到https</title>
    <url>/2017/07/23/nginx-e9-85-8d-e7-bd-aehttp-e5-bc-ba-e5-88-b6-e8-b7-b3-e8-bd-ac-e5-88-b0https/</url>
    <content><![CDATA[<p>刚刚配置好https证书，可以实现访问，可是发现个问题输入网址直接是到http网站而非https，每次需要输入https那也真麻烦</p>
<p>用我自己的网站实验：http:fayne.cn 直接跳转到<a href="https://fayne.cn" target="_blank" rel="noopener">https://fayne.cn</a></p>
<p>步骤：修改/etc/nginx/nginx.conf</p>
<p></p><br><a id="more"></a><p></p>
<pre code_snippet_id="2494986" snippet_file_name="blog_20170723_1_3233119" name="code" class="html">server {
        listen 80;
        server_name fayne.cn;
        return 301 https://$server_name$request_uri;
}
    server {
        listen       443 default_server;
        server_name _;
        ssl on;
        ssl_certificate 1_fayne.cn_bundle.crt;
        ssl_certificate_key 2_fayne.cn.key;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置
        ssl_prefer_server_ciphers on;
        root         /usr/share/nginx/html;
        index index.html index.php index.htm;
        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
                root   /usr/share/nginx/html;
                index  index.html index.htm index.php;
        }
}</pre>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>NYOJ_23_取石子（一）</title>
    <url>/2016/09/22/nyoj-23-e5-8f-96-e7-9f-b3-e5-ad-90-ef-bc-88-e4-b8-80-ef-bc-89/</url>
    <content><![CDATA[<div class="problem-display" style="font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun"><br><br>##<br>取石子（一）<br><br><div class="problem-ins" style="text-align:center">时间限制：<span class="editable highlight" id="problem[time_limit]" style="color:rgb(113,32,21)">3000</span>&nbsp;ms &nbsp;|&nbsp; 内存限制：<span class="editable highlight" id="problem[memory_limit]" style="color:rgb(113,32,21)">65535</span>&nbsp;KB</div><br><div class="problem-ins" style="text-align:center">难度：<span class="editable highlight" style="color:rgb(113,32,21)">2</span></div><br></div>

<div class="clr" style="clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19.5px"><br></div>

<dl class="problem-display" style="margin:0px; padding:0px"><dt style="color:rgb(113,32,21); font-family:Tahoma,Arial,sans-serif,simsun; font-size:16px; margin:1em 0px 0.2em; padding:0px; font-weight:bold"><br>描述</dt><dd style="color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; margin:0px; padding:0px"><br>一天，TT在寝室闲着无聊，和同寝的人玩起了取石子游戏，而由于条件有限，他/她们是用旺仔小馒头当作石子。游戏的规则是这样的。设有一堆石子，数量为N（1&lt;=N&lt;=1000000），两个人轮番取出其中的若干个，每次最多取M个（1&lt;=M&lt;=1000000），最先把石子取完者胜利。我们知道，TT和他/她的室友都十分的聪明，那么如果是TT先取，他/她会取得游戏的胜利么？<br><div class="clr" style="color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; clear:both"><br></div><br><dl class="others" style="margin:0px; padding:0px"><dt style="color:rgb(113,32,21); font-family:Tahoma,Arial,sans-serif,simsun; font-size:16px; margin:1em 0px 0.2em; padding:0px; font-weight:bold"><br>输入</dt><dd style="color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; margin:0px; padding:0px"><br>第一行是一个正整数n表示有n组测试数据<br><a id="more"></a><br>输入有不到1000组数据，每组数据一行，有两个数N和M,之间用空格分隔。</dd><dt style="color:rgb(113,32,21); font-family:Tahoma,Arial,sans-serif,simsun; font-size:16px; margin:1em 0px 0.2em; padding:0px; font-weight:bold"><br>输出</dt><dd style="color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; margin:0px; padding:0px"><br>对于每组数据，输出一行。如果先取的TT可以赢得游戏，则输出“Win”，否则输出“Lose”（引号不用输出）</dd><dt style="color:rgb(113,32,21); font-family:Tahoma,Arial,sans-serif,simsun; font-size:16px; margin:1em 0px 0.2em; padding:0px; font-weight:bold"><br>样例输入</dt><dd style="color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; margin:0px; padding:0px"><br>&lt;pre id=”sample_input” style=”margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,”Courier New”,”DejaVu Sans Mono”,”Droid Sans Mono”,monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)”&gt;2<br>1000 1<br>1 100<br></dd><dt style="color:rgb(113,32,21); font-family:Tahoma,Arial,sans-serif,simsun; font-size:16px; margin:1em 0px 0.2em; padding:0px; font-weight:bold"><br>样例输出</dt><dd style="color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; margin:0px; padding:0px"><br>&lt;pre id=”sample_output” style=”margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,”Courier New”,”DejaVu Sans Mono”,”Droid Sans Mono”,monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)”&gt;Lose<br>Win<br></dd><dt style="color:rgb(113,32,21); font-family:Tahoma,Arial,sans-serif,simsun; font-size:16px; margin:1em 0px 0.2em; padding:0px; font-weight:bold"><br>来源</dt><dd style="color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; margin:0px; padding:0px"><br><a href="http://acm.nyist.net/JudgeOnline/search_result.php?source=%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE" target="_blank" rel="noopener">经典题目</a></dd><dt style="color:rgb(113,32,21); font-family:Tahoma,Arial,sans-serif,simsun; font-size:16px; margin:1em 0px 0.2em; padding:0px; font-weight:bold"><br>上传者<br><br><a href="http://acm.nyist.net/JudgeOnline/profile.php?userid=%E5%BC%A0%E4%BA%91%E8%81%AA" target="_blank" rel="noopener">张云聪</a><br><br><span style="color:#ff0000"><span style="font-family:Tahoma,Arial,sans-serif,simsun"><span style="font-size:14px">题解：</span></span></span><br><br><span style="font-family:Tahoma,Arial,sans-serif,simsun; color:#ff0000"><span style="font-size:14px">一开始低估了这个难度为2的问题，却发现却不是那么的简单，查了资料，原来是博弈问题</span></span><br><br><span style="font-family:Tahoma,Arial,sans-serif,simsun"><span style="font-size:14px"><span style="color:#ff0000">巴什博奕（Bash Game）：<br><br>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。<br><br>显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。</span></span></span><br><br><pre code_snippet_id="1895468" snippet_file_name="blog_20160922_1_992180" name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int t;<br>    scanf(“%d”, &amp;t);<br>    while (t–)<br>    {<br>        int n, m;<br>        scanf(“%d%d”, &amp;n, &amp;m);<br>        if (n % (1 + m))<br>            printf(“Win\n”);<br>        else<br>            printf(“Lose\n”);<br>    }<br>    return 0;<br>}</pre><br><br><span style="font-family:Tahoma,Arial,sans-serif,simsun"><span style="font-size:14px"><br><br></span></span><br><br></dt></dl><br></dd></dl>
]]></content>
      <categories>
        <category>NYOJ</category>
        <category>博弈论</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT (Basic Level) Practise （中文）-1021. 个位数统计 (15)</title>
    <url>/2015/07/12/patbasiclevelpractise-ef-bc-88-e4-b8-ad-e6-96-87-ef-bc-89-1021-e4-b8-aa-e4-bd-8d-e6-95-b0-e7-bb-9f-e8-ae-a115/</url>
    <content><![CDATA[<h1 id="1021-个位数统计-15"><a href="#1021-个位数统计-15" class="headerlink" title="1021. 个位数统计 (15)"></a>1021. 个位数统计 (15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">100 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">CHEN, Yue<br><br></div><br></div>

<div id="problemContent"><br>给定一个k位整数N = d<sub>k-1</sub><em>10<sup>k-1</sup> + … + d<sub>1</sub></em>10<sup>1</sup> + d<sub>0</sub> (0&lt;=d<sub>i</sub>&lt;=9, i=0,…,k-1, d<sub>k-1</sub>&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。<br><br><strong>输入格式：</strong><br><br>每个输入包含1个测试用例，即一个不超过1000位的正整数N。<br><a id="more"></a><br><strong>输出格式：</strong><br><br>对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。<br><strong>输入样例：</strong><br><pre>100311<br></pre><br><strong>输出样例：</strong><br><pre>0:2<br>1:3<br>3:1<br><pre name="code" class="cpp">/<em>
 </em>此题在解答时完全不需要<br> <em>使用使用数组储存数据，
 </em>实时记录单个数字，并统计即可<br> */<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>int main()<br>{<br>    int num[10], i;<br>    char ch;<br>    memset(num, 0, sizeof(num));<br>    while ( (ch = getchar()) != ‘\n’ )<br>    {<br>        num[ch-‘0’]++;<br>    }<br>    for ( i=0; i&lt;10; i++ )<br>    {<br>        if ( num[i] )<br>            printf(“%d:%d\n”, i, num[i]);<br>    }<br>    return 0;<br>}</pre><br><img src="http://img.blog.csdn.net/20150712225048684?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br></pre><br></div>
]]></content>
      <categories>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT (Basic Level) Practise （中文）  1017. A除以B (20)</title>
    <url>/2015/08/31/patbasiclevelpractise-ef-bc-88-e4-b8-ad-e6-96-87-ef-bc-891017-a-e9-99-a4-e4-bb-a5b20/</url>
    <content><![CDATA[<h1 id="1017-A除以B-20"><a href="#1017-A除以B-20" class="headerlink" title="1017. A除以B (20)"></a>1017. A除以B (20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">100 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">CHEN, Yue<br><br></div><br></div>

<div id="problemContent"><br>本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B <em> Q + R成立。<br><br><strong>输入格式：</strong><br><br>输入在1行中依次给出A和B，中间以1空格分隔。<br><br><strong>输出格式：</strong><br><br>在1行中依次输出Q和R，中间以1空格分隔。<br><strong>输入样例：</strong><br><pre>123456789050987654321 7<br></pre><br><strong>输出样例：</strong><br><pre>17636684150141093474 3<br><br><span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">解题思路：<br>此题的因为被除数范围太大，所以用字符串表示被除数，从小学就学过的基本除法规则在此时就派上了用场<br></span></pre><br><a id="more"></a><br>1.  <span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">首先依次读取被除数，用临时变量temp储存被除数各位数（从首位开始）</span><br>2.  <span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">用第一个数除以B，若第一个数大于等于B，输出第一个数/B，并标记首位</span><br>3.  <span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">若第一个数小于B，先判断首位是否标记，没有标记则进入下一步，否则则输出零</span><br>4.  <span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">temp储存其对B的余数，并进入第一步，并判断是否继续</span><br>5.  <span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">以上步骤完毕后，判断是否标记，没有标记则输出0</span><br>6.  <span style="font-family:KaiTi_GB2312; font-size:18px; color:#FF0000">输出余数temp</span><br><span style="color:#FF0000"><span style="font-size:18px"><span style="font-family:KaiTi_GB2312">以上步骤写的不是很清晰，可以看下面解答<br><br></span></span></span><br><pre><pre name="code" class="cpp">#include <iostream><br>#include <string><br><br>using namespace std;<br><br>int main()<br>{<br>    string A;<br>    int B, R, i, temp = 0, p = 0;<br>    cin &gt;&gt; A &gt;&gt; B;<br>    for ( i=0; i&lt;A.length(); i++ )<br>    {<br>        temp = temp</string></iostream></pre></pre></em>10 + A[i] - ‘0’;//每次用temp除以B，下一循环自动更新temp的值<br>        if ( temp &gt;= B )//判断是否大于除数B ，成立则输出商的第一位<br>        {<br>            cout &lt;&lt; temp/B;<br>            p = 1;//第一位输出后用p标记<br>        }<br>        else if (p)<br>            cout &lt;&lt; “0”;//第一位输出后且temp&lt;B，则后移一位，商0<br>        temp %= B;//得到余数<br>    }<br>    if ( p == 0 )<br>        cout &lt;&lt; “0”;<br>    cout &lt;&lt; “ “ &lt;&lt; temp &lt;&lt; endl;<br><br>    return 0;<br>}<br><br><br></div>
]]></content>
      <categories>
        <category>PAT</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>pat</tag>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT (Basic Level) Practise （中文） 1023. 组个最小数 (20)</title>
    <url>/2015/08/30/patbasiclevelpractise-ef-bc-88-e4-b8-ad-e6-96-87-ef-bc-891023-e7-bb-84-e4-b8-aa-e6-9c-80-e5-b0-8f-e6-95-b020/</url>
    <content><![CDATA[<h1 id="1023-组个最小数-20"><a href="#1023-组个最小数-20" class="headerlink" title="1023. 组个最小数 (20)"></a>1023. 组个最小数 (20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">100 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">CAO, Peng<br><br></div><br></div>

<div id="problemContent"><br>给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。<br><br>现给定数字，请编写程序输出能够组成的最小的数。<br><br><strong>输入格式：</strong><br><br>每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。<br><br><strong>输出格式：</strong><br><br>在一行中输出能够组成的最小的数。<br><strong>输入样例：</strong><br><pre>2 2 0 0 0 3 0 0 1 0<br></pre><br><strong>输出样例：<br><a id="more"></a><br><span style="background-color:rgb(255,255,255)"><span style="font-size:14px; color:#FF0000"><span style="font-family:KaiTi_GB2312"></span></span></span></strong><br><pre>10015558<br>&nbsp;<br><pre><span style="background-color:rgb(255,255,255)"><span style="font-size:14px; color:#FF0000"><span style="font-family:KaiTi_GB2312">解题思路：<br></span></span></span></pre><span style="background-color:rgb(255,255,255)"><span style="font-size:14px; color:#FF0000"><span style="font-family:KaiTi_GB2312">   ·利用数组a[0],..a[9]储存0…9数字出现的次数</span></span></span><br><span style="background-color:rgb(255,255,255)"><span style="font-size:14px; color:#FF0000"><span style="font-family:KaiTi_GB2312">   ·首先组成的数字首位不能为零，同时要求数字最小，即输出最小的非零数，同时将该数的次数减一</span></span></span><br><span style="background-color:rgb(255,255,255)"><span style="font-size:14px; color:#FF0000"><span style="font-family:KaiTi_GB2312">   ·输出所有的“0”。</span></span></span><br><span style="background-color:rgb(255,255,255)"><span style="font-size:14px; color:#FF0000"><span style="font-family:KaiTi_GB2312">   ·从1开始从小到大按其次数输出所有数字</span></span></span><br><pre name="code" class="cpp">#include <iostream><br>using namespace std;<br><br>int main()<br>{<br>    int a[10], i, j;<br>    for ( i=0; i&lt;10; i++ )<br>        cin &gt;&gt; a[i];//a[i]记录0至9出现的次数<br>    for ( i=1; i&lt;10; i++ )//输出最小的非零数<br>        if ( a[i] )<br>        {<br>            cout &lt;&lt; i;//输出后次数减一并终止循环<br>            a[i]–;<br>            break;<br>        }<br>    for ( i=0; i&lt;a[0]; i++ )<br>        cout &lt;&lt; “0”;//输出所有零<br>    for ( i=1; i&lt;10; i++ )<br>        for ( j=0; j&lt;a[i]; j++ )<br>            cout &lt;&lt; i;//从小到大按其次数输出所有<br>    cout &lt;&lt; endl;<br>    return 0;<br>}</iostream></pre><br><br><span style="background-color:rgb(255,255,255)"></span></pre><br></div>
]]></content>
      <categories>
        <category>PAT</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>pat</tag>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title>Android+PHP+Mysql实现简单登录</title>
    <url>/2017/11/20/php-login-server/</url>
    <content><![CDATA[<p><img src="https://cdn.fayne.cn/20bf8aa42b022f110cd98f0c87a760e2.png" alt="android-login"></p>
<a id="more"></a>
<p>最近做一个项目需要实现登录功能，感觉Java实现起来太麻烦了，看到有用PHP的，果断用起来，还是很方便</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>因为是本地实验，所以用的XAMPP</li>
<li>Android Studio 3.0</li>
<li>HBuilder，主要是方便写php代码</li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>用的mysql，新建了一个数据库testlogin，然后新建了表user，结构如下<br><img src="https://cdn.fayne.cn/da938ff7a22313577e4b563ef1a154a9.png" alt="mysql"></p>
<h3 id="搭建PHP服务器"><a href="#搭建PHP服务器" class="headerlink" title="搭建PHP服务器"></a>搭建PHP服务器</h3><p>主要是负责接收android端的账号密码，通过查询操作mysql表<br>首先在HBuilder中新建了一个WBE项目，然后新建了一个conn.php，用于连接数据库<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$dbhost = <span class="string">"localhost:3306"</span>;</span><br><span class="line">	$dbuser=<span class="string">"root"</span>;</span><br><span class="line">	$dbpass=<span class="string">""</span>;</span><br><span class="line">	$dbname=<span class="string">"testlogin"</span>;</span><br><span class="line">	$conn = mysql_connect($dbhost, $dbuser, $dbpass) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"connect error"</span>);</span><br><span class="line">	@mysql_select_db($dbname) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"db error"</span>);</span><br><span class="line">	mysql_query(<span class="string">"set names 'UTF-8'"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后新建login.php用于接收表单数据并返回json数据<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">include</span>(<span class="string">'conn.php'</span>);</span><br><span class="line">  $name = str_replace(<span class="string">" "</span>, <span class="string">""</span>, $_POST[<span class="string">'username'</span>]);</span><br><span class="line">  $sql = <span class="string">"select * from user where '$name' = username"</span>;</span><br><span class="line">  $query = mysql_query($sql);</span><br><span class="line">  $result = mysql_fetch_array($query);</span><br><span class="line">  $response = <span class="keyword">array</span>();</span><br><span class="line">  <span class="keyword">if</span> (is_array($result)) &#123;</span><br><span class="line">  	<span class="keyword">if</span> ($_POST[<span class="string">'password'</span>] == $result[<span class="string">'password'</span>]) &#123;</span><br><span class="line">  		$response[<span class="string">'success'</span>] = <span class="number">1</span>;</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  		$response[<span class="string">'success'</span>] = <span class="number">0</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">echo</span> json_encode($response);</span><br><span class="line">  &#125;</span><br><span class="line">  mysql_close($conn);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Android客户端"><a href="#Android客户端" class="headerlink" title="Android客户端"></a>Android客户端</h3><p>首先新建一个登录Acticity，布局如下，再新建一个Activity，用于登录成功跳转</p>
<p><img src="https://cdn.fayne.cn/87ab07e394fe1b5a11f75c639dbf0a1d.png" alt="login"></p>
<p>我这里的布局代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/email_login_form"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.TextInputLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/et_username"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:maxLines</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.TextInputLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.TextInputLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/et_password"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">"@string/prompt_password"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeActionId</span>=<span class="string">"6"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeActionLabel</span>=<span class="string">"@string/action_sign_in_short"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:imeOptions</span>=<span class="string">"actionUnspecified"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:inputType</span>=<span class="string">"textPassword"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:maxLines</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:singleLine</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.TextInputLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_login"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"?android:textAppearanceSmall"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/action_sign_in"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textStyle</span>=<span class="string">"bold"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来主要是要发送Post请求，这里用到了外部库<code>volley</code>，在app/gradle中dependencies中添加<br><code>compile group: &#39;com.mcxiaoke.volley&#39;, name: &#39;library&#39;, version: &#39;1.0.19&#39;</code>就好了</p>
<p>一开始使用<code>volley</code>时死活下不到jar包，还是gradle方便多了，推荐个网站<a href="http://mvnrepository.com/" target="_blank" rel="noopener">传送门</a>，这里能找到你想要的</p>
<p>最后是LoginActivity代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UI references.</span></span><br><span class="line">    <span class="keyword">private</span> EditText mUsername;</span><br><span class="line">    <span class="keyword">private</span> EditText mPassword;</span><br><span class="line">    <span class="keyword">private</span> View mLogin;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line">        mUsername = findViewById(R.id.et_username);</span><br><span class="line">        mPassword = findViewById(R.id.et_password);</span><br><span class="line">        mLogin = findViewById(R.id.btn_login);</span><br><span class="line">        mLogin.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> LoginHandle().run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LoginHandle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> String username = mUsername.getText().toString();</span><br><span class="line">            <span class="keyword">final</span> String password = mPassword.getText().toString();</span><br><span class="line">            String connectUrl = <span class="string">"http://10.0.2.2/PhpLoginDemo/login.php"</span>;</span><br><span class="line">            RequestQueue requestQueue = Volley.newRequestQueue(LoginActivity.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            Response.Listener&lt;String&gt; listener = <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                    String TAG = <span class="string">"LOGIN"</span>;</span><br><span class="line">                    Log.e(TAG, s);</span><br><span class="line">                    <span class="keyword">int</span> retCode = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(s);</span><br><span class="line">                        retCode = jsonObject.getInt(<span class="string">"success"</span>);</span><br><span class="line">                        Log.d(<span class="string">"retCode"</span>, retCode+<span class="string">""</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (retCode == <span class="number">1</span>) &#123;</span><br><span class="line">                        startActivity(<span class="keyword">new</span> Intent(LoginActivity.<span class="keyword">this</span>, MainActivity.class));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Toast.makeText(LoginActivity.<span class="keyword">this</span>,<span class="string">"用户名或密码错误!"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Response.ErrorListener errorListener = <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">                <span class="keyword">public</span> String TAG = <span class="string">"LOG"</span>;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">                    Log.e(TAG, error.getMessage(), error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.POST, connectUrl, listener, errorListener) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> Map&lt;String, String&gt; <span class="title">getParams</span><span class="params">()</span> <span class="keyword">throws</span> AuthFailureError </span>&#123;</span><br><span class="line">                    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">"username"</span>, username);</span><br><span class="line">                    map.put(<span class="string">"password"</span>, password);</span><br><span class="line">                    <span class="keyword">return</span> map;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            requestQueue.add(stringRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后不要忘记在Manifest中申明权限<br><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></p>
<h2 id="收工"><a href="#收工" class="headerlink" title="收工"></a>收工</h2><p>至此，一个简单的Android登录功能就实现了，附上效果<br><img src="https://cdn.fayne.cn/record.gif" alt="record"></p>
<p><a href="https://github.com/Finhoo/LoginDemo.git" target="_blank" rel="noopener">项目地址</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>NYOJ-56 阶乘因式分解（一）</title>
    <url>/2015/11/28/nyoj-56-e9-98-b6-e4-b9-98-e5-9b-a0-e5-bc-8f-e5-88-86-e8-a7-a3-ef-bc-88-e4-b8-80-ef-bc-89/</url>
    <content><![CDATA[<div class="problem-display" style="font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun"><br><br>##<br>阶乘因式分解（一）<br><br><div class="problem-ins" style="text-align:center">时间限制：<span class="editable highlight" id="problem[time_limit]" style="color:rgb(113,32,21)">3000</span>&nbsp;ms &nbsp;|&nbsp; 内存限制：<span class="editable highlight" id="problem[memory_limit]" style="color:rgb(113,32,21)">65535</span>&nbsp;KB</div><br><div class="problem-ins" style="text-align:center">难度：<span class="editable highlight" style="color:rgb(113,32,21)">2</span></div><br></div>

<div class="clr" style="clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19.5px"><br></div>

<dl class="problem-display" style="margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun"><br><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold"><br>描述</dt><dd style="margin:0px; padding:0px"><span style="color:rgb(255,255,0); font-size:12px"></span><br><br><span style="font-weight:bold"><span style="color:rgb(76,51,229); background-color:rgb(255,255,255)"><span style="color:rgb(255,255,0)"><strong><span style="background-color:rgb(0,0,0)"><strong><strong><span style="color:rgb(0,0,0); background-color:rgb(255,255,255)">给定两个数m,n,其中m是一个素数。</span></strong></strong></span></strong></span></span></span><br><br><span style="color:rgb(0,0,0)"></span><span style="color:rgb(0,0,0)"></span><strong><span style="color:rgb(0,0,0)"></span></strong><br><br><span style="font-size:12px"><strong><span style="color:rgb(0,0,0)">将n（0&lt;=n&lt;=10000）的阶乘分解质因数，求其中有多少个m。</span></strong></span><br><a id="more"></a><br><div class="clr" style="clear:both"></div><br><dl class="others" style="margin:0px; padding:0px"><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold"><br>输入</dt><dd style="margin:0px; padding:0px">第一行是一个整数s（0&lt;s&lt;=100)，表示测试数据的组数<br><br>随后的s行, 每行有两个整数n，m。</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold"><br>输出</dt><dd style="margin:0px; padding:0px">输出m的个数。</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold"><br>样例输入</dt><dd style="margin:0px; padding:0px"><br><pre id="sample_input" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)">2<br>100 5<br>16 2<br></pre><br></dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold"><br>样例输出</dt><dd style="margin:0px; padding:0px"><br><pre id="sample_output" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em; background:rgb(239,239,239)">24<br>15<br></pre><br></dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold"><br>来源</dt><dd style="margin:0px; padding:0px"><a href="http://acm.nyist.net/JudgeOnline/search_result.php?source=%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">网络</a></dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold"><br>上传者<br><br><a href="http://acm.nyist.net/JudgeOnline/profile.php?userid=%E8%8B%97%E6%A0%8B%E6%A0%8B" target="_blank" rel="noopener">苗栋栋</a><br><br><pre name="code" class="cpp">#include <iostream><br><br>using namespace std;<br><br>int f(int n, int m)<br>{<br>    return n &lt; m ? 0 : f(n / m, m) + n / m;<br>}<br><br>int main()<br>{<br>    int t;<br>    cin &gt;&gt; t;<br>    while (t–)<br>    {<br>        int n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        cout &lt;&lt; f(n, m) &lt;&lt; endl;<br>    }<br>    return 0;<br>}</iostream></pre><br><br></dt></dl><br></dd></dl>
]]></content>
      <categories>
        <category>NYOJ</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>nyoj</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1861-NETWORK 解题报告</title>
    <url>/2017/04/13/poj-1861-network-e8-a7-a3-e9-a2-98-e6-8a-a5-e5-91-8a/</url>
    <content><![CDATA[<div class="ptt" lang="en-US" style="text-align:center; font-size:18pt; font-weight:bold; color:blue"><br>Network</div>

<div class="plm" style="text-align:center; font-size:14px"><br><table align="center"><br><tbody><br><tr><br><td><strong>Time Limit:</strong>&nbsp;1000MS</td><br><td width="10px">&nbsp;</td><br><td colspan="3"><strong>Memory Limit:</strong>&nbsp;30000K</td><br></tr><br><tr><br><td><strong>Total Submissions:</strong>&nbsp;16628</td><br><td width="10px">&nbsp;</td><br><td><strong>Accepted:</strong>&nbsp;6597</td><br><td width="10px">&nbsp;</td><br><td style="font-weight:bold; color:red">Special Judge</td><br></tr><br></tbody><br></table><br></div>

<p>Description</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>Andrew is working as system administrator and is planning to establish a new network in his company. There will be N hubs in the company, they can be connected to each other using cables. Since each worker of the company must have access to the whole network,<br> each hub must be accessible by cables from any other hub (with possibly some intermediate hubs).&nbsp;<br><br>Since cables of different types are available and shorter ones are cheaper, it is necessary to make such a plan of hub connection, that the maximum length of a single cable is minimal. There is another problem — not each hub can be connected to any other one<br> because of compatibility problems and building geometry limitations. Of course, Andrew will provide you all necessary information about possible hub connections.&nbsp;<br><br>You are to help Andrew to find the way to connect hubs so that all above conditions are satisfied.&nbsp;<br><br>

<p>Input<br><a id="more"></a></p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>The first line of the input contains two integer numbers: N - the number of hubs in the network (2 &lt;= N &lt;= 1000) and M - the number of possible hub connections (1 &lt;= M &lt;= 15000). All hubs are numbered from 1 to N. The following M lines contain information about<br> possible connections - the numbers of two hubs, which can be connected and the cable length required to connect them. Length is a positive integer number that does not exceed 10<sup>6</sup>. There will be no more than one way to connect two hubs. A hub cannot<br> be connected to itself. There will always be at least one way to connect all hubs.

<p>Output</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>Output first the maximum length of a single cable in your hub connection plan (the value you should minimize). Then output your plan: first output P - the number of cables used, then output P pairs of integer numbers - numbers of hubs connected by the corresponding<br> cable. Separate numbers by spaces and/or line breaks.

<p>Sample Input</p>
<pre class="sio" style="font-family:" courier new",courier,monospace; font-size:14px">4 6
1 2 1
1 3 1
1 4 2
2 3 1
3 4 1
2 4 1
</pre>

<p>Sample Output</p>
<pre class="sio" style="font-family:" courier new",courier,monospace; font-size:14px">1
4
1 2
1 3
2 3
3 4
</pre>

<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=Northeastern+Europe+2001" target="_blank" rel="noopener">Northeastern Europe 2001</a>, Northern Subregion</p>
<p><span style="color:#ff0000">好久没有更新这个博客，觉得自己还是不够努力，自己的acm学习之路的脚步走的很慢，希望尽快改变现状吧。这道题考察kruskal算法，留下个记录</span></p>
<p><span style="color:#ff0000">题解：题目大意是有n个顶点，m条边，使图连通，使边权和最小，不构成回路</span></p>
<p><span style="color:#ff0000">kruskal算法：按边权从小到到排序，顺序将边加入图中，若图中两点不连通则加入，否则就不考虑，（判断两点是否在图中中并查集，并查集的主要功能就是合并和查找的功能），最终就可以解答此题，找到最小的边权的连通图。</span></p>
<p><span style="color:#ff0000">初始化并查集f[]数组（f中每个数等于下标值）find(x),</span></p>
<p><span style="color:#ff0000">查找x的祖先，若x!=find(x)则find(find(x))，递归操作即可</span></p>
<p><span style="color:#ff0000">合并操作，union(x,y) 若两个是不同的祖先则合并。</span></p>
<pre code_snippet_id="2331433" snippet_file_name="blog_20170413_1_6876556" name="code" class="cpp">#include <stdio.h>
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const int maxn = 1e6+7;

int father[maxn];

int n, m, c = 1;
struct _edge{
    int x, y, d;
}edge[maxn], ans[maxn];

bool cmp(_edge a, _edge b)
{
    return a.d < b.d;
}

int fi(int x)
{
    return x == father[x] ? x : father[x] = fi(father[x]);
}

void union1(int x, int y)
{
    int p1 = fi(x), p2 = fi(y);
    if (p1 == p2) return;
    father[p1] = p2;
}

int check(int x, int y)
{
    int p = fi(x), q = fi(y);
    if (p == q)
        return 1;
    return 0;
}

void init()
{
    for (int i=0; i<=n; i++) father[i]="i;" } void kruskal() { for (int i="1;" i<="m;" int x="edge[i].x;" y="edge[i].y;" if (fi(x) !="fi(y))" union1(x, y); ans[c].x="x;" ans[c].y="y;" ans[c].d="edge[i].d;" c++; main() x, y; scanf("%d%d", &n, &m); init(); scanf("%d%d%d", &edge[i].x, &edge[i].y, &edge[i].d); sort(edge+1, edge+m+1, cmp); kruskal(); printf("%d\n", ans[c-1].d); c-1); i<c; printf("%d %d\n", ans[i].x, ans[i].y); return 0; < pre>
</=n;></algorithm></cstdio></iostream></stdio.h></pre>]]></content>
      <categories>
        <category>POJ</category>
        <category>并查集</category>
        <category>最小生成树</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2479 Maximum sum 解题报告</title>
    <url>/2017/04/15/poj2479maximumsum-e8-a7-a3-e9-a2-98-e6-8a-a5-e5-91-8a/</url>
    <content><![CDATA[<div class="ptt" lang="en-US" style="text-align: center; font-size: 18pt; font-weight: bold; color: blue;">Maximum sum</div>

<div class="plm" style="text-align: center; font-size: 14px;"><br><table align="center"><br><tbody><br><tr><br><td><strong>Time Limit:</strong> 1000MS</td><br><td width="10px"></td><br><td><strong>Memory Limit:</strong> 65536K</td><br></tr><br><tr><br><td><strong>Total Submissions:</strong> 40596</td><br><td width="10px"></td><br><td><strong>Accepted:</strong> 12663</td><br></tr><br></tbody><br></table><br></div>

<p>Description</p>
<div class="ptx" lang="en-US">Given a set of n integers: A={a1, a2,…, an}, we define a function d(A) as below:<br>&gt; <img src="i" alt><br>Your task is to calculate d(A).<br><br></div>

<p>Input</p>
<div class="ptx" lang="en-US">The input consists of T(&lt;=30) test cases. The number of test cases (T) is given in the first line of the input.<br>Each test case contains two lines. The first line is an integer n(2&lt;=n&lt;=50000). The second line contains n integers: a1, a2, …, an. (|ai| &lt;= 10000).There is an empty line after each case.</div>

<p>Output</p>
<div class="ptx" lang="en-US">Print exactly one line for each test case. The line should contain the integer d(A).</div>

<p>Sample Input</p>
<pre class="sio" courier new monospace font-size:14px>1

10
1 -1 2 2 3 -3 4 -4 5 -5</pre>

<p>Sample Output</p>
<pre class="sio" courier new monospace font-size:14px>13</pre>

<p>Hint<br><a id="more"></a></p>
<div class="ptx" lang="en-US">In the sample, we choose {2,2,3,-3,4} and {5}, then we can get the answer.Huge input,scanf is recommended.<br><br></div>

<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=POJ+Contest" target="_blank" rel="noopener">POJ Contest</a>,Author:Mathematica@ZSU</p>
<p><span style="color: #ff0000;">题目大意：给定一个整数数字序列s，要求使两段不相交的子序列s1,s2的和最大</span></p>
<p><span style="color: #ff0000;">题解：动态规划</span></p>
<p><span style="color: #ff0000;">ls[i]表示以第i个元素结尾序列的最大值</span></p>
<p><span style="color: #ff0000;">rs[i]表示以第i个元素开始序列的最大值</span></p>
<p><span style="color: #ff0000;">rst[i]表示取i个元素能够达到的最大值</span></p>
<p><span style="color: #ff0000;">所以有</span></p>
<p><span style="color: #ff0000;">ls[i]=max(ls[i-1]+a[i], a[i]),  rs[i]=max(rs[i+1]+a[i], a[i])</span></p>
<p><span style="color: #ff0000;">rst[i]=max(rst(i+1), rs[i])</span></p>
<p><span style="color: #ff0000;">所以最后的答案是s=max(s, ls[i]+rst(i+1))</span></p>
<p>&nbsp;</p>
<pre code_snippet_id="2334861" snippet_file_name="blog_20170415_1_249662" name="code" class="cpp">#include
#include
#include
#include

using namespace std;

const int maxn = 1e6+7, inf = -1e6+7;

int a[maxn], ls[maxn], rs[maxn], s, rst[maxn];

int main()
{
    int t, n;
    scanf("%d", &amp;t);
    while (t--)
    {
        s = 0;
        memset(ls, 0, sizeof(ls));
        memset(rs, 0, sizeof(rs));
        memset(rst, 0, sizeof(rst));
        scanf("%d", &amp;n);
        for (int i=0; i&lt;n; i++)
            scanf("%d", &amp;a[i]);
        ls[0] = a[0];
        for (int i=1; i&lt;n; i++) { ls[i] = max(ls[i-1]+a[i], a[i]); } rst[n-1] = rs[n-1] = a[n-1]; for (int i=n-2; i&gt;=0; i--){
            rs[i] = max(rs[i+1]+a[i], a[i]);
            rst[i] = max(rst[i+1], rs[i]);
        }
        s = inf;
        for (int i=0; i&lt;n-1; i++) {
            s = max(s, ls[i]+rst[i+1]);
        }
        printf("%d\n", s);
    }
    return 0;
}
</pre>
]]></content>
      <categories>
        <category>POJ</category>
        <category>动态规划</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1308 Is It A Tree? 解题报告</title>
    <url>/2017/04/13/poj1308isitatree-e8-a7-a3-e9-a2-98-e6-8a-a5-e5-91-8a/</url>
    <content><![CDATA[<div class="ptt" lang="en-US" style="text-align:center; font-size:18pt; font-weight:bold; color:blue"><br>Is It A Tree?</div>

<div class="plm" style="text-align:center; font-size:14px"><br><table align="center"><br><tbody><br><tr><br><td><strong>Time Limit:</strong>&nbsp;1000MS</td><br><td width="10px">&nbsp;</td><br><td><strong>Memory Limit:</strong>&nbsp;10000K</td><br></tr><br><tr><br><td><strong>Total Submissions:</strong>&nbsp;32052</td><br><td width="10px">&nbsp;</td><br><td><strong>Accepted:</strong>&nbsp;10876</td><br></tr><br></tbody><br></table><br></div>

<p>Description</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>A tree is a well-known data structure that is either empty (null, void, nothing) or is a set of one or more nodes connected by directed edges between nodes satisfying the following properties.&nbsp;<br><br>There is exactly one node, called the root, to which no directed edges point.&nbsp;<br><br>Every node except the root has exactly one edge pointing to it.&nbsp;<br><br>There is a unique sequence of directed edges from the root to each node.&nbsp;<br><br>For example, consider the illustrations below, in which nodes are represented by circles and edges are represented by lines with arrowheads. The first two of these are trees, but the last is not.&nbsp;<br><br><center><img src="http://poj.org/images/1308_1.jpg" alt></center><br><br>In this problem you will be given several descriptions of collections of nodes connected by directed edges. For each of these you are to determine if the collection satisfies the definition of a tree or not.

<p>Input</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers;<br> the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero.

<p>Output</p>
<p>&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>For each test case display the line “Case k is a tree.” or the line “Case k is not a tree.”, where k corresponds to the test case number (they are sequentially numbered starting with 1).<br><a id="more"></a><br>Sample Input</p>
<pre class="sio" style="font-family:" courier new",courier,monospace; font-size:14px">6 8  5 3  5 2  6 4
5 6  0 0

8 1  7 3  6 2  8 9  7 5
7 4  7 8  7 6  0 0

3 8  6 8  6 4
5 3  5 6  5 2  0 0
-1 -1</pre>

<p>Sample Output</p>
<pre class="sio" style="font-family:" courier new",courier,monospace; font-size:14px">Case 1 is a tree.
Case 2 is a tree.
Case 3 is not a tree.</pre>

<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=North+Central+North+America+1997" target="_blank" rel="noopener">North Central North America 1997</a></p>
<p><span style="color:#ff0000">再写一题，顺便巩固一下并查集基础，poj1182还没想好，先写了这题吧</span></p>
<p><span style="color:#ff0000">题解：这道题的意思是判断给定的边是否构成一颗树，注意不能是森林，我这里用的并查集的方法，每次输入x,y两个点就合并x,y，但是在处理判断是否为森林时感觉处理的不好，我是逐个判断是不是有相同的父亲结点来处理的，感觉优化的不是很好，好在AC了。</span></p>
<pre code_snippet_id="2331633" snippet_file_name="blog_20170414_1_222141" name="code" class="cpp">#include <iostream>
#include <cstdio>
#include <vector>

const int maxn = 1e6+7;

using namespace std;

int father[maxn], n;

void init()
{
    for (int i=0; i<=maxn; i++) father[i]="i;" } int fi(int x) { return x="=" father[x] ? : void unite(int x, y) p1="fi(x)," p2="fi(y);" if (p1="=" p2) return; father[p1]="p2;" same(int 1; 0; main() a, b; c="1;" vector<int> v;
    init();bool judge = true;
    while (~scanf("%d%d", &a, &b))
    {
        if (a == -1 && b == -1) break;
        if (a == 0 && b == 0) {
            for (int i=0; i<v.size(); i++) { for (int j="i+1;" j<v.size(); j++) 判断是否构成森林 if (i !="j" && v[i] !same(v[i], v[j])) judge="false;" break; } (!judge) (judge) printf("case %d is a tree.\n", c); else not c++; init(); v.clear(); }else v.push_back(a); v.push_back(b); (!same(a, b)) 判断是否构成回路或者环 unite(a, b); return 0; < pre>
</v.size();></=maxn;></vector></cstdio></iostream></pre>]]></content>
      <categories>
        <category>POJ</category>
        <category>并查集</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2524 Ubiquitous Religions 解题报告</title>
    <url>/2017/04/13/poj2524ubiquitousreligions-e8-a7-a3-e9-a2-98-e6-8a-a5-e5-91-8a/</url>
    <content><![CDATA[<div class="ptt" lang="en-US" style="text-align: center; font-size: 18pt; font-weight: bold; color: blue;">Ubiquitous Religions</div>

<div class="plm" style="text-align: center; font-size: 14px;"><br><table align="center"><br><tbody><br><tr><br><td><strong>Time Limit:</strong> 5000MS</td><br><td width="10px"></td><br><td><strong>Memory Limit:</strong> 65536K</td><br></tr><br><tr><br><td><strong>Total Submissions:</strong> 34122</td><br><td width="10px"></td><br><td><strong>Accepted:</strong> 16477</td><br></tr><br></tbody><br></table><br></div>

<p>Description</p>
<div class="ptx" lang="en-US">There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask<br>m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound<br>of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.<br><br></div>

<p>Input</p>
<div class="ptx" lang="en-US">The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The<br>end of input is specified by a line in which n = m = 0.</div>

<p>Output<br><a id="more"></a></p>
<div class="ptx" lang="en-US">For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.</div>

<p>Sample Input</p>
<pre class="sio" courier new monospace font-size:14px>10 9
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
10 4
2 3
4 5
4 8
5 8
0 0
</pre>

<p>Sample Output</p>
<pre class="sio" courier new monospace font-size:14px>Case 1: 1
Case 2: 7
</pre>

<p>Hint</p>
<div class="ptx" lang="en-US">Huge input, scanf is recommended.</div>

<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=Alberta+Collegiate+Programming+Contest+2003.10.18" target="_blank" rel="noopener">Alberta Collegiate Programming Contest 2003.10.18</a></p>
<p><span style="color: #ff0000;">题解</span></p>
<p><span style="color: #ff0000;">再来并查集，作为并查集学习的专题吧，这这道题考察连通块的个数，道题较为基础，每次合并的时候加入计数一次就好，但是要是没加到图里面的点才能计数，这样直接用总的点数减去它即可得到连通块的个数</span></p>
<p>&nbsp;</p>
<pre code_snippet_id="2331635" snippet_file_name="blog_20170414_1_9118115" name="code" class="cpp">#include
#include

const int maxn = 1e6+7;

using namespace std;

int father[maxn];
int cnt = 0;

void init()
{
    cnt = 0;
    for (int i=0; i&lt;maxn; i++)
        father[i] = i;
}

int fi(int x)
{
    return x == father[x] ? x : father[x] = fi(father[x]);
}

void unite(int x, int y)
{
    int p1 = fi(x), p2 = fi(y);
    if (p1 == p2) return;
    father[p1] = p2;
    cnt++;
}

bool same(int x, int y)
{
    if (fi(x) == fi(y))
        return true;
    return false;
}

int main()
{
    int n, m, a, b, c = 1;
    while (~scanf("%d%d", &amp;n ,&amp;m))
    {
        init();
        if (n == 0 &amp;&amp; m == 0) break;
        while (m--)
        {
            scanf("%d%d", &amp;a, &amp;b);
            unite(a, b);
        }

        printf("Case %d: %d\n", c++, n-cnt);
    }
    return 0;
}
</pre>
]]></content>
      <categories>
        <category>POJ</category>
        <category>并查集</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2593 Max Sequence</title>
    <url>/2017/04/15/poj2593maxsequence/</url>
    <content><![CDATA[<div class="ptt" lang="en-US" style="text-align:center; font-size:18pt; font-weight:bold; color:blue"><br>Max Sequence</div>

<div class="plm" style="text-align:center; font-size:14px"><br><table align="center"><br><tbody><br><tr><br><td><strong>Time Limit:</strong>&nbsp;3000MS</td><br><td width="10px">&nbsp;</td><br><td><strong>Memory Limit:</strong>&nbsp;65536K</td><br></tr><br><tr><br><td><strong>Total Submissions:</strong>&nbsp;17678</td><br><td width="10px">&nbsp;</td><br><td><strong>Accepted:</strong>&nbsp;7401</td><br></tr><br></tbody><br></table><br></div>

<p>Description</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>Give you N integers a1, a2 … aN (|ai| &lt;=1000, 1 &lt;= i &lt;= N).&nbsp;<br><br><center><img src="http://poj.org/images/2593_1.jpg" alt></center><br><br>You should output S.&nbsp;<br><br>

<p>Input</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>The input will consist of several test cases. For each test case, one integer N (2 &lt;= N &lt;= 100000) is given in the first line. Second line contains N integers. The input is terminated by a single line with N = 0.

<p>Output</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>For each test of the input, print a line containing S.

<p>Sample Input</p>
<pre class="sio" style="font-family:" courier new",courier,monospace; font-size:14px">5
-5 9 -5 11 20
0
</pre>

<p>Sample Output</p>
<pre class="sio" style="font-family:" courier new",courier,monospace; font-size:14px">40</pre>

<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=POJ+Monthly--2005.08.28" target="_blank" rel="noopener">POJ Monthly–2005.08.28</a>,Li Haoyuan</p>
<p><span style="color:#ff0000">题解：这个题2479差不多，具体可以看2479的题解，不过感觉这道题的测试数据要比2479弱一些，轻松AC</span></p>
<p><span style="color:#ff0000">//主要是刷几道dp练练手</span><br><a id="more"></a></p>
<pre code_snippet_id="2334914" snippet_file_name="blog_20170415_1_5894770" name="code" class="cpp">#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int maxn = 1e6+7, inf = -1e9+7;
int a[maxn], ls[maxn], rs[maxn], rst[maxn], s;

int main()
{
    int n;
    while (~scanf("%d", &n) && n)
    {
        for (int i=0; i<n; i++) scanf("%d", &a[i]); ls[0]="a[0]," rs[n-1]="rst[n-1]" = a[n-1], s="inf;" for (int i="1;" i<n; ls[i]="max(ls[i-1]+a[i]," a[i]);>=0; i--)
            rs[i] = max(rs[i+1]+a[i], a[i]),
            rst[i] = max(rst[i+1], rs[i]);
        for (int i=1; i<n; i++) s="max(s," ls[i-1]+rst[i]); printf("%d\n", s); } return 0; < pre>
</n;></n;></cstring></cstdio></iostream></pre>]]></content>
      <categories>
        <category>POJ</category>
        <category>动态规划</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1182 食物链 -- 解题报告</title>
    <url>/2017/04/15/poj1182-e9-a3-9f-e7-89-a9-e9-93-be-e8-a7-a3-e9-a2-98-e6-8a-a5-e5-91-8a/</url>
    <content><![CDATA[<div class="ptt" lang="en-US" style="text-align:center; font-size:18pt; font-weight:bold; color:blue"><br>食物链</div>

<div class="plm" style="text-align:center; font-size:14px"><br><table align="center"><br><tbody><br><tr><br><td><strong>Time Limit:</strong>&nbsp;1000MS</td><br><td width="10px">&nbsp;</td><br><td><strong>Memory Limit:</strong>&nbsp;10000K</td><br></tr><br><tr><br><td><strong>Total Submissions:</strong>&nbsp;70529</td><br><td width="10px">&nbsp;</td><br><td><strong>Accepted:</strong>&nbsp;20875</td><br></tr><br></tbody><br></table><br></div>

<p>Description</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。&nbsp;<br><br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。&nbsp;<br><br>有人用两种说法对这N个动物所构成的食物链关系进行描述：&nbsp;<br><br>第一种说法是”1 X Y”，表示X和Y是同类。&nbsp;<br><br>第二种说法是”2 X Y”，表示X吃Y。&nbsp;<br><br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。&nbsp;<br><br>1） 当前的话与前面的某些真的话冲突，就是假话；&nbsp;<br><br>2） 当前的话中X或Y比N大，就是假话；&nbsp;<br><br>3） 当前的话表示X吃X，就是假话。&nbsp;<br><br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。&nbsp;<br><br>

<p>Input<br><a id="more"></a></p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>第一行是两个整数N和K，以一个空格分隔。&nbsp;<br><br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。&nbsp;<br><br>若D=1，则表示X和Y是同类。&nbsp;<br><br>若D=2，则表示X吃Y。

<p>Output</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br>只有一个整数，表示假话的数目。

<p>Sample Input</p>
<pre class="sio" style="font-family:" courier new",courier,monospace; font-size:14px">100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
</pre>

<p>Sample Output</p>
<pre class="sio" style="font-family:" courier new",courier,monospace; font-size:14px">3</pre>

<p>Source</p>
&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><a href="http://poj.org/searchproblem?field=source&amp;key=Noi+01" target="_blank" rel="noopener">Noi 01</a>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">写在前面</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">——————————-</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">此题为经典并查集，考察的较为全面，这道题算是做了很久都没有思路的类型，之前看别人的博客都不是很理解他们的思路，都是要找规律的，不太懂，并且提交了几次都WA了。看了《挑战程序设计竞赛》中的解方案，豁然开朗，感觉清晰了很多，值得推荐</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">题解</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">——————————-</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">此题的解决方案是对于每只动物创建3个元素，i-A，i-B，i-C，并用3*N个元素创建并查集。</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">i-x表示“i属于种类x”</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">并查集里的每一组表示组内所有元素代表的情况同时发生或者不发生</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000"><br><br></span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">第一种：x和y属于同一个种类——–合并x-A和y-A，&lt;span style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;x-B和y-B，</span>&lt;span style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;x-C和y-C。

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">第二种：x和y属于不同的种类——–合并x-A和y-B，x-B和y-C，x-C和y-A。</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000"><br><br></span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><span style="color:#ff0000">p.s.在合并之前，需要判断合并是否产生矛盾</span>

&lt;div class=”ptx” lang=”en-US” style=”font-family:”Times New Roman”,Times,serif; font-size:14px”&gt;<br><pre code_snippet_id="2335055" snippet_file_name="blog_20170416_1_2108272" name="code" class="cpp">#include <iostream><br>#include <cstdio><br><br>const int maxn = 1e6+7;<br><br>int N, K;<br>int par[maxn], rank[maxn];<br>int T[maxn], X[maxn], Y[maxn];<br><br>void init(int n)<br>{<br>    for (int i=0; i&lt;=n; i++)<br>        par[i] = i,<br>        rank[i] = 0;<br>}<br><br>int find(int x)<br>{<br>    return x == par[x] ? x : par[x] = find(par[x]);<br>}<br><br>void unite(int x, int y)<br>{<br>    x = find(x);<br>    y = find(y);<br>    if (x == y) return;<br>    if (rank[x] &lt; rank[y])<br>        par[x] = y;<br>    else<br>        par[y] = x;<br>    if (rank[x] == rank[y])<br>        rank[x]++;<br>}<br><br>bool same(int x, int y)<br>{<br>    return find(x) == find(y);<br>}<br><br>void solve()<br>{<br>    init(N<em>3);<br>    int ans = 0;<br>    for (int i=0; i&lt;K; i++)<br>    {<br>        int t = T[i];<br>        int x = X[i], y = Y[i];<br>        if (x &lt; 1 || y &lt; 1 || x &gt; N || y &gt; N) {<br>            ans++;<br>            continue;<br>        }<br>        if (t == 1) {<br>            if (same(x, y+N) || same(x, y+2</em>N))<br>                ans++;<br>            else{<br>                unite(x, y);<br>                unite(x+N, y+N);<br>                unite(x+2<em>N, y+2</em>N);<br>            }<br>        }<br>        else {<br>            if (same(x, y) || same(x, y+2<em>N))<br>                ans++;<br>            else {<br>                unite(x, y+N);<br>                unite(x+N, y+2</em>N);<br>                unite(x+2*N, y);<br>            }<br>        }<br>    }<br>    printf(“%d\n”, ans);<br>}<br><br>int main()<br>{<br>    scanf(“%d%d”, &amp;N, &amp;K);<br>    for (int i=0; i&lt;K; i++) {<br>        scanf(“%d%d%d”, &amp;T[i], &amp;X[i], &amp;Y[i]);<br>    }<br>    solve();<br>    return 0;<br>}<br></cstdio></iostream></pre><br><br>
]]></content>
      <categories>
        <category>POJ</category>
        <category>并查集</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Section 1.1 Your Ride Is Here</title>
    <url>/2015/10/06/section1-1yourrideishere/</url>
    <content><![CDATA[<center>

<h1 id="Your-Ride-Is-Here"><a href="#Your-Ride-Is-Here" class="headerlink" title="Your Ride Is Here"></a>Your Ride Is Here</h1><p></p></center><br>It is a well-known fact that behind every good comet is a UFO. TheseUFOs often come to collect loyal supporters from here on Earth.Unfortunately, they only have room to pick up one group of followers oneach trip. They do, however, let the groups know ahead<br> of time whichwill be picked up for each comet by a clever scheme: they pick a namefor the comet which, along with the name of the group, can be used todetermine if it is a particular group’s turn to go (who do you thinknames the comets?). The details of the<br> matching scheme are given below;your job is to write a program which takes the names of a group and acomet and then determines whether the group should go with the UFO behindthat comet.<p></p>
<p>Both the name of the group and the name of the comet are converted intoa number in the following manner: the final number is just the product ofall the letters in the name, where “A” is 1 and “Z” is26. For instance, the group “USACO” would be 21 <em> 19 </em> 1</p>
<ul>
<li>3 *15 = 17955. If the group’s number mod 47 is the same as the comet’s numbermod 47, then you need to tell the group to get ready! (Remember that”a mod b” is the remainder left over after dividing a by b; 34mod 10 is 4.)</li>
</ul>
<p>Write a program which reads in the name of the comet and the name ofthe group and figures out whether according to the above scheme the namesare a match, printing “GO” if they match and “STAY” ifnot. The names of the groups and the comets will be a string<br> of capitalletters with no spaces or punctuation, up to 6 characters long.</p>
<p>Examples:</p>
<table border="1"><br><tbody><br><tr><br><td align="center">Input</td><br><td align="center">Output</td><br></tr><br><tr><br><td><br><pre>COMETQ<br>HVNGAT<br></pre><br></td><br><td align="center" valign="Center"><tt>GO</tt></td><br></tr><br><tr><br><td><br><pre>ABSTAR<br>USACO </pre><br></td><br><td align="center" valign="Center"><tt>STAY </tt></td><br></tr><br></tbody><br></table>

<h3 id="PROGRAM-NAME-ride"><a href="#PROGRAM-NAME-ride" class="headerlink" title="PROGRAM NAME: ride"></a>PROGRAM NAME: ride</h3><p>This means that you fill in your header with:</p>
<tt>PROG: ride</tt>

<p><strong>WARNING:</strong> You must have ‘ride’ in this field or thewrong test data (or no test data) will be used.</p>
<h3 id="INPUT-FORMAT"><a href="#INPUT-FORMAT" class="headerlink" title="INPUT FORMAT"></a>INPUT FORMAT</h3><a id="more"></a>
<table><br><tbody><br><tr><br><td>Line 1:</td><br><td>An upper case character string of length 1..6 that is the name of the comet.</td><br></tr><br><tr><br><td>Line 2:</td><br><td>An upper case character string of length 1..6 that is the name of the group.</td><br></tr><br></tbody><br></table>

<p><strong>NOTE</strong>: The input file has a newline at the end of each linebut does not have a “return”. Sometimes, programmers code forthe Windows paradigm of “return” followed by “newline”; don’t dothat! Use simple input routines like “readln” (for Pascal)<br> and,for C/C++, “fscanf” and “fid&gt;&gt;string”.</p>
<p><strong>NOTE 2</strong>: Because of the extra characters, be sure to leaveenough room for a ‘newline’ (also notated as ‘\n’) and an end ofstring character (‘\0’) if your language uses it (as C and C++ do).This means you need eight characters of room instead<br> of six.</p>
<h3 id="SAMPLE-INPUT-file-ride-in"><a href="#SAMPLE-INPUT-file-ride-in" class="headerlink" title="SAMPLE INPUT (file ride.in)"></a>SAMPLE INPUT (file ride.in)</h3><pre>COMETQ
HVNGAT
</pre>

<h3 id="OUTPUT-FORMAT"><a href="#OUTPUT-FORMAT" class="headerlink" title="OUTPUT FORMAT"></a>OUTPUT FORMAT</h3><p>A single line containing either the word “GO” or the word “STAY”.</p>
<h3 id="SAMPLE-OUTPUT-file-ride-out"><a href="#SAMPLE-OUTPUT-file-ride-out" class="headerlink" title="SAMPLE OUTPUT (file ride.out)"></a>SAMPLE OUTPUT (file ride.out)</h3><pre>GO
</pre>

<h3 id="OUTPUT-EXPLANATION"><a href="#OUTPUT-EXPLANATION" class="headerlink" title="OUTPUT EXPLANATION"></a>OUTPUT EXPLANATION</h3><p>Converting the letters to numbers:</p>
<table><br><tbody><br><tr><br><td align="center"><tt>C</tt></td><br><td align="center"><tt>O</tt></td><br><td align="center"><tt>M</tt></td><br><td align="center"><tt>E</tt></td><br><td align="center"><tt>T</tt></td><br><td align="center"><tt>Q</tt></td><br><td align="center">&nbsp;</td><br></tr><br><tr><br><td align="center"><tt>3</tt></td><br><td align="center"><tt>15</tt></td><br><td align="center"><tt>13</tt></td><br><td align="center"><tt>5</tt></td><br><td align="center"><tt>20</tt></td><br><td align="center"><tt>17</tt></td><br><td align="center">&nbsp;</td><br></tr><br><tr colspan="4"><br><td>&nbsp;</td><br></tr><br><tr><br><td align="center"><tt>H</tt></td><br><td align="center"><tt>V</tt></td><br><td align="center"><tt>N</tt></td><br><td align="center"><tt>G</tt></td><br><td align="center"><tt>A</tt></td><br><td align="center"><tt>T</tt></td><br></tr><br><tr><br><td align="center"><tt>8</tt></td><br><td align="center"><tt>22</tt></td><br><td align="center"><tt>14</tt></td><br><td align="center"><tt>7</tt></td><br><td align="center"><tt>1</tt></td><br><td align="center"><tt>20</tt></td><br><td align="center">&nbsp;</td><br></tr><br></tbody><br></table>

<p>then calculate the product mod 47:</p>
<pre><tt>3 * 15 * 13 * 5 * 20 * 17 = 994500 mod 47 = 27</tt>
<tt>8 * 22 * 14 * 7 *  1 * 20 = 344960 mod 47 = 27</tt>
</pre>

<p>Because both products evaluate to 27 (when modded by 47), themission is ‘GO’.</p>
<p><span style="font-size:18px; color:#FF0000">题意很简单，用A~Z表示1~26，然后字符串所表示的各个数字相乘的结果对47取余数，两个字符串处理的结果若一样，则输出GO， 否则输出STAY</span></p>
<p><span style="font-size:18px; color:#FF0000"></span></p><p></p>
<p>&lt;</p>
<p>pre name=”code” class=”cpp”&gt;#include <iostream></iostream></p>
<p>#include <string></string></p>
<p>#include &lt;stdio.h&gt;<br>/<em><br>ID: ifayne1<br>LANG: C++<br>TASK: ride
</em>/</p>
<p>using namespace std;</p>
<p>int main()<br>{<br>    freopen(“ride.in”, “r”, stdin);<br>    freopen(“ride.out”, “w”, stdout);<br>    string s1, s2;<br>    cin &gt;&gt; s1;<br>    cin &gt;&gt; s2;<br>    int k1 = s1.length();<br>    int k2 = s2.length();<br>    long long sum1 = 1, sum2 = 1;<br>    for ( int i=0; i&lt;k1; i++ )<br>        sum1 <em>= (s1[i] - ‘A’ + 1);<br>    for ( int i=0; i&lt;k2; i++ )<br>        sum2 </em>= (s2[i] - ‘A’ + 1);</p>
<pre><code>if ( sum1 % 47 == sum2 % 47 ) cout &amp;lt;&amp;lt; &quot;GO&quot; &amp;lt;&amp;lt; endl;
else cout &amp;lt;&amp;lt; &quot;STAY&quot; &amp;lt;&amp;lt; endl;

return 0;
</code></pre><p>}</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>usaco</tag>
      </tags>
  </entry>
  <entry>
    <title>Section 1.1 Greedy Gift Givers</title>
    <url>/2015/10/06/section1-1greedygiftgivers/</url>
    <content><![CDATA[<center>

<h1 id="Greedy-Gift-Givers"><a href="#Greedy-Gift-Givers" class="headerlink" title="Greedy Gift Givers"></a>Greedy Gift Givers</h1><p></p></center><br>A group of NP (2 ≤ NP ≤ 10) uniquely named friends hasdecided to exchange gifts of money. Each of these friends might ormight not give some money to any or all of the other friends.Likewise, each friend might or might not receive money from any orall of<br> the other friends. Your goal in this problem is to deduce how much more money each person gives than they receive.<p></p>
<p>The rules for gift-giving are potentially different than youmight expect. Each person sets aside a certain amount of money togive and divides this money evenly among all those to whom he orshe is giving a gift. No fractional money is available, so dividing3<br> among 2 friends would be 1 each for the friends with 1 left over– that 1 left over stays in the giver’s “account”.</p>
<p>In any group of friends, some people are more giving than others(or at least may have more acquaintances) and some people have moremoney than others.</p>
<p>Given a group of friends, no one of whom has a name longer than14 characters, the money each person in the group spends on gifts,and a (sub)list of friends to whom each person gives gifts, determinehow much more (or less) each person in the group gives than<br> theyreceive.</p>
<h3 id="IMPORTANT-NOTE"><a href="#IMPORTANT-NOTE" class="headerlink" title="IMPORTANT NOTE"></a>IMPORTANT NOTE</h3><p>The grader machine is a Linux machine that uses standard Unixconventions: end of line is a single character often known as ‘\n’.This differs from Windows, which ends lines with two charcters,’\n’ and ‘\r’. Do not let your program get trapped by this!</p>
<h3 id="PROGRAM-NAME-gift1"><a href="#PROGRAM-NAME-gift1" class="headerlink" title="PROGRAM NAME: gift1"></a>PROGRAM NAME: gift1</h3><a id="more"></a>
<h3 id="INPUT-FORMAT"><a href="#INPUT-FORMAT" class="headerlink" title="INPUT FORMAT"></a>INPUT FORMAT</h3><table><br><tbody><br><tr><br><td width="20%">Line 1:</td><br><td>The single integer, NP</td><br></tr><br><tr><br><td>Lines 2..NP+1:</td><br><td>Each line contains the name of a group member</td><br></tr><br><tr><br><td valign="top">Lines NP+2..end:</td><br><td>NP groups of lines organized like this:<br><table><br><tbody><br><tr><br><td>The first line in the group tells the person’s name who will be giving gifts.</td><br></tr><br><tr><br><td>The second line in the group contains two numbers: The initialamount of money (in the range 0..2000) to be divided up into gifts by the giverand then the number of people to whom the giver will give gifts,NG<sub>i</sub> (0 ≤ NG<sub>i</sub> ≤ NP-1).</td><br></tr><br><tr><br><td>If NG<sub>i</sub> is nonzero, each of the next NG<sub>i</sub> lines lists the the name of a recipient of a gift.</td><br></tr><br></tbody><br></table><br></td><br></tr><br></tbody><br></table>

<h3 id="SAMPLE-INPUT-file-gift1-in"><a href="#SAMPLE-INPUT-file-gift1-in" class="headerlink" title="SAMPLE INPUT (file gift1.in)"></a>SAMPLE INPUT (file gift1.in)</h3><pre>5
dave
laura
owen
vick
amr
dave
200 3
laura
owen
vick
owen
500 1
dave
amr
150 2
vick
owen
laura
0 2
amr
vick
vick
0 0
</pre>

<h3 id="OUTPUT-FORMAT"><a href="#OUTPUT-FORMAT" class="headerlink" title="OUTPUT FORMAT"></a>OUTPUT FORMAT</h3><p>The output is NP lines, each with the name of a person followed bya single blank followed by the net gain or loss (final_money_value - initial_money_value) for that person. The names should be printed inthe same order they appear on line 2 of the input.</p>
<p>All gifts are integers. Each person gives the same integer amountof money to each friend to whom any money is given, and gives as muchas possible that meets this constraint. Any money not given is kept bythe giver.</p>
<h3 id="SAMPLE-OUTPUT-file-gift1-out"><a href="#SAMPLE-OUTPUT-file-gift1-out" class="headerlink" title="SAMPLE OUTPUT (file gift1.out)"></a>SAMPLE OUTPUT (file gift1.out)</h3><pre>dave 302
laura 66
owen -359
vick 141
amr -150
<span style="font-size:18px; color:#FF0000">
此题关键在于如何处理字符串所表示人的名字上，就是如何通过一个名字找到此人的位置，下面写了find（）函数 用于返回名字所在的位置</span>
<pre name="code" class="cpp">/*
ID: ifayne1
LANG: C++
TASK: gift1
*/
#include <iostream>
#include <stdio.h>
#include <string>

#define NP 11

using namespace std;

struct _NP{
    string name;
    int have;
}N[NP];

int n;

int find(string name)
{
    int i;
    for ( i=0; i<n; i++ ) { if ( name="=" n[i].name break; } return i; void input() int amount, divide; string temp; cin>> temp;
    cin >> amount >> divide;
    if ( divide != 0 )
    {
        N[find(temp)].have = N[find(temp)].have - (amount - amount % divide);
        for ( int i=0; i<divide; i++ ) { cin>> temp;
            N[find(temp)].have += (amount / divide);
        }
    }
}

int main()
{
    freopen("gift1.in", "r", stdin);
    freopen("gift1.out", "w", stdout);
    int i;
    cin >> n;
    for ( i=0; i<n; i++ ) { cin>> N[i].name;
            N[i].have = 0;
    }
    for ( i=0; i<n; i++ ) input(); for ( i="0;" i<n; cout << n[i].name " n[i].have endl; return 0; }< pre>

<p></p></n;></n;></divide;></n;></string></stdio.h></iostream></pre><p></p>
</pre>]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>usaco</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2018，我的十年</title>
    <url>/2019/01/01/summary-of-2018/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码无效, 请检查并重试" data-whm="这些内容无法验证，但您仍然可以查看"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="输入密码，查看文章" /><label>输入密码，查看文章</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="fa024c0c81f6506b9eb63886fb42052efaff514c2526faf6a0941d4393b3d1c5">5393d9cd48cf4ad629c25c2765d478ff918c3f927f5a06f7a62ff39ee7e52eb9410ebe686f5dec90c0c0bc85982ed3cdec5059d76c789b7ee8170777d70e4f4f271968994fff9b01de64460a5b8867ce408e0e22bb9449e9b7cab82519bb6878ee860b4d824dd07ff9bfaf5aa34979a48d03f5fb40eb5a96f577325437229becacb6083042fcb99e7b577985152c23f0afbd26ea1204e171e8be88a004f1272508a9aae08e908ca03656bb12c3581bff79246ee2adab95ebfb899376b67a833ad7706428f3aba1d47f8a44f23559c282a2e3777c180e06a3f6a555e087e127eb564feb5ce08fa4ebb1b9d9549beb65b5c804681f03c018805af4771b4d2ddad6310cfb4b1f753a98d8769eae535cbd513fa180d70d0968796363433b1df6ab03d6807c34e5f322dcc2a2321d26b0eb843d175b11cef84146b4365845b9a533bdba1b8ae36e492cbbdcea354a44a30a415457a95252aef8699ef22e14018f6a322352c51d9ec45cb340dcd369148c296de5c603d6ba788601bf8971fff5f69a883877a68095e3a97773c5bb9f6418586a483e9a473b398989edbf5d2e51ce33964042b1cfaf614e95dfa9243988006bcaf0eef5d1c10aab2b1c139d858004aaee74be692a5c2fea9f4450ac4c1f70c39040ebc392d8cc4b2e72e83df25ea841862ed43270fdb4471e271a84900b4f34d58dae93f2a5e185fd4ef4e300cbc56cf3715358b73defbc0d92012487add5dcc79d3a4e1ebc64cc467379c8939555db43cdd2fea96ea1591bbcbbed41781d69fdec255fd5470164c8ee326f689e152849090148265e33c09173bd2340020e5e01cfdb0ee7ee1551b021528ae37b1cb26885a7ae559fc435799fe69c85685aa686b16f6b3dd207543dcab657a0ed512b6c483f01bcbe51bf45da9ae92160a45cfebe376a10b970438f2c4a3373b098680ae42cc5a4ee7805d33e7c36793586c11335872dc2cdec54c933c2afe2fa97ac24b5c06608e2e7e38765756e4733cda7317f513d454e35a02528fe434efde9728679dd6194a5e716617326225355752b964a520041a79551ab9c599bd1a97665402393b5a498a0388b9244cb62cb765ff67c4c7114f30d5c1aaa6bf3fc7c9689f59fef53c9791a518d659fc63c63526301119258afadc4f02009e3d65708028c273ccac89d3e1c576925536e8bb6564b5136029db937eae94b692d93289b7d1ffe91af91afa810f8efc946f36d99c13cf8e706efe0f9360487805ec5ff5e77b86c6532539592e14198d47f833c48755696205d11a9169cf4ae775fcb5416f8b5d1dc2f8589392b015314dc1c8058396e684c8a6970a1a63a3c6c4db9a19695c2d1d8f145cae226740fe106b47924f4bc22b070c391a5ccfc4479c902e1d2612a9e99ecf1d298308e019cf1f2732d908360fc952bd2e08c9a8daa7ee3d4124818ed62165f5bb5587782df05b53993e92abbe107311b5bd3f8726125e39aeb901b1d6735457e68445ab907291cbaeb9c1da67ca07908eaf980e5b97b1119bc80837a68b0084e251da92ea0ae233d2f57d590b6579a5099d4dcac55558a4048d5d632a759d5d8bfb294c359a33962345215a5526f3d9ff4c59b4ef0d612f71da41ee45cc474444a1b18d1d8804836f1a92390754b05fc73549959c4224ac471d61278e8a29a517306e47450fd22c92e9412c03db7414bb70e590a85ce613f8ac03a97c6bc76b1f7b1121834dd069e3f093cb0b766546e3f78a6023a18f5bb4004b842635c290501afedb72e08fd91033a11f65388cd9e114306eee1679465cb207a28e7daf71f1d7bbc8a72080dbf03d0f7824db8a9ccf933dce2ec1dc1224a094a8dfa749ea1d1d9bac9dfcc5491b6aa068ae4374499b826f316d72a103e14cd36bf406bc622fe565d5734a765117581807b945ef4084a55f4230b07449133b9e37835f2af4288a9cc540a1036219b7bcaa99c388f62e7784d17a600d5c6aba596ec7e203ff4773b2f9537eade52a578d3b5296ddb513f8fa1ac92be38e289f929e4555206cde8c03148757c62429c8f3ec3b70ebbfbe6d0117969c0d0e2333d92535be954e57837a09097a3fc71df774cf24efc284063e57e9fd44701731900eb92ff7a287d54dd3cf40a0e9828ab3c4d2f42fb2bafee78053070e8c28f35bb880db6d135d7599266a0981f4c9e65371fa7ed72adec6cce4c77e67f21d058273e15a823a56fac1be08c4aa5fc31d70870a5603df702235351b230288a671fa438c418e66128a8f59dcd515c8ed7583f7b9d4fb47fc8573f05c48923dc9eddac3361a70c47a50ae9b8e69cd6a57f518620ec783966aabe9cc6865d75a8fae6c2b5e63f6320feadd3ddb3cdf9b5f96133bfbaf2c5118fe4662167b4cf0ce7941878ecc8595f12505f8a3afdcbd5f3ebf053943449f02be922eda261b432a0ef5ab59aa623925882e695b53488ea020ddabb4c90c48415b6bef3ad753a7451cca6347a10e54698400cea556bf8ab00f068e5748d09d8ad6a85df2fff08c7e6b9ad2cb97c87e55d33aeeacaf6bd50e9dc055973f024cf8f5ce10a301b225b6aaa7ea96b7786e6e54cb10f488e7dbc4431e8ff97d6b9e1d44fd893caad56f0a073b21933a9e0f232181f128b05011b28cd0f1705b3fb2a3f37421ccd1151140eaf4311bd5305d08b24ebe1c9f1da678ff35a838da4dcec526fb94d48839c7f38eb78f717adbe1ce7b78f7af96d0db0ae7e22a22e07892e60bdff8b7a42b555b25efe5a21da10194a61511aabc3eb7c603985feba6beeb7c8b3a23835171f0a130942e593133cad8b075cf48ed5936f59829046ca45a21740e8cb3c4166af68c26ede0003b90cd0d1e08681c63ee0ec25d4ea1c60941bff9447b4ba4c920116081d5bd675ef6d3de642af9929525a1fd4109fd14bdc833b280bc108bdb646426c2dc7384ac99153de74980d90f8ec805fc18d37f9a497766957655960f95c6478da44583b4958af980f36aee8744c5469a068269c1eeac4d87e582c54f43d8319b3de4ef91b79046ea3197a04d043b8e461e3cd5080e89a42d587a56cdae9935d81510c598aedc17d47e5d362cf92da5765f074d4c2b6b6e465adf65ac2736644b6bd2f2ddc7a7f5a47297e5f1b22fff1e56d96f5a3db4aa2a1b20c63ab441c8132e1ccfc2093768931591d86e2d336537dc37f29ffe8b81b388eadd13038f485975d6a7ee8cd32bc76c258f2aa960cceb78a137495b3d1be26d64547f546346b0b7b1eabeb37232d5b2200eace980e4387dc80b10b8e683a8b5096bfa6dc7e9f4d2d564565658e29c2daf14e2d2362aca786f66ae001046c86ae1823461045e915873620f80548affe98106b0b3f1f66da0133c2fdd18f14f9959802811481296bf2ac7dcdf3ab4420f0b3f90d21bed635de946490c3b2c7322064dba809c29eede6ddb5d4b9ccd531193499d45db2077ea2ca9578f8f0e7fb2a7591a79c0441378ef8bd5ed804a05eff24a2febf634db543dabf95438b70d7f6628f88611723839fd2172974f601f0ba2528c7a09743c6e84eb9dc0f9dd9845e82da2bbf3295f5453b56554d6e7128e19ab4879d265ffd92ee790ec13f8673169d27f2ffd3d4b5415ede8930ae411fd853229312550cc98de6d21599dc0c26de104bf041a4d85e11c20c5f33b361986e17567dc46ec770ac06b80553742d1a20b0a80632a3fc884ce361cf0d0c026f2dd367774e33ced9505be797084d7f5224215ce7022cd05fcb08dc5d4e941ffa1c5848935c616528399d77e2a108cce21f6b1ddf2d4280456f30a1412521c0dc03ef62cf9bb2a283489142e692868eca1c1275dbcb8df2696bd55a5f7f5f8e2b2813df10dcf6a03ccbae7f3ac3e429e867f566210f239ba5ab20b3786b3f16c9cad2f23a0737e6ac5f5851ab5fd298bb9999f3691b5650fd78fffb35a79c2f77e6abb701161009d0da42a02d857dfd5e71426da44d59284a9ed7ff1522c07a1f38f4146236948439ace0020315cd8162e795077d26a9e91e5af3faf1668190f7c40248f9b84efe85edd6843b5e4cf5b5505f33741a563e4bcd78273461b8998071669c7d9f04f479e666699302192cbbce35a1aeedb7d07e23caee04b415b449831ed2a055ca21ba0e6ba1533df0b2b9ad7c3d8ccb3a675e4db5406dbb96c21d6248c30526c28ab136e9dff9d45559d146d6abfbc1a913f8e20c96a2d0440bb887f9b229d14731040c655bace4b6e9d14ca8fceda7f375b008f1cc4fcb7905b17e2213275f0ced818604c4800980001577828419fced83a22bf2edb1e797431cbb0ee9a63d637bc775479546455bad617c0ede281004ae68f0392b431af770d8f8fe2d15b60331f0eff7f139f4c767b54a0393063c91be9df998f6fe77cce9211adf160bb4b473ec0fdfa5792ae278e90595e3e89d1f110c861da978ef0ed5a8ded225d6c6aebdecbfd84b40cd6a169b818c48cc0e8f7f15263bd82484089095ec084003c07978e951cbd6783295c2abae25892490f196d423f7776432e998fedd6cb9627f872ee654d249fca16f774e81901b8f26be55974f915aa071485c20b6ec963e46253f3085b32a4262157578e807b4000c477dc7c557fd</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT (Basic Level) Practise （中文）  1016. 部分A+B (15)</title>
    <url>/2015/08/31/patbasiclevelpractise-ef-bc-88-e4-b8-ad-e6-96-87-ef-bc-891016-e9-83-a8-e5-88-86ab15/</url>
    <content><![CDATA[<h1 id="1016-部分A-B-15"><a href="#1016-部分A-B-15" class="headerlink" title="1016. 部分A+B (15)"></a>1016. 部分A+B (15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">100 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">CHEN, Yue<br><br></div><br></div>

<div id="problemContent"><br>正整数A的“D<sub>A</sub>（为1位整数）部分”定义为由A中所有D<sub>A</sub>组成的新整数P<sub>A</sub>。例如：给定A = 3862767，D<sub>A</sub> = 6，则A的“6部分”P<sub>A</sub>是66，因为A中有2个6。<br><br>现给定A、D<sub>A</sub>、B、D<sub>B</sub>，请编写程序计算P<sub>A</sub> + P<sub>B</sub>。<br><br><strong>输入格式：</strong><br><br>输入在一行中依次给出A、D<sub>A</sub>、B、D<sub>B</sub>，中间以空格分隔，其中0 &lt; A, B &lt; 10<sup>10</sup>。<br><br><strong>输出格式：</strong><br><br>在一行中输出P<sub>A</sub> + P<sub>B</sub>的值。<br><strong>输入样例1：</strong><br><pre>3862767 6 13530293 3<br></pre><br><strong>输出样例1：</strong><br><pre>399<br></pre><br><strong>输入样例2：</strong><br><pre>3862767 1 13530293 8<br></pre><br><strong>输出样例2：</strong><br><pre>0<br><a id="more"></a><br><span style="font-size:18px; color:#FF0000"><span style="font-family:KaiTi_GB2312">解题思路：</span></span><span style="font-size:18px; color:#FF0000"><span style="font-family:KaiTi_GB2312"><br>  ·此题的关键在于如何计算新整数Pa,Pb,因为A和B范围太大，所以用字符串储存</span></span><span style="font-size:18px; color:#FF0000"><span style="font-family:KaiTi_GB2312"><br>  ·使用临时变量temp更新其结果，遍历字符串，如遍历字符串A时，与Pa比较，如果相同即更新temp的值，遍历完毕即Pa的值<br><br></span></span></pre><br><pre>&nbsp;<pre name="code" class="cpp">#include <iostream><br>#include <string><br>using namespace std;<br><br>int solve(string a, int x)//函数用于计算Pa和Pb的值<br>{<br>    int temp = 0;<br>    for ( int i = 0; i&lt;a.length(); i++ )<br>    {<br>        if ( a[i]-‘0’ == x )//因为a为字符串， 比较时应将其转换为数字进行比较<br>        {<br>            temp = x + temp*10;//条件成立更新temp的值<br>        }<br>    }<br>    return temp;<br>}<br><br>int main()<br>{<br>    string A, B;<br>    int Da, Db, Pa, Pb;<br>    cin &gt;&gt; A &gt;&gt; Da &gt;&gt; B &gt;&gt; Db;<br>    Pa = solve(A, Da);<br>    Pb = solve(B, Db);<br>    cout &lt;&lt; Pa + Pb &lt;&lt; endl;<br><br>    return 0;<br>}</string></iostream></pre><br><br></pre><br></div>
]]></content>
      <categories>
        <category>MOOC</category>
        <category>PAT</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>pat</tag>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title>不再回来的2017</title>
    <url>/2017/12/31/the-last-day-of-2017/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码无效, 请检查并重试" data-whm="这些内容无法验证，但您仍然可以查看"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="输入密码，查看文章" /><label>输入密码，查看文章</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="bc82183537cf82da6238c63f22d8e8c4809d9103f24e30355535c6a26fcd3cb0">0d3934e2b85bec1319d568bde8277b58c39f2e68bcea22fe96f6089fe278c6c2a12e625826d271b5ab4c765be46c4f8fc3223230e5397de5581bea308abf96246d863d5382b8625db18424e4bc2b07bcd19e71500c12f6bf72aca570dbc06b664973c5d94e5b9dd7e7ad64ca5fc59016dc1e63da05d074a7d86bf3369cfee8d5d8e1f1cbd54efa16c605a3b1f519bc5b2175f6e185318d861e6e75accead5b82e5fa77d5d9d0878e8b2b9776bc631fa5186eef5ffa71b72c7f761f4c49cce46363f9b7efaab7aded4c02e3cdb1d0ef5b4fb396d0276c10d83fce0a5b44c0aa07edb1a7c2b33c787b19c3608a5f5b777fb2f6a5445a5bc6a52740ffc4cacace1bd6146e526806a6960d4442ce83a130f17d3905d4cd6cf356cf575a8fab6041193f583a228ee9c17eaa20f3d7d6665cf0d099844097286df5cdf8e5c2a8536a8ef12785672e8655025aaaa684faddea974e0e9805745f2b7eef8bc81ee125052e55f381dba25ed96157d3cd9cf1c6c3b34171c27287b2f39cf197c963cfe372ca7c96fd7c2166fe907e0e0e0786f687998e4670d9c658205f538ca2e8a69942e8d0def133a680cddd94fd3741d44bcf537e7ea1b533646bdc2fccee89514672a1d6297b97fa7a576f9a0ef2ee5a1712ac28a7390e8bfed298956fc614a057fa7bc35d4da7da740cb9d7a1681e867f2ead0e3bff4bf4f30580de9842819733019015fb013282355ebb2a90289102176c97517c817b59b41cbc7806544772c7f20e3cce06d589b94800e0e246c8301cd7023162cb519ee1581d7f30b1618c9149ec3f5f57db5194c3d5eb5884768f2607cee3e26655a486ff5a55e581f364f7ba7a173a0d203190b927a284f89acb8674db806bd8afb3da86113121a9a4e1d87337b4b03b75cdac4b79dca32082123e753df178a1096a9b675a405ef945bd0f0eb35bba78efacbfa78c4ffa7286b09cbb699214eae44c7ba0203e893ea4e1fc1fa18bcee3f951402f42b92b244997929487c250ae2a2fb9ddc2f9ea70ea4324c362af2837704bbc86daac74f186c8fcad27de5ee60dea926cd8ac54d2ddd1777e0e4beb95bc84cb92d5599bce779a606a1abcdb051e828557143bb01661dec3921deda3c4a3e0ee80001e52ce6ecd17f8953d8dc32d7b22a43f73974b17952773b41713df0b470b110206792e531b81f3f739b9575e106bc9d9f62cc36dab2cf54f39bfb14dee3b80d1d2bc2208ea4a6e373ec71642fecdc6028977053838867f72142676acdb32e04f8422201a45dbc6e14abf7c72e5ddec00b8438cf3ac39ff9689612cbffef59680987501e72f5fd357b9d35cf2c36bb810bba43ff2dcc0c7423f6d8ef0dd8978438ccc90bfd60c37b28039da5ad1ef3b18b76513ca803da7bfbf74b74a6c2d1b35d2349d1eab898928fc34045f57372150efae45f4c24bb9d08e6e57e3a2a95a203f1d0f5237b53b0d989befc1f4fdf230cf7dda6644dc89183d4cec22390b8ebe2c56e11ae9285f4e6fd0db38634ee3c60e84bb288e5b53de61517d064f6441da27c153e874dbc3256b2c7f35a51fae76c2b1dbf3f5b6f0bd375cb5e26b081ea02a237581e5a76d795a8cf1a09fd2c67f5e3be415ef1ea549fc16fc5d588bf1bad45b8f167548c64367e8310faac5e787edbcd06d48da2d064b5cb7de134a1bf6d2ee93f2df22127515c8d8b4c3fda63abba767a928a863e357ee6ec7720de38d6c6a34d7b70299eb8c44eb93899c31a51771a741013ce866e3446cef4f4704911c8dd29ad55f1d98cee707c20b652b87972fb3dee193cac30b2fca64b7ea7d235afe14f1134d3997b13ccb43d04616326201a971ec156ad1750be4c354aa28d757766b7c3b210281a2f6ddf4d75dc89d35fe4f945e24e9e18fd8895cde01c2dce788559ffda230b6a536f16b7173f45c92b485e46ccb671d9e9b49d3fee2082c9f8303c67b353e59dc90130cee6d870bf0df894c3283daa4b46fc04e77b654d8b50aab43f51dd10793f0b4ec8de4e31a2f72aa20914679077f85819badd3101a28cd169100d17c9a23c0f1484e11e83f0971c57eeef4b03a017a171bcdfcbcc827b6c6bc210d268c81b94bcc9fcd4fd8de02332a8dfd0dca929cd2ad9fda4f021325ce1ba07bd4b5172dc9ad2e67d6d8f2e7c34e5ddc8230b4d845c2e372ac0211f5a2999259b866e4eef03bb44ea522d1efb3b95ed1ea1857b91c9ac6957555a482ed336975a4ae26ab72d3e7c8c202acfd9901605e77d32f3a4a787fa5561ca8dc163b377393eb03e69334afcf3262beeba470ab559f6d897fdc8dbecea8143b8178d622f5588923c82b2acb6c07c0fb933cbe7ff1661ac89cef2f22621cf3b8b0e6ae5eb401d73afbfec045bb958a4b21299bea49f7f4bd292e390cc6cd0cb5c0e653c00fd224ae815d45e8606ff67bd3572c65f83082045c6d2663c0cbd31917bb6e672882f97383b98f967d680e8205f263a13237b124bd21383c21d412239bf4f3ef6ae988172958e5d7b00c517695814915f893f9e4a46c74519fed3d589eb3c78a3ef7288dc3745109c9c1750816e913883493c9b798048bffb8a18d820651b023c6140410f9bd936e3c81ade4728ec6db7da5379d832f05e809ccc79465ba0cd569c9ad149c3ee4ff41ad1b161b26023ea0ec675b60bcd8a35ed9c45de1f16f7295ed6344a7d00ea60b986f2fb622f308459739d0dbffe1aca4b7d0cda2eeb845e182b323c03b2774d35351b9a6391d9778923b70ffb1637715653d6e2853aea7422406975038aba442efc8e118c916c03d697effe7d8168ca37daca28bca06df1d99e9075e6fe289d208b478a838d3885c04401e0c29d722da8dcba5440e85c110ca7f25e4cdd3e8c27067148bead5e66ca18260876c2387457a4a1ad1609e68930f2f94386ac8e34c9aaddd9c83b1e999153aa537ef7e1e19699970c80c17e98eae07d1027a12003576688b46c91073ac8d6a5f5ab732cebad434fb065e46374d210113e33fc1e8f24bf29a39abc62cc6f487a3a601bce8a4f9ba6d4a2f975ceb9a42d2e3bfd7cf6821c37d7fd17c641d330b75d816da1a094b35bbdf5f8b5fbca065aaced76a5b9608eb740049db7d38160b006751b5ce0ad0870d4971e6962d54b81d17ed04fd29802e4af4fb20a6e79a34fe27d1b0a2d300a81f0f9685e795c9636e5e32defc8e2466c54294de8e204bba7b80f1754241fcdd34a36a785d61306245ce72c8eaf70bedd1f0fb6acf399012215227720e4ae7c5fd34f0b4b21507e07f371f365b4f70aa5d9122d523d3255b35a9cddeb253307abe19c18cfb707bf68f023eeda4c46a25e79c713421820b6bd400f24e64fa041958d81bbc44bc3568470893ea6edfda97ef1f1a19f01ed9d6d9b5c6f5bb53174a2c9d6d4846b7fe599e3de30fe8da98d88cebc9400765e6f9747ec15d6ef1138a3200276a5cac84043e731065e2bf12debd8e4bb912167ea8f0ff3f4d40d6ecb8b2780fce26e97407f1ee54c83fcd065f7f7b12793b797e53e1b24a4aaec8591284665d705cdb4cd74f137dc87e49d914c7ba963e916c2c14805e62b407ed871d8585811f46542f90533f6e3a16b437651dccd7e86d360ddc5d1404f1b5c7427793173c6e489de84236ac923acd8adb4cfe4332ff1fa5ea0450374f8dba83848ce7a7a21ed026d693311a5259a6624bd3045abb0cfcac7ddde91dc838c4b08f587ba6eae54b2c1018873170b45376be7e99573717e65c8ba10bc258068d799c074808bf5e421b967d3d0d463dbb16eb9e3fa6780cf44474f03602b8c0180fdfe6498fb8167133ee800dfa7396ec3532a4c4bdf4828c770efb515a1c948ffbd8cbba53cb946b9468494ce6bd9313008ae831a061b56a7e04efeca9a0068d256779496ef2350020d770</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress更改“固定链接”模式后，页面出现404错误原因及解决方法</title>
    <url>/2017/07/24/wp-404-error/</url>
    <content><![CDATA[<p>在更改wordpress的固定链接后，出现了链接打开404错误，查了很多，修改好了</p>
<p>本文采用的是centos+nginx</p>
<p><strong>解决方案：</strong><br><a id="more"></a><br>在 /etc/nginx/nginx.conf文件的 loction \ {} 中添加</p>
<pre class="theme:xcode float-enable:true toolbar-overlay:false toolbar-delay:false show-title:false lang:default decode:true ">if (-f $request_filename/index.html){
    rewrite (.*) $1/index.html break;
}

if (-f $request_filename/index.php){
    rewrite (.*) $1/index.php;
}

if (!-f $request_filename){
    rewrite (.*) /index.php;
}</pre>

<p>&nbsp;</p>
<p>重启nginx服务器，完美解决</p>
<p>&nbsp;</p>
]]></content>
      <categories>
        <category>服务器</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计入门——C语言 习题汇总</title>
    <url>/2015/04/26/e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e5-85-a5-e9-97-a8-c-e8-af-ad-e8-a8-80-e4-b9-a0-e9-a2-98-e6-b1-87-e6-80-bb/</url>
    <content><![CDATA[<div style="top:0px"><pre class="cpp" name="code"><img src="http://imgsize.ph.126.net/?enlarge=true&amp;imgurl=http://img1.ph.126.net/DRP1fc7IDe3Jux_yvA0OnQ==/3186859686418268890.jpg_108x40x1x95.png" alt="浙江大学">&nbsp;&nbsp;</pre></div><br><a id="more"></a><br>&lt;<br><br>div id=”g-container”&gt;<br><br>&lt;<br><br>div id=”g-body”&gt;<br><br><div class="m-learnhead"><br><div class="f-cb"><br><div class="f-fl info"><br><div class="f-cb"><a href="http://www.icourse163.org/course/zju-199001" target="_blank" rel="noopener"></a><br><br>#### 程序设计入门——C语言<br><br></div>

<h5 id="翁恺"><a href="#翁恺" class="headerlink" title="翁恺"></a>翁恺</h5><p></p></div><br></div><br></div><p></p>
<div class="g-wrap f-cb"><br><div class="g-sd1"><br><div class="m-learnleft"><br><div class="top f-pr"><img src="http://imgsize.ph.126.net/?enlarge=true&amp;imgurl=http://img1.ph.126.net/tYhzuDVilzlDOo2bEyH_Qg==/6608226511143817333.jpg_230x130x1x95.png" alt="程序设计入门——C语言"><br><div class="u-searchIpt search"><br><form action="/search.htm" target="_blank"><input name="search" type="text"><input class="f-icon" type="submit" value=""></form><br></div><br></div>

<ul>
<li><a href="http://www.icourse163.org/learn/zju-199001#/learn/announce" target="_blank" rel="noopener">公告</a></li>
<li><a href="http://www.icourse163.org/learn/zju-199001#/learn/score" target="_blank" rel="noopener">评分标准</a></li>
<li><a href="http://www.icourse163.org/learn/zju-199001#/learn/content" target="_blank" rel="noopener">课件</a></li>
<li><a href="http://www.icourse163.org/learn/zju-199001#/learn/testlist" target="_blank" rel="noopener">测验与作业</a></li>
<li><a href="http://www.icourse163.org/learn/zju-199001#/learn/examlist" target="_blank" rel="noopener">考试</a></li>
<li><a href="http://www.icourse163.org/learn/zju-199001#/learn/forumindex" target="_blank" rel="noopener">讨论区</a></li>
<li><a href="http://www.icourse163.org/learn/zju-199001#/learn/custom?id=300001" target="_blank" rel="noopener">教材与参考资料</a><div class="m-coulshar f-bg f-cb" id="j-coushare"><br><div class="f-fl f-fc3 f-f0">分享到</div><br><div class="u-share f-cb"><a target="_blank" title="分享到新浪微博" class="solo f-fl f-fc6 sina" id="auto-id-6uhKWu3lJ5MWHvbh" rel="sina"></a><a target="_blank" title="分享到QQ空间" class="solo f-fl f-fc6 qzone" id="auto-id-DIftcdOtXI52RCXR" rel="qzone"></a><a target="_blank" title="分享到人人" class="solo f-fl f-fc6 renren" id="auto-id-yFaG4ETvXpK0wEbx" rel="renren"></a><a target="_blank" title="分享到微信" class="weixin f-fl f-fc6 solo" id="auto-id-tavorPx5Nm8TlWcz" rel="weixin"></a></div><br></div>

</li>
</ul>
<p><a href="http://www.icourse163.org/help/help.htm#/hf?t=0" target="_blank" rel="noopener">帮助中心</a></p>
<p></p></div><br></div><p></p>
<div class="g-mn1"><br><div class="g-mn1c m-learnbox" id="courseLearn-inner-box"><br><div class="u-learn-modulewidth"><br><div class="u-learn-moduletitle f-cb"><br><br>## 测验与作业<br><br><span style="font-size:18px; color:#ff0000">次汇总由CSDN-fjinhao原创，转载请注明来源，此汇总由于本人</span><br><br><span style="font-size:18px; color:#ff0000">能力有限，难免会些问题，欢迎各位程序爱好者来此讨论交流，给予指正，本人</span><br><br><span style="font-size:18px; color:#ff0000">联系邮箱<a href="mailto:fjinhao@qq.com" target="_blank" rel="noopener">fjinhao@qq.com</a>，谢谢。</span><br><br><span style="font-size:18px; color:#ff0000"><br><br></span><br><br><a href="http://www.icourse163.org/help/help.htm#/hf?t=3" target="_blank" rel="noopener">查看帮助</a><br><br></div><br><div><br><div class="empty j-empty"><span class="f-ib">老师还没有发布测试和作业，请耐心等待</span> </div><br><div class="m-chapterQuizHwItem"><br><br>### 第1周：计算<br><br><div class="u-quizHwListItem f-pr last down"><br><div class="titleBox j-titleBox f-cb" id="auto-id-tB3qdgAL94vKWXtH"><br><div class="f-icon qhicon f-fc9 j-up f-fl"></div><br><div class="f-icon qhicon f-fc9 j-down f-fl"></div><br><div class="f-icon qhicon j-noContent f-fl">&nbsp;</div>

<h4 id="第1周编程练习"><a href="#第1周编程练习" class="headerlink" title="第1周编程练习"></a>第1周编程练习</h4><div class="j-submitTime score f-fl">截止时间：2015年5月4日 0:00</div><br><a target="_blank" class="j-quizBtn u-btn u-btn-default f-fr" id="auto-id-AOBzZsP5DfdZFPvp">前往作业</a><br><div class="j-validScore score f-fr"></div><br></div><br><div class="detail j-detail"><br><div class="u-quizHwInfoItem"><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业类型</div><br><div class="f-fl right">Online Judge作业</div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业截止时间</div><br><div class="f-fl right right1"><br><div class="j-submitTime">2015年5月4日 0:00</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">成绩公布时间</div><br><div class="f-fl right right1 j-publishTime">2015年5月4日 0:00</div><br><div class="f-fl right right1 j-publishTime"><br><div class="position f-fl">1</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_12">逆序的三位数<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_13"><br><strong>题目内容：</strong><br><br>逆序的三位数：<br><br>程序每次读入一个正三位数，然后输出逆序的数字。注意，当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。<br><br>提示：用%10可以得到个位数，用/100可以得到百位数…。将这样得到的三个数字合起来：百位<em>100+十位</em>10+个位，就得到了结果。<br><br><strong>输入格式:</strong><br><br>每个测试是一个3位的正整数。<br><br><strong>输出格式：</strong><br><br>输出逆序的数。<br><br><strong>输入样例：</strong><br><br>123<br><br><strong>输出样例：</strong><br><br>321<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br></div><br><div class="f-fl right right1 j-publishTime">代码参考：</div><br><div class="f-fl right right1 j-publishTime"><pre class="cpp" name="code">#include&lt;stdio.h&gt;<br><br>int main()<br><br>{<br>int n;<br><br>scanf(“%d”,&amp;n);<br><br>int t1=n%10;<br><br>int t2=(n-n/100<em>100)/10;<br><br>int t3=n/100;<br><br>int t=t1</em>100+t2*10+t3;<br><br>printf(“%d”,t);<br><br>return 0;<br><br>}</pre><br><br></div><br></div><br></div><br></div><br><div class="j-previewStatus"></div><br></div><br></div><br><div class="m-chapterQuizHwItem"><br><br>### 第2周：判断<br><br><div class="u-quizHwListItem f-pr last down"><br><div class="titleBox j-titleBox f-cb" id="auto-id-PLLkHq1MMkNlh7Qa"><br><div class="f-icon qhicon f-fc9 j-up f-fl"></div><br><div class="f-icon qhicon f-fc9 j-down f-fl"></div><br><div class="f-icon qhicon j-noContent f-fl">&nbsp;</div>

<h4 id="第2周编程练习"><a href="#第2周编程练习" class="headerlink" title="第2周编程练习"></a>第2周编程练习</h4><div class="j-submitTime score f-fl">截止时间：2015年5月4日 0:00</div><br><a target="_blank" class="j-quizBtn u-btn u-btn-default f-fr" id="auto-id-azTNp3KCGwbULGvS">前往作业</a><br><div class="j-validScore score f-fr"></div><br></div><br><div class="detail j-detail"><br><div class="u-quizHwInfoItem"><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业类型</div><br><div class="f-fl right">Online Judge作业</div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业截止时间</div><br><div class="f-fl right right1"><br><div class="j-submitTime">2015年5月4日 0:00</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">成绩公布时间</div><br><div class="f-fl right right1 j-publishTime">2015年5月4日 0:00</div><br><div class="f-fl right right1 j-publishTime"><br><br></div><br><div class="f-fl right right1 j-publishTime"><br><div class="position f-fl">1</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_12 edueditor_styleclass_14"><br>时间换算<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_13 edueditor_styleclass_15"><br><strong>题目内容：</strong><br><br>UTC是世界协调时，BJT是北京时间，UTC时间相当于BJT减去8。现在，你的程序要读入一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。如1124表示11点24分，而905表示9点5分，36表示0点36分，7表示0点7分。<br><br>有效的输入范围是0到2359，即你的程序不可能从测试服务器读到0到2359以外的输入数据。<br><br>你的程序要输出这个时间对应的UTC时间，输出的格式和输入的相同，即输出一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。<br><br>提醒：要小心跨日的换算。<br><br><strong>输入格式:</strong><br><br>一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。<br><br><strong>输出格式：</strong><br><br>一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。<br><br><strong>输入样例：</strong><br><br>803<br><br><strong>输出样例：</strong><br><br>3<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span>参考代码：</span></div><br><span></span><br><div class="j-limit f-fc6 limit f-fs0"><pre class="cpp" name="code"># include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int i;<br>    scanf(“%d”,&amp;i);<br>    if(i &gt;= 0 &amp;&amp; i &lt;= 2359) {<br>        if(i &gt; 0 &amp;&amp; i &lt; 10) {<br>            i = 1600 + i;<br>                printf(“%d”,i);<br>        }<br>        else if(i == 0){<br>            i = 1600;<br>                printf(“%d”,i);<br>        }<br>        else if(i &gt;= 10 &amp;&amp; i &lt; 100 ){<br>            i = 1600 + i;<br>                printf(“%d”,i);<br>        }<br>        else if(i &gt;= 100 &amp;&amp; i &lt; 1000) {<br>            if(i/100 == 8) {<br>                i = i % 100;<br>                    printf(“%d”,i);<br>            }<br>            else if(i/100 &gt; 0 &amp;&amp; i/100 &lt; 8) {<br>                i = (i/100 - 8 + 24) <em>100 + (i % 100);<br>                    printf(“%d”,i);<br>            }<br>            else if(i/100 == 9) {<br>                i = (i/100 - 8)</em>100 + i % 100;<br>                    printf(“%d”,i);<br>            }<br>        }<br>        else if(i &gt;= 1000 &amp;&amp; i &lt;= 2359) {<br>            i = (i /100 -8)<em>100 + (i % 100);<br>                printf(“%d”,i);<br>        }<br>    }<br>    return 0;<br> }</em></pre></div><br><div class="j-limit f-fc6 limit f-fs0"><br><div class="position f-fl">2</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_16">信号报告<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_17"><br><strong>题目内容：</strong><br><br>无线电台的RS制信号报告是由三两个部分组成的：

   R(Readability) 信号可辨度即清晰度.<br><br>*   S(Strength) &nbsp; &nbsp;信号强度即大小.<br>其中R位于报告第一位，共分5级，用1—5数字表示.<br><br>1.  Unreadable<br><br>2.  Barely readable, occasional words distinguishable<br><br>3.  Readable with considerable difficulty<br><br>4.  Readable with practically no difficulty<br><br>5.  Perfectly readable<br>报告第二位是S，共分九个级别，用1—9中的一位数字表示<br><br>1.  Faint signals, barely perceptible<br><br>2.  Very weak signals<br><br>3.  Weak signals<br><br>4.  Fair signals<br><br>5.  Fairly good signals<br><br>6.  Good signals<br><br>7.  Moderately strong signals<br><br>8.  Strong signals<br><br>9.  Extremely strong signals<br>现在，你的程序要读入一个信号报告的数字，然后输出对应的含义。如读到59，则输出：<br><br>Extremely strong signals, perfectly readable.<br><br><strong>输入格式:</strong><br><br>一个整数，信号报告。整数的十位部分表示可辨度，个位部分表示强度。输入的整数范围是[11,59]中的个位不为0的数字，这个范围外的数字不可能出现在测试数据中。<br><br><strong>输出格式：</strong><br><br>一句话，表示这个信号报告的意义。按照题目中的文字，先输出表示强度的文字，跟上逗号和空格，然后是表示可辨度的文字，跟上句号。注意可辨度的句子的第一个字母是小写的。注意这里的标点符号都是英文的。<br><br><strong>输入样例：</strong><br><br>33<br><br><strong>输出样例：</strong><br><br>Weak signals, readable with considerable difficulty.<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span>参考代码：</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code"># include &lt;stdio.h&gt;<br>int main()<br>{<br>    int n;<br>    int R,S;<br>    scanf(“%d”,&amp;n);<br>    R = n/10;<br>    S = n%10;<br>    switch(S) {<br>        case 1:<br>            printf(“Faint signals, barely perceptible, “);<br>            break;<br>        case 2:<br>            printf(“Very weak signals, “);<br>            break;<br>        case 3:<br>            printf(“Weak signals, “);<br>            break;<br>        case 4:<br>            printf(“Fair signals, “);<br>            break;<br>        case 5:<br>            printf(“Fairly good signals, “);<br>            break;<br>        case 6:<br>            printf(“Good signals, “);<br>            break;;<br>        case 7:<br>            printf(“Moderately strong signals, “);<br>            break;<br>        case 8:<br>            printf(“Strong signals, “);<br>            break;<br>        case 9:<br>            printf(“Extremely strong signals, “);<br>            break;<br>    }<br>        switch(R) {<br>        case 1:<br>            printf(“unreadable.”);<br>            break;<br>        case 2:<br>            printf(“barely readable, occasional words distinguishable.”);<br>            break;<br>        case 3:<br>            printf(“readable with considerable difficulty.”);<br>            break;<br>        case 4:<br>            printf(“readable with practically no difficulty.”);<br>            break;<br>        case 5:<br>            printf(“perfectly readable.”);<br>            break;<br>    }<br>}</pre><br><br></div><br></div><br><div class="j-limit f-fc6 limit f-fs0"><br><br></div><br></div><br></div><br></div><br></div><br><div class="j-previewStatus"></div><br></div><br></div><br><div class="m-chapterQuizHwItem"><br><br>### 第3周：循环<br><br><div class="u-quizHwListItem f-pr last down"><br><div class="titleBox j-titleBox f-cb" id="auto-id-L7lGwLa8Eb8s7Uo7"><br><div class="f-icon qhicon f-fc9 j-up f-fl"></div><br><div class="f-icon qhicon f-fc9 j-down f-fl"></div><br><div class="f-icon qhicon j-noContent f-fl">&nbsp;</div>

<h4 id="第3周编程练习"><a href="#第3周编程练习" class="headerlink" title="第3周编程练习"></a>第3周编程练习</h4><div class="j-submitTime score f-fl">截止时间：2015年5月4日 0:00</div><br><a target="_blank" class="j-quizBtn u-btn u-btn-default f-fr" id="auto-id-28tfq2vofTM24KOD">前往作业</a><br><div class="j-validScore score f-fr"></div><br></div><br><div class="detail j-detail"><br><div class="u-quizHwInfoItem"><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业类型</div><br><div class="f-fl right">Online Judge作业</div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业截止时间</div><br><div class="f-fl right right1"><br><div class="j-submitTime">2015年5月4日 0:00</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">成绩公布时间</div><br><div class="f-fl right right1 j-publishTime">2015年5月4日 0:00</div><br><div class="f-fl right right1 j-publishTime"><br><br></div><br><div class="f-fl right right1 j-publishTime"><br><div class="position f-fl">1</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_16 edueditor_styleclass_18"><br>奇偶个数<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_17 edueditor_styleclass_19"><br><strong>题目内容：</strong><br><br>你的程序要读入一系列正整数数据，输入-1表示输入结束，-1本身不是输入的数据。程序输出读到的数据中的奇数和偶数的个数。<br><br><strong>输入格式:</strong><br><br>一系列正整数，整数的范围是（0,100000）。如果输入-1则表示输入结束。<br><br><strong>输出格式：</strong><br><br>两个整数，第一个整数表示读入数据中的奇数的个数，第二个整数表示读入数据中的偶数的个数。两个整数之间以空格分隔。<br><br><strong>输入样例：</strong><br><br>9 3 4 2 5 7 －1&nbsp;<br><br><strong>输出样例：</strong><br><br>4 2<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code"># include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int i,j = 0,k = 0;<br>        scanf(“%d”,&amp;i);<br>        while (i != -1) {<br><br>        if (i % 2 == 0) {<br>            ++j;<br>        }<br>        else {<br>            ++k;<br>        }<br>            scanf(“%d”,&amp;i);<br>    }<br><br>    printf(“%d %d”,k,j);<br>    return 0;<br>}</pre><br><br><span></span><br><div class="position f-fl">2</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_12 edueditor_styleclass_14 edueditor_styleclass_20"><br>数字特征值<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_13 edueditor_styleclass_15 edueditor_styleclass_21"><br><strong>题目内容：</strong><br><br>对数字求特征值是常用的编码算法，奇偶特征是一种简单的特征值。对于一个整数，从个位开始对每一位数字编号，个位是1号，十位是2号，以此类推。这个整数在第n位上的数字记作x，如果x和n的奇偶性相同，则记下一个1，否则记下一个0。按照整数的顺序把对应位的表示奇偶性的0和1都记录下来，就形成了一个二进制数字。比如，对于342315，这个二进制数字就是001101。<br><br>这里的计算可以用下面的表格来表示：<br><br><table border="1" cellspacing="0" cellpadding="0" style="border:currentColor; white-space:normal"><br><tbody><br><tr><br><td width="80" valign="top" style="border-color:windowtext; padding:0px 7px; width:106px"><br><span style="font-family:宋体">数字</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-top-color:windowtext; border-right-color:windowtext; border-bottom-color:windowtext; border-left-style:none"><br>3<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-top-color:windowtext; border-right-color:windowtext; border-bottom-color:windowtext; border-left-style:none"><br>4<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-top-color:windowtext; border-right-color:windowtext; border-bottom-color:windowtext; border-left-style:none"><br>2<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-top-color:windowtext; border-right-color:windowtext; border-bottom-color:windowtext; border-left-style:none"><br>3<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-top-color:windowtext; border-right-color:windowtext; border-bottom-color:windowtext; border-left-style:none"><br>1<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-top-color:windowtext; border-right-color:windowtext; border-bottom-color:windowtext; border-left-style:none"><br>5<br></td><br></tr><br><tr><br><td width="80" valign="top" style="padding:0px 7px; width:106px; border-right-color:windowtext; border-bottom-color:windowtext; border-left-color:windowtext; border-top-style:none"><br><span style="font-family:宋体">数位</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>6<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>5<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>4<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>3<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>2<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>1<br></td><br></tr><br><tr><br><td width="80" valign="top" style="padding:0px 7px; width:106px; border-right-color:windowtext; border-bottom-color:windowtext; border-left-color:windowtext; border-top-style:none"><br><span style="font-family:宋体">数字奇偶</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">奇</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">偶</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">偶</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">奇</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">奇</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">奇</span><br></td><br></tr><br><tr><br><td width="80" valign="top" style="padding:0px 7px; width:106px; border-right-color:windowtext; border-bottom-color:windowtext; border-left-color:windowtext; border-top-style:none"><br><span style="font-family:宋体">数位奇偶</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">偶</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">奇</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">偶</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">奇</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">偶</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br><span style="font-family:宋体">奇</span><br></td><br></tr><br><tr><br><td width="80" valign="top" style="padding:0px 7px; width:106px; border-right-color:windowtext; border-bottom-color:windowtext; border-left-color:windowtext; border-top-style:none"><br><span style="font-family:宋体">奇偶一致</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>0<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>0<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>1<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>1<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>0<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>1<br></td><br></tr><br><tr><br><td width="80" valign="top" style="padding:0px 7px; width:106px; border-right-color:windowtext; border-bottom-color:windowtext; border-left-color:windowtext; border-top-style:none"><br><span style="font-family:宋体">二进制位值</span><br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>32<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>16<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>8<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>4<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>2<br></td><br><td width="32" valign="top" style="padding:0px 7px; width:42px; border-right-color:windowtext; border-bottom-color:windowtext; border-top-style:none; border-left-style:none"><br>1<br></td><br></tr><br></tbody><br></table><br><br>你的程序要读入一个非负整数，整数的范围是[0,1000000]，然后按照上述算法计算出表示奇偶性的那个二进制数字，输出它对应的十进制值。<br><br><em>提示：将整数从右向左分解，数位每次加1，而二进制值每次乘2。</em><br><br>_<br><br>_<br><br><strong>输入格式:</strong><br><br>一个非负整数，整数的范围是[0,1000000]。<br><br><strong>输出格式：</strong><br><br>一个整数，表示计算结果。<br><br><strong>输入样例：</strong><br><br>342315<br><br><strong>输出样例：</strong><br><br>13<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code"># include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int a,m,two = 1,s = 0;<br>    int cout = 0;<br>    scanf(“%d”,&amp;a);<br>        while(a != 0) {<br>    m = a % 10;<br>    a /= 10;<br>    ++cout;<br>    if(m % 2 == cout % 2) {<br>        s += two;<br>    }<br>    two *= 2;<br><br>}<br>printf(“%d\n”,s);<br>    return 0;<br>}</pre><br><br></div><br><div class="j-limit f-fc6 limit f-fs0"></div><br></div><br></div><br></div><br></div><br></div><br><div class="j-previewStatus"></div><br></div><br></div><br><div class="m-chapterQuizHwItem"><br><br>### 第4周：循环控制<br><br><div class="u-quizHwListItem f-pr last down"><br><div class="titleBox j-titleBox f-cb" id="auto-id-pzwiAE0tsNlxuDt5"><br><div class="f-icon qhicon f-fc9 j-up f-fl"></div><br><div class="f-icon qhicon f-fc9 j-down f-fl"></div><br><div class="f-icon qhicon j-noContent f-fl">&nbsp;</div>

<h4 id="第4周编程练习"><a href="#第4周编程练习" class="headerlink" title="第4周编程练习"></a>第4周编程练习</h4><div class="j-submitTime score f-fl">截止时间：2015年5月4日 0:00</div><br><a target="_blank" class="j-quizBtn u-btn u-btn-default f-fr" id="auto-id-47g1kfzkqpapcFA1">前往作业</a><br><div class="j-validScore score f-fr"></div><br></div><br><div class="detail j-detail"><br><div class="u-quizHwInfoItem"><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业类型</div><br><div class="f-fl right">Online Judge作业</div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业截止时间</div><br><div class="f-fl right right1"><br><div class="j-submitTime">2015年5月4日 0:00</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">成绩公布时间</div><br><div class="f-fl right right1 j-publishTime">2015年5月4日 0:00</div><br><div class="f-fl right right1 j-publishTime"><br><div class="position f-fl">1</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_16 edueditor_styleclass_18 edueditor_styleclass_24 edueditor_styleclass_26"><br>素数和<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_17 edueditor_styleclass_19 edueditor_styleclass_25 edueditor_styleclass_27"><br><strong>题目内容：</strong><br><br>我们认为2是第一个素数，3是第二个素数，5是第三个素数，依次类推。<br><br>现在，给定两个整数n和m，0&lt;n&lt;=m&lt;=200，你的程序要计算第n个素数到第m个素数之间所有的素数的和，包括第n个素数和第m个素数。<br><br><strong>输入格式:</strong><br><br>两个整数，第一个表示n，第二个表示m。<br><br><strong>输出格式：</strong><br><br>一个整数，表示第n个素数到第m个素数之间所有的素数的和，包括第n个素数和第m个素数。<br><br><strong>输入样例：</strong><br><br>2 4<br><br><strong>输出样例：</strong><br><br>15<br><br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code">#include &lt;stdio.h&gt;<br>int isPrime(long n);<br>int main(int argc, char const <em>argv[])<br><br>{<br>    int n, m, count;<br>    long l, sum;<br>    while(1) {<br>        scanf(“%d%d”, &amp;n, &amp;m);<br>        if (n &gt; 0 &amp;&amp; n &lt;= m &amp;&amp; m &lt;= 200) break;<br>    }<br>    count = 0; sum = 0; l = 2;<br>    do {<br>        if (isPrime(l)) {<br>            count ++;<br>            if (count &gt;= n) sum += l;<br>        }<br>        l++;<br>    } while (count &lt; m);<br>    printf(“%d\n”, sum);<br>    return 0;<br>}<br>int isPrime(long n)<br>{<br>    int i;<br>    if (n == 2)<br>        return 1;<br>    for (i = 2; i</em>i &lt;= n;i++)<br>        if (n % i == 0)<br>             return 0;<br>     return 1;<br>}</pre><br><div class="position f-fl">2</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_12 edueditor_styleclass_14 edueditor_styleclass_20 edueditor_styleclass_22 edueditor_styleclass_28"><br>念整数<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_13 edueditor_styleclass_15 edueditor_styleclass_21 edueditor_styleclass_23 edueditor_styleclass_29"><br><strong>题目内容：</strong><br><br>你的程序要读入一个整数，范围是[-100000,100000]。然后，用汉语拼音将这个整数的每一位输出出来。<br><br>如输入1234，则输出：<br><br>yi er san si<br><br>注意，每个字的拼音之间有一个空格，但是最后的字后面没有空格。当遇到负数时，在输出的开头加上“fu”，如-2341输出为：<br><br>fu er san si yi<br><br><strong>输入格式:</strong><br><br>一个整数，范围是[-100000,100000]。<br><br><strong>输出格式：</strong><br><br>表示这个整数的每一位数字的汉语拼音，每一位数字的拼音之间以空格分隔，末尾没有空格。<br><br><strong>输入样例：</strong><br><br>-30<br><br><strong>输出样例：</strong><br><br>fu san ling<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code"># include &lt;stdio.h&gt;<br># include &lt;math.h&gt;<br>int main()<br>{<br>    int n,c = 0;<br>    scanf(“%d”,&amp;n);<br>    if(n == 0){<br>    printf(“ling”);<br>    }<br>    else{<br>        if(n &lt; 0){<br>        printf(“fu “);<br>        n = -n;<br>        }<br>        int t = n;<br>        while(t != 0){<br>            t /= 10;<br>            ++c;<br>        }<br>        int w = n,p,z;<br>        while(c &gt; 0){<br>        z = pow(10.0,c-1);<br>        p = w / z;<br>        if(p == 0){<br>            printf(“ling”);<br>        }<br>        else if(p == 1){<br>            printf(“yi”);<br>        }<br>        else if(p == 2){<br>            printf(“er”);<br>        }<br>        else if(p == 3){<br>            printf(“san”);<br>        }<br>        else if(p == 4){<br>            printf(“si”);<br>        }<br>        else if(p == 5){<br>            printf(“wu”);<br>        }<br>        else if(p == 6){<br>            printf(“liu”);<br>        }<br>        else if(p == 7){<br>            printf(“qi”);<br>        }<br>        else if(p == 8){<br>            printf(“ba”);<br>        }<br>        else if(p == 9){<br>            printf(“jiu”);<br>        }<br>        if(c != 1){<br>            printf(“ “);<br>        }<br>        c–;<br>        w = w - p*z;<br><br>        }<br>    }<br><br>    return 0;<br> }</pre><br><br></div><br><div class="j-limit f-fc6 limit f-fs0"></div><br></div><br></div><br></div><br></div><br></div><br><div class="j-previewStatus"></div><br></div><br></div><br><div class="m-chapterQuizHwItem"><br><br>### 第5周：数据类型<br><br><div class="u-quizHwListItem f-pr down"><br><div class="titleBox j-titleBox f-cb" id="auto-id-q7p6b4GIPgp5mSlB"><br><div class="f-icon qhicon f-fc9 j-up f-fl"></div><br><div class="f-icon qhicon f-fc9 j-down f-fl"></div><br><div class="f-icon qhicon j-noContent f-fl">&nbsp;</div>

<h4 id="第一次单元测验"><a href="#第一次单元测验" class="headerlink" title="第一次单元测验"></a>第一次单元测验</h4><div class="j-submitTime score f-fl">截止时间：2015年5月4日 0:00</div><br><a target="_blank" class="j-quizBtn u-btn u-btn-default f-fr" id="auto-id-E2GreDoA9T9oHpkT">前往测验</a><br><div class="j-validScore score f-fr">测验得分：30.00分</div><br></div><br><div class="detail j-detail"><br><div class="u-quizHwInfoItem auto-1430044117559-parent"><br><div class="infoItem f-cb"><br><div class="f-fl">截止时间</div><br><div class="f-fl right"><br><div class="j-submitTime">2015年5月4日 0:00</div><br><div class="gray">请务必在截止时间之前提交，截止时间后的提交不再计分</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl">有效分数</div><br><div class="f-fl right"><br><div class="j-validScore">30.00/30.00</div><br><div class="gray">你的每一次测验系统都将为你计分，并提取<span class="j-scoreType">最高得分</span>作为你的有效分数</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl">有效提交次数</div><br><div class="f-fl right right1 j-submitCount">2/2</div><br></div><br><div class="auto-1430044117559"><br><div><br><br>## 第一次单元测验<br><br><a target="_blank" class="j-backList backbtn f-fr f-fc9" id="auto-id-qOnGTRLw943aUUwF"><span class="f-icon"></span> 返回</a><br><div class="totalScore f-f0 j-scoreInfo">本次得分为：<strong>30.00/30.00</strong>, 本次测试的提交时间为：<strong>2015-03-31</strong>, 如果你认为本次测试成绩不理想，你可以选择<a target="_blank" class="j-doAgain" id="auto-id-mdmEf6tTZAs3ib2E">再做一次</a>，也可以去<a href="http://www.icourse163.org/learn/zju-199001#/learn/forumtopic?fid=283028" target="_blank" rel="noopener">测验作业讨论区</a>分享你的测试成绩和想法。</div><br><div class="j-warnTip warnTip f-dn"></div><br><div class="j-quizPool analysisModule auto-1430045508236-parent"><br><div class="m-basepool f-cb auto-1430045508236"><br><div class="j-list"><br><div class="m-data-lists f-cb f-pr j-data-list"><br><div class="m-choiceQuestion u-questionItem analysisMode first"><br><div class="j-title title f-cb"><br><div class="position f-fl">1</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_0">以下代码片段的输出是：<br><br><span></span><br><br><span></span><br><br><span>int j=4;</span><br><br><span>for ( int i=j; i&lt;=2<em>j; i++ ) {</em></span><br><br><span>switch ( i/j ) {</span><br><br><span>case 0:</span><br><br><span>case 1: printf(“”); break;</span><br><br><span>case 2: printf(“#”);</span><br><br><span>}</span><br><br><span>}</span><br></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></div><br><div class="j-choicebox"><br><br>*   <input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_1"><br><em>**</em><br></div><br><div class="score f-fr"></div>

<ul>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_2"><br>*#<br></div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_3"><br><em>**</em>#<br></div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_4"><br>***#<br></div><br><div class="score f-fr"></div><br></p></li></ul></div><br></div><br><div class="m-choiceQuestion u-questionItem analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">2</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_5">下列程序段输出结果为：<p></p>


<div></div>

<div>int x=1, y=012;</div><br><div>printf(“%d”,y<em>x++);</em></div><br></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></div><br><div class="j-choicebox">

   <input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_6">12</div><br><div class="score f-fr"></div>

<ul>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_7">20</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_8">24</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label><br><div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_9">10</div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div><br></p></li></ul></div><br></div><br><div class="m-choiceQuestion u-questionItem analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">3</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_10">以下哪个不是C语言的关键字？</div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></div><p></p>
<div class="j-choicebox">

<li><p><input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label></p>
<div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_11">include</div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_12">int</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_13">if</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_14">for</div><br><div class="score f-fr"></div><br></p></li></div><br></div><br><div class="m-choiceQuestion u-questionItem analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">4</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_15">以下哪个直接量是十进制的124？</div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></div><p></p>
<div class="j-choicebox">

<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_16">124d</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_17">0124</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_18">0x124</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label></p>
<div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_19">124</div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div><br></li></div><br></div><br><div class="m-choiceQuestion u-questionItem analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">5</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_20"><br><div>对于以下代码：</div><br><div><span></span>int i=6;</div><br><div><span></span></div>



<div><span></span>if ( i&lt;= 6 )&nbsp;</div><br><div><span></span>printf(“hello\n”);;</div><br><div><span></span>else</div><br><div><span></span>printf(“bye-bye\n”);;</div><br><div></div><br><div>哪句话是对的？</div><br></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></div><br><div class="j-choicebox"><br><br>*   <input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_21">打印出”hello”</div><br><div class="score f-fr"></div>

<ul>
<li><p><input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_22">无法编译</div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_23">打印出”hello bye-bye”</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_24">打印出”bye-bye”</div><br><div class="score f-fr"></div><br></p></li></ul></div><br></div><br><div class="m-choiceQuestion u-questionItem analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">6</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_25"><br><div>对于以下代码：</div><br><div>`int i,j=6;<p></p>


<p>`</p></div><p></p>
<div>以下哪句话是对的？</div><br></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></div><br><div class="j-choicebox"><br><br>*   <input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label><br><div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_26">i不会被初始化，而j是6</div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div>

<ul>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_27">i被初始为0，而j是6</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_28">i和j的初始值都是6</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_29">不能通过编译</div><br><div class="score f-fr"></div><br></li></ul></div><br></div><br><div class="m-choiceQuestion u-questionItem analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">7</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_30"><br><div>对于以下代码：</div><br><div><span></span></div>



<div><span></span>char ch = -1;</div><br><div><span></span>printf(“%d\n”, ch);</div><br><div></div>

<div>输出结果是？</div><br></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></div><br><div class="j-choicebox"><br><br>*   <input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_31">255</div><br><div class="score f-fr"></div>

<ul>
<li><p><input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_32">-1</div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_33">编译错误，因为赋值的时候类型不一致</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_34">编译错误，因为赋值的时候不能把负数赋给char</div><br><div class="score f-fr"></div><br></li></ul></div><br></div><br><div class="m-choiceQuestion u-questionItem analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">8</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_35"><br><div>对于以下代码：</div><br><div><span></span></div>



<div>int i=6;</div><br><div>do {</div><br><div><span></span>printf(“%d”, i–);</div><br><div>} while (0);</div><br><div></div><br><div>哪句话是对的？</div><br></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></div><br><div class="j-choicebox"><br><br>*   <input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_36">打印不出东西</div><br><div class="score f-fr"></div>

<ul>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_37">因为while(0)，无法编译</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_38">打印出6</div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_39">打印出5</div><br><div class="score f-fr"></div><br></p></li></ul></div><br></div><br><div class="m-choiceQuestion u-questionItem analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">9</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_40"><br>对于以下代码：<p></p>


<p><code>int i;</code></p>
<p><code>for ( i=0; i&lt;10; i++)</code></p>
<p><code>printf(&quot;%d&quot;, i);</code><br>`</p>
<p>`</p>
<p>for循环结束后，i的值是多少？<br></p></div><br></div><p></p>
<p><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></p></div><p></p>
<div class="j-choicebox"><br><br>*   <input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_41"><br>9<br></div><br><div class="score f-fr"></div>

<ul>
<li><p><input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_42"><br>10<br></div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_43"><br>11<br></div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label><br><div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_44"><br>i没有确定的值<br></div><br><div class="score f-fr"></div><br></p></li></ul></div><br></div><br><div class="m-choiceQuestion u-questionItem analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">10</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="dan">单选</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_45">以下哪个for语句是错误的？</div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel" style="display:block">得分/总分</label></div><p></p>
<div class="j-choicebox">

<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">A.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_46">for (i=0; i&lt;10, j&lt;10; i++);</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">B.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_47">for (i=0; i&lt;10; i–);</div><br><div class="score f-fr"></div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"><label class="u-tbl f-pr f-cb"></label></p>
<div class="f-fl optionPos">C.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_48">for (i=0; i++ );</div><br><div class="score f-fr"><span class="f-icon"></span> 2.00 /2.00 </div>
</li>
<li><p><input disabled="true" class="u-tbi" type="radio"> <label class="u-tbl f-pr f-cb"><br></label></p>
<div class="f-fl optionPos">D.</div><br><div class="f-fl f-richEditorText optionCnt f-thide edueditor_styleclass_49">for (;;);</div><br><div class="score f-fr"></div><br></li></div><br></div><br><div class="m-FillBlank u-questionItem f-pr analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">11</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="pan">填空</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_50">表达式ch =‘B’+‘8’-‘3’表示的字符是：</div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel">得分/总分</label></div><br><div class="f-cb inputArea"><br><div class="f-fl j-input input"><br><div class="u-baseinputui u-baseinputui-disable" style="width:250px; height:35px"><br><textarea name="inputtxt" disabled="disabled" class="j-textarea inputtxt" id="auto-id-E8DEcNJbTqEC2f9Z" style="width: 240px; height: 25px;">G</textarea><label class="j-hint inputhint" id="auto-id-Ugn35uQIsPx2UdRC" for="inputtxt">请输入答案</label></div><br></div><br><div class="score f-fr f-fn j-score right"><span class="f-icon"></span> 2.00/2.00</div><br></div><br><div class="analysisInfo f-dn j-analysis"></div><br></div><br><div class="m-FillBlank u-questionItem f-pr analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">12</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="pan">填空</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_51"><br><div>以下代码的输出是 <strong>_</strong>.</div><br><div></div>



<div>int x=0, y=0, z=0;</div><br><div>z = (x==1) &amp;&amp; (y=2);</div><br><div>printf(“%d “, y);</div><br><div></div><br></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel">得分/总分</label></div><br><div class="f-cb inputArea"><br><div class="f-fl j-input input"><br><div class="u-baseinputui u-baseinputui-disable" style="width:250px; height:35px"><br><textarea name="inputtxt" disabled="disabled" class="j-textarea inputtxt" id="auto-id-yPhdMicgWb4Me3XR" style="width: 240px; height: 25px;">0</textarea><label class="j-hint inputhint" id="auto-id-eomn1yKhwOugSXAE" for="inputtxt">请输入答案</label></div><br></div><br><div class="score f-fr f-fn j-score right"><span class="f-icon"></span> 2.00/2.00</div><br></div><br><div class="analysisInfo f-dn j-analysis"></div><br></div><br><div class="m-FillBlank u-questionItem f-pr analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">13</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="pan">填空</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_52">以下代码段的结果是：<br><br><code>int i=10;

long long t = sizeof(i++);

printf(&quot;%d&quot;, i);</code></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel">得分/总分</label></div><br><div class="f-cb inputArea"><br><div class="f-fl j-input input"><br><div class="u-baseinputui u-baseinputui-disable" style="width:250px; height:35px"><br><textarea name="inputtxt" disabled="disabled" class="j-textarea inputtxt" id="auto-id-ganxOBKzBHFEQzbu" style="width: 240px; height: 25px;">10</textarea><label class="j-hint inputhint" id="auto-id-oyrbVDeeOtDw36XE" for="inputtxt">请输入答案</label></div><br></div><br><div class="score f-fr f-fn j-score right"><span class="f-icon"></span> 2.00/2.00</div><br></div><br><div class="analysisInfo f-dn j-analysis"></div><br></div><br><div class="m-FillBlank u-questionItem f-pr analysisMode"><br><div class="j-title title f-cb"><br><div class="position f-fl">14</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="pan">填空</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_53"><br>表达式<code>(double)(10/4*4)</code> 的结果是<strong>_</strong><br></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel">得分/总分</label></div><br><div class="f-cb inputArea"><br><div class="f-fl j-input input"><br><div class="u-baseinputui u-baseinputui-disable" style="width:250px; height:35px"><br><textarea name="inputtxt" disabled="disabled" class="j-textarea inputtxt" id="auto-id-mGHr3gxG7T1Ps4ye" style="width: 240px; height: 25px;">8.000000</textarea><label class="j-hint inputhint" id="auto-id-hbTDUb3JUx6kEJWO" for="inputtxt">请输入答案</label></div><br></div><br><div class="score f-fr f-fn j-score right"><span class="f-icon"></span> 2.00/2.00</div><br></div><br><div class="analysisInfo f-dn j-analysis"></div><br></div><br><div class="m-FillBlank u-questionItem f-pr analysisMode last"><br><div class="j-title title f-cb"><br><div class="position f-fl">15</div><br><div class="qaDescription f-fl f-cb"><br><div class="qaCate j-qacate f-fl"><span class="pan">填空</span>(2分)</div><br><div class="f-richEditorText j-richTxt edueditor_styleclass_54"><br><div>以下代码的输出是 ：</div><br><div></div>

<div>int i,x,y;i=x=y=0;do {++i;if ( i%2 ) x+=i, i++;y +=i++;} while ( i&lt;=7 );printf(“%d %d %d”, i, x, y);</div><br></div><br></div><br><label class="scoreLabel f-fr f-dn j-scoreLabel">得分/总分</label></div><br><div class="f-cb inputArea"><br><div class="f-fl j-input input"><br><div class="u-baseinputui u-baseinputui-disable" style="width:250px; height:35px"><br><textarea name="inputtxt" disabled="disabled" class="j-textarea inputtxt" id="auto-id-FUrIe8S7WkEI882o" style="width: 240px; height: 25px;">9 1 20</textarea></div><br></div><br></div><br></div><br></div><br></div><br></div><br></div><br></div><br></div><br></div><br></div><br><div class="j-previewStatus"></div><br></div><br><div class="u-quizHwListItem f-pr last down"><br><div class="titleBox j-titleBox f-cb" id="auto-id-CKPn1kuR5KLAam82"><br><div class="f-icon qhicon f-fc9 j-up f-fl"></div><br><div class="f-icon qhicon f-fc9 j-down f-fl"></div><br><div class="f-icon qhicon j-noContent f-fl">&nbsp;</div>

<h4 id="第5周编程练习"><a href="#第5周编程练习" class="headerlink" title="第5周编程练习"></a>第5周编程练习</h4><div class="j-submitTime score f-fl">截止时间：2015年5月4日 0:00</div><br><a target="_blank" class="j-quizBtn u-btn u-btn-default f-fr" id="auto-id-ZEhzrv87kSqvKR9q">前往作业</a><br><div class="j-validScore score f-fr"></div><br></div><br><div class="detail j-detail"><br><div class="u-quizHwInfoItem"><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业类型</div><br><div class="f-fl right">Online Judge作业</div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业截止时间</div><br><div class="f-fl right right1"><br><div class="j-submitTime">2015年5月4日 0:00</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">成绩公布时间</div><br><div class="f-fl right right1 j-publishTime">2015年5月5日 0:00</div><br><div class="f-fl right right1 j-publishTime"><br><br></div><br><div class="f-fl right right1 j-publishTime"><br><div class="position f-fl">1</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_12 edueditor_styleclass_14 edueditor_styleclass_20 edueditor_styleclass_22 edueditor_styleclass_28 edueditor_styleclass_30"><br>高精度小数<span>（10分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_13 edueditor_styleclass_15 edueditor_styleclass_21 edueditor_styleclass_23 edueditor_styleclass_29 edueditor_styleclass_31"><br><strong>题目内容：</strong><br><br>由于计算机内部表达方式的限制，浮点运算都有精度问题，为了得到高精度的计算结果，就需要自己设计实现方法。<br><br>(0,1)之间的任何浮点数都可以表达为两个正整数的商，为了表达这样两个数的商，可以将相除的结果以多个整数来表示，每个整数表示结果的一位。即商的第一位用一个整数来表示，第二位用另一个整数来表示，以此类推，就可以输出一个高精度的除法结果了。<br><br>如16/19的结果0.8421052631…就可以依次输出8、4、2、1、0、5、2、6、3、1…。<br><br>而除法的过程，则可以模仿人工列竖式做除法的方式，先将被除数乘以10，得到一位商以后，将余数乘以10作为下一轮计算的被除数：<br><br>&nbsp; &nbsp; 160/19-&gt;8余8<br><br>&nbsp; &nbsp; 80/19-&gt;4余4<br><br>&nbsp; &nbsp; …<br><br>当某次余数为0时，则表明除尽。<br><br>现在，请写一个程序，输入一个分数，计算出它的小数形式。无论是否可以除尽，输出最多小数点后200位。<br><br><strong>输入格式:</strong><br><br>形如<br><br>&nbsp; &nbsp; a/b<br><br>的两个数，其中10&lt;=a&lt;b&lt;100。也就是说，这个小数一定是小于1的正数。<br><br>提示：输入是带着两个数中间的“/”的，所以scanf应采用“%d/%d”这样的输入格式。<br><br><strong>输出格式：</strong><br><br>形如<br><br>&nbsp; &nbsp; 0.xxxxxxxxx<br><br>的小数，小数点后最多200位。输出结束的时候要带着回车换行。如果a/b是一个有限不循环小数，则输出完所有的有效位就可以了，不需要再输出后面的0来凑满200位。<br><br><strong>输入样例：</strong><br><br>16/19<br><br><strong>输出样例：</strong><br><br>0.84210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684210526315789473684<br><br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code"># include &lt;stdio.h&gt;<br>int main()<br>{<br>    int n,m,c = 0;<br>    scanf(“%d/%d”,&amp;n,&amp;m);<br>    printf(“0.”);<br>    while ( c &lt; 200) {<br>        c++;<br>        n *= 10;<br>        printf(“%d”,n/m);<br>        n %= m;<br>        if ( n == 0)<br>        break;<br>    }<br><br>    return 0;<br>}</pre><br><br></div><br></div><br></div><br></div><br></div><br><div class="j-previewStatus"></div><br></div><br></div><br><div class="m-chapterQuizHwItem"><br><br>### 第6周：函数<br><br><div class="u-quizHwListItem f-pr last down"><br><div class="titleBox j-titleBox f-cb" id="auto-id-cCTUJtvZTlKpyBM8"><br><div class="f-icon qhicon f-fc9 j-up f-fl"></div><br><div class="f-icon qhicon f-fc9 j-down f-fl"></div><br><div class="f-icon qhicon j-noContent f-fl">&nbsp;</div>

<h4 id="第6周编程练习"><a href="#第6周编程练习" class="headerlink" title="第6周编程练习"></a>第6周编程练习</h4><div class="j-submitTime score f-fl">截止时间：2015年5月4日 0:00</div><br><a target="_blank" class="j-quizBtn u-btn u-btn-default f-fr" id="auto-id-KMo1QCt4tLu3VobK">前往作业</a><br><div class="j-validScore score f-fr"></div><br></div><br><div class="detail j-detail"><br><div class="u-quizHwInfoItem"><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业类型</div><br><div class="f-fl right">Online Judge作业</div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业截止时间</div><br><div class="f-fl right right1"><br><div class="j-submitTime">2015年5月4日 0:00</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">成绩公布时间</div><br><div class="f-fl right right1 j-publishTime">2015年5月5日 0:00</div><br><div class="f-fl right right1 j-publishTime"><br><br></div><br><div class="f-fl right right1 j-publishTime"><br><div class="position f-fl">1</div><br><div class="position f-fl">分解质因数<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_17 edueditor_styleclass_19 edueditor_styleclass_25 edueditor_styleclass_27 edueditor_styleclass_33"><br><strong>题目内容：</strong><br><br>每个非素数（合数）都可以写成几个素数（也可称为质数）相乘的形式，这几个素数就都叫做这个合数的质因数。比如，6可以被分解为2x3，而24可以被分解为2x2x2x3。<br><br>现在，你的程序要读入一个[2,100000]范围内的整数，然后输出它的质因数分解式；当读到的就是素数时，输出它本身。<br><br>提示：可以用一个函数来判断某数是否是素数。<br><br><strong>输入格式:</strong><br><br>一个整数，范围在[2,100000]内。<br><br><strong>输出格式：</strong><br><br>形如：<br><br>n=axbxcxd<br><br>或<br><br>n=n<br><br>所有的符号之间都没有空格，x是小写字母x。abcd这样的数字一定是从小到大排列的。<br><br><strong>输入样例：</strong><br><br>18<br><br><strong>输出样例：</strong><br><br>18=2x3x3<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span><br><br></span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code"># include &lt;stdio.h&gt;<br>int is(int i) {<br>    int j;<br>    for ( j = 2; j &lt; i; ++j ) {<br>        if ( i%j == 0)<br>        break;<br>    }<br>    if ( j != i)<br>    return 0;<br>    else<br>    return 1;<br>}<br>int main()<br>{<br>    int n,i;<br>    scanf(“%d”,&amp;n);<br>    printf(“%d=”,n);<br>    if ( is(n))<br>    printf(“%d\n”,n);<br><br>    else<br>    {<br>        while ( n != 1 ){<br>            for ( i = 2; i &lt;= n; ++i) {<br>                if (is(i) &amp;&amp; n%i == 0){<br>                    printf(“%d”,i);<br>                    if ( i != n)<br>                    printf(“x”);<br>                    else<br>                    printf(“\n”);<br>                    n /= i;<br>                    i = 1;<br>                }<br>            }<br>        }<br><br>    }<br><br>    return 0;<br>}</pre><br><div class="position f-fl">2</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_12 edueditor_styleclass_14 edueditor_styleclass_20 edueditor_styleclass_22 edueditor_styleclass_28 edueditor_styleclass_30 edueditor_styleclass_34"><br>完数<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_13 edueditor_styleclass_15 edueditor_styleclass_21 edueditor_styleclass_23 edueditor_styleclass_29 edueditor_styleclass_31 edueditor_styleclass_35"><br><strong>题目内容：</strong><br><br>一个正整数的因子是所有可以整除它的正整数。而一个数如果恰好等于除它本身外的因子之和，这个数就称为完数。例如6=1＋2＋3(6的因子是1,2,3)。<br><br>现在，你要写一个程序，读入两个正整数n和m（1&lt;=n&lt;m&lt;1000），输出[n,m]范围内所有的完数。<br><br>提示：可以写一个函数来判断某个数是否是完数。<br><br><strong>输入格式:</strong><br><br>两个正整数，以空格分隔。<br><br><strong>输出格式：</strong><br><br>其间所有的完数，以空格分隔，最后一个数字后面没有空格。如果没有，则输出一行文字：<br><br>NIL<br><br>（输出NIL三个大写字母加回车）。<br><br><strong>输入样例：</strong><br><br>1 10<br><br><strong>输出样例：</strong><br><br>6<br><br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code"># include &lt;stdio.h&gt;<br>int w(int n)<br>{<br><br>int i,s = 0;<br><br>    for ( i = 1; i &lt; n; ++i) {<br>        if ( n%i == 0){<br>            s += i;<br>        }<br>    }<br>    if ( n == s)<br>    return 1;<br>    else<br>    return 0;<br>}<br>int main()<br>{<br>    int i,j,k,c = 0;<br>    scanf(“%d%d”,&amp;i,&amp;j);<br>    for ( k = i; k &lt;= j; ++k) {<br>        if (w(k)) {<br>            if ( c == 2)<br>            printf(“ “);<br><br>            printf(“%d”,k);<br>                c = 1;<br>                c++;<br><br>        }<br>    }<br>    if ( k == j+1 &amp;&amp; c != 0)<br>    printf(“\n”);<br>    if (c == 0 )<br>    printf(“NIL\n”);<br>    return 0;<br>}</pre><br><br></div><br><div class="j-limit f-fc6 limit f-fs0"></div><br></div><br></div><br></div><br></div><br></div><br><div class="j-previewStatus"></div><br></div><br></div><br><div class="m-chapterQuizHwItem"><br><br>### 第7周：数组<br><br><div class="u-quizHwListItem f-pr last down"><br><div class="titleBox j-titleBox f-cb" id="auto-id-34olZecLTWI0q447"><br><div class="f-icon qhicon f-fc9 j-up f-fl"></div><br><div class="f-icon qhicon f-fc9 j-down f-fl"></div><br><div class="f-icon qhicon j-noContent f-fl">&nbsp;</div>

<h4 id="第7周编程练习"><a href="#第7周编程练习" class="headerlink" title="第7周编程练习"></a>第7周编程练习</h4><div class="j-submitTime score f-fl">截止时间：2015年5月4日 0:00</div><br><a target="_blank" class="j-quizBtn u-btn u-btn-default f-fr" id="auto-id-oC8Z3UPl16qvTRzG">前往作业</a><br><div class="j-validScore score f-fr"></div><br></div><br><div class="detail j-detail"><br><div class="u-quizHwInfoItem"><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业类型</div><br><div class="f-fl right">Online Judge作业</div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业截止时间</div><br><div class="f-fl right right1"><br><div class="j-submitTime">2015年5月4日 0:00</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">成绩公布时间</div><br><div class="f-fl right right1 j-publishTime">2015年5月5日 0:00</div><br><div class="f-fl right right1 j-publishTime"><br><br></div><br><div class="f-fl right right1 j-publishTime"><br><div class="position f-fl">1</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_12 edueditor_styleclass_14 edueditor_styleclass_20 edueditor_styleclass_22 edueditor_styleclass_28 edueditor_styleclass_30 edueditor_styleclass_34 edueditor_styleclass_36"><br>多项式加法<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_13 edueditor_styleclass_15 edueditor_styleclass_21 edueditor_styleclass_23 edueditor_styleclass_29 edueditor_styleclass_31 edueditor_styleclass_35 edueditor_styleclass_37"><br><strong>题目内容：</strong><br><br>一个多项式可以表达为x的各次幂与系数乘积的和，比如：<br><br>2x6+3x5+12x3+6x+20<br><br>现在，你的程序要读入两个多项式，然后输出这两个多项式的和，也就是把对应的幂上的系数相加然后输出。<br><br>程序要处理的幂最大为100。<br><br><strong>输入格式:</strong><br><br>总共要输入两个多项式，每个多项式的输入格式如下：<br><br>每行输入两个数字，第一个表示幂次，第二个表示该幂次的系数，所有的系数都是整数。第一行一定是最高幂，最后一行一定是0次幂。<br><br>注意第一行和最后一行之间不一定按照幂次降低顺序排列；如果某个幂次的系数为0，就不出现在输入数据中了；0次幂的系数为0时还是会出现在输入数据中。<br><br><strong>输出格式：</strong><br><br>从最高幂开始依次降到0幂，如：<br><br>2x6+3x5+12x3-6x+20<br><br>注意其中的x是小写字母x，而且所有的符号之间都没有空格，如果某个幂的系数为0则不需要有那项。<br><br><strong>输入样例：</strong><br><br>6 2<br><br>5 3<br><br>3 12<br><br>1 6<br><br>0 20<br><br>6 2<br><br>5 3<br><br>2 12<br><br>1 6<br><br>0 20<br><br><strong>输出样例：</strong><br><br>4x6+6x5+12x3+12x2+12x+40<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span><br><br></span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code">#include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;<br><br>void outNum(int j,int k)<br>{<br>    int absk = abs(k);<br>    if(absk==1 &amp;&amp; j!=1 &amp;&amp; j!=0)<br>    {<br>        printf(“x%d”,j);<br>    }<br>    else if(absk==1 &amp;&amp; j!=0)<br>    {<br>        printf(“x”);<br>    }<br>    else if(absk==1)<br>    {<br>        printf(“%d”,absk);<br>    }<br>    else if(j==0)<br>    {<br>        printf(“%d”,absk);<br>    }<br>    else if(j==1)<br>    {<br>        printf(“%dx”,absk);<br>    }<br>    else<br>    {<br>        printf(“%dx%d”,absk,j);<br>    }<br><br>}<br><br>int main()<br>{<br>    int num[101] = { (0) };<br>    int cut = 0;<br>    int ent = 0;<br>    int i,j,k;<br>    while(cut &lt; 2)<br>    {<br>        k=0;<br>        scanf(“%d %d”,&amp;j,&amp;k);<br>        num[j] += k;<br>        if(j==0)<br>            cut++;<br>    }<br><br>    for(i=100;i&gt;-1;i–)<br>    {<br>        j=i;<br>        k=num[j];<br>        if(k!=0)<br>        {<br>            ent++;<br>            if(cut==2)<br>            {<br>                if(k&lt;0)<br>                    printf(“-“);<br>                outNum(j,k);<br>                cut ++;<br>            }<br>            else<br>            {<br>                if(k&lt;0)<br>                {<br>                    printf(“-“);<br>                    outNum(j,k);<br>                }<br>                else<br>                {<br>                    printf(“+”);<br>                    outNum(j,k);<br>                }<br>            }<br>        }<br>    }<br>    if(ent==0)<br>        printf(“0”);<br><br>    return 0;<br>}</pre><br><div class="position f-fl">2</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_16 edueditor_styleclass_18 edueditor_styleclass_24 edueditor_styleclass_26 edueditor_styleclass_32 edueditor_styleclass_38"><br>鞍点<span>（5分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_17 edueditor_styleclass_19 edueditor_styleclass_25 edueditor_styleclass_27 edueditor_styleclass_33 edueditor_styleclass_39"><br><strong>题目内容：</strong><br><br>给定一个n*n矩阵A。矩阵A的鞍点是一个位置（i，j），在该位置上的元素是第i行上的最大数，第j列上的最小数。一个矩阵A也可能没有鞍点。<br><br>你的任务是找出A的鞍点。<br><br><strong>输入格式:</strong><br><br>输入的第1行是一个正整数n, （1&lt;=n&lt;=100），然后有n行，每一行有n个整数，同一行上两个整数之间有一个或多个空格。<br><br><strong>输出格式：</strong><br><br>对输入的矩阵，如果找到鞍点，就输出其下标。下标为两个数字，第一个数字是行号，第二个数字是列号，均从0开始计数。<br><br>如果找不到，就输出<br><br>NO<br><br>题目所给的数据保证了不会出现多个鞍点。<br><br><strong>输入样例：</strong><br><br>4&nbsp;<br><br>1 7 4 1&nbsp;<br><br>4 8 3 6&nbsp;<br><br>1 6 1 2&nbsp;<br><br>0 7 8 9<br><br><strong>输出样例：</strong><br><br>2 1<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span><br><br></span></div><br><span></span></div><br><div class="j-limit f-fc6 limit f-fs0"><span><span></span></span><br><div class="j-limit f-fc6 limit f-fs0"><pre class="cpp" name="code">#include &lt;stdio.h&gt;<br><br>#define M 100<br>#define N 100<br><br>int main(void) {<br>    int i,j,m,n;<br>    int max,jmax,flag,f = 1;<br>    int a[M][N];<br>    while(scanf(“%d”,&amp;n) != EOF){<br>        for(i = 0; i &lt; n; ++i)<br>        for(j = 0; j &lt; n; ++j)<br>        scanf(“%d”,&amp;a[i][j]);<br><br>        for(i = 0; i &lt; n; ++i){<br>            max = a[i][0];<br>            jmax = 0;<br>            for(j = 1; j &lt; n; ++j) {<br>                if(max &lt; a[i][j]){<br>                    max = a[i][j];<br>                    jmax = j;<br>               }<br>            }<br>            flag = 1;<br>            int ii;<br>            for(ii = 0; ii &lt; n &amp;&amp; flag; ++ii) {<br>                if(a[ii][jmax] &lt; max)<br>                    flag = 0;<br>            }<br>            if(flag == 1){<br>                printf(“%d %d\n”,i,jmax);<br>                f = 0;<br>            }<br>        }<br>        if(f) printf(“NO\n”);<br>    }<br>    return 0;<br>}</pre><br><br></div><br><div class="j-limit f-fc6 limit f-fs0"></div><br></div><br></div><br></div><br></div><br></div><br><div class="j-previewStatus"></div><br></div><br></div><br><div class="m-chapterQuizHwItem"><br><br>### 第八周：指针与字符串<br><br><div class="u-quizHwListItem f-pr last down"><br><div class="titleBox j-titleBox f-cb" id="auto-id-9pnmBdi8ZGd6BsEr"><br><div class="f-icon qhicon f-fc9 j-up f-fl"></div><br><div class="f-icon qhicon f-fc9 j-down f-fl"></div><br><div class="f-icon qhicon j-noContent f-fl">&nbsp;</div>

<h4 id="第8周编程练习"><a href="#第8周编程练习" class="headerlink" title="第8周编程练习"></a>第8周编程练习</h4><div class="j-submitTime score f-fl">截止时间：2015年5月4日 0:00</div><br><a target="_blank" class="j-quizBtn u-btn u-btn-default f-fr" id="auto-id-WQZ6Apuw6VXT2vqN">前往作业</a><br><div class="j-validScore score f-fr"></div><br></div><br><div class="detail j-detail"><br><div class="u-quizHwInfoItem"><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业类型</div><br><div class="f-fl right">Online Judge作业</div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">作业截止时间</div><br><div class="f-fl right right1"><br><div class="j-submitTime">2015年5月4日 0:00</div><br></div><br></div><br><div class="infoItem f-cb"><br><div class="f-fl ntit">成绩公布时间</div><br><div class="f-fl right right1 j-publishTime">2015年5月5日 0:00</div><br><div class="f-fl right right1 j-publishTime"><br><br></div><br><div class="f-fl right right1 j-publishTime"><br><div class="position f-fl">1</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_16 edueditor_styleclass_18 edueditor_styleclass_24 edueditor_styleclass_26 edueditor_styleclass_32 edueditor_styleclass_38 edueditor_styleclass_40"><br>单词长度<span>（4分）</span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_17 edueditor_styleclass_19 edueditor_styleclass_25 edueditor_styleclass_27 edueditor_styleclass_33 edueditor_styleclass_39 edueditor_styleclass_41"><br><strong>题目内容：</strong><br><br>你的程序要读入一行文本，其中以空格分隔为若干个单词，以‘.’结束。你要输出这行文本中每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如“it’s”算一个单词，长度为4。注意，行中可能出现连续的空格。<br><br><strong>输入格式:</strong><br><br>输入在一行中给出一行文本，以‘.’结束，结尾的句号不能计算在最后一个单词的长度内。<br><br><strong>输出格式：</strong><br><br>在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。<br><br><strong>输入样例：</strong><br><br>It’s great to see you here.<br><br><strong>输出样例：</strong><br><br>4 5 2 3 3 4<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><div class="j-limit f-fc6 limit f-fs0"><span></span><pre class="cpp" name="code">#include &lt;stdio.h&gt;<br>int main()<br>{   int i=0;<br>    char a;<br>    while(1){<br>        scanf(“%c”,&amp;a);<br>        if(a == ‘.’){<br>                        if(i!=0){<br>                                printf(“%d”,i);<br>                        }<br>                        printf(“\n”);<br>                        break;<br>                }<br>        if(a==’ ‘){<br>                        if(i!=0){<br>                                printf(“%d “,i);<br>                                i=0;<br>                        }<br>                }<br>        else{<br>                i+=1;<br>        }<br>    }<br>return 0;<br>}</pre><br><div class="position f-fl">2</div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_12 edueditor_styleclass_14 edueditor_styleclass_20 edueditor_styleclass_22 edueditor_styleclass_28 edueditor_styleclass_30 edueditor_styleclass_34 edueditor_styleclass_36 edueditor_styleclass_42"><br>GPS数据处理<span>（6分）</span></div><br><div class="qaDescription f-richEditorText f-fl edueditor_styleclass_12 edueditor_styleclass_14 edueditor_styleclass_20 edueditor_styleclass_22 edueditor_styleclass_28 edueditor_styleclass_30 edueditor_styleclass_34 edueditor_styleclass_36 edueditor_styleclass_42"><br><span><br><br></span></div><br><div class="j-detail f-richEditorText detail f-fs0 edueditor_styleclass_13 edueditor_styleclass_15 edueditor_styleclass_21 edueditor_styleclass_23 edueditor_styleclass_29 edueditor_styleclass_31 edueditor_styleclass_35 edueditor_styleclass_37 edueditor_styleclass_43"><br><strong>题目内容：</strong><br><br>NMEA-0183协议是为了在不同的GPS（全球定位系统）导航设备中建立统一的BTCM（海事无线电技术委员会）标准，由美国国家海洋电子协会（NMEA-The National Marine Electronics Associa-tion）制定的一套通讯协议。GPS接收机根据NMEA-0183协议的标准规范，将位置、速度等信息通过串口传送到PC机、PDA等设备。<br><br>NMEA-0183协议是GPS接收机应当遵守的标准协议，也是目前GPS接收机上使用最广泛的协议，大多数常见的GPS接收机、GPS数据处理软件、导航软件都遵守或者至少兼容这个协议。<br><br>NMEA-0183协议定义的语句非常多，但是常用的或者说兼容性最广的语句只有$GPGGA、$GPGSA、$GPGSV、$GPRMC、$GPVTG、$GPGLL等。<br><br>其中$GPRMC语句的格式如下：<br><br>&nbsp;&nbsp;&nbsp;&nbsp;$GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A<em>50<br><br>这里整条语句是一个文本行，行中以逗号“,”隔开各个字段，每个字段的大小（长度）不一，这里的示例只是一种可能，并不能认为字段的大小就如上述例句一样。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段0：$GPRMC，语句ID，表明该语句为Recommended Minimum Specific GPS/TRANSIT Data（RMC）推荐最小定位信息<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段1：UTC时间，hhmmss.sss格式<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段2：状态，A=定位，V=未定位<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段3：纬度ddmm.mmmm，度分格式（前导位数不足则补0）<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段4：纬度N（北纬）或S（南纬）<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段5：经度dddmm.mmmm，度分格式（前导位数不足则补0）<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段6：经度E（东经）或W（西经）<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段7：速度，节，Knots<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段8：方位角，度<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段9：UTC日期，DDMMYY格式<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段10：磁偏角，（000 - 180）度（前导位数不足则补0）<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段11：磁偏角方向，E=东W=西<br><br>&nbsp;&nbsp;&nbsp;&nbsp;字段16：校验值<br><br>这里，“</em>”为校验和识别符，其后面的两位数为校验和，代表了“$”和“<em>”之间所有字符（不包括这两个字符）的异或值的十六进制值。上面这条例句的校验和是十六进制的50，也就是十进制的80。<br><br>提示：^运算符的作用是异或。将$和</em>之间所有的字符做^运算(第一个字符和第二个字符异或，结果再和第三个字符异或，依此类推)之后的值对65536取余后的结果，应该和<em>后面的两个十六进制数字的值相等，否则的话说明这条语句在传输中发生了错误。注意这个十六进制值中是会出现A-F的大写字母的。<br><br>现在，你的程序要读入一系列GPS输出，其中包含$GPRMC，也包含其他语句。在数据的最后，有一行单独的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;END<br><br>表示数据的结束。<br><br>你的程序要从中找出$GPRMC语句，计算校验和，找出其中校验正确，并且字段2表示已定位的语句，从中计算出时间，换算成北京时间。一次数据中会包含多条$GPRMC语句，以最后一条语句得到的北京时间作为结果输出。<br><br>你的程序一定会读到一条有效的$GPRMC语句。<br><br><strong>输入格式:</strong><br><br>多条GPS语句，每条均以回车换行结束。最后一行是END三个大写字母。<br><br><strong>输出格式：</strong><br><br>6位数时间，表达为：<br><br>&nbsp;&nbsp;&nbsp;&nbsp;hh:mm:ss<br><br>其中，hh是两位数的小时，不足两位时前面补0；mm是两位数的分钟，不足两位时前面补0；ss是两位数的秒，不足两位时前面补0。<br><br><strong>输入样例：</strong><br><br>$GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A</em>50<br><br>END<br><br><strong>输出样例：</strong><br><br>10:48:13<br></div><br><div class="j-limit f-fc6 limit f-fs0"><span class="itm">时间限制：500ms</span><span>内存限制：32000kb</span></div><br><span></span></div><br><div class="j-limit f-fc6 limit f-fs0"><span><span></span></span><br><div class="j-limit f-fc6 limit f-fs0"><pre class="cpp" name="code">#include “stdio.h”<br>#include “string.h”<br>int main()<br>{<br>    int i,j,k,sum=0,r,num,t,d;<br>    char c[80][100];<br>    char time[9]=”00:00:00”;<br>    for(i=0;;i++)<br>    {<br>        gets(c[i]);<br>        if(c[i][0]==’E’&amp;&amp;c[i][1]==’N’&amp;&amp;c[i][2]==’D’&amp;&amp;c[i][3]==’\0’)<br>        {<br><br>            num=i;break;<br>           }<br><br>    }<br><br>    for(i=0;i&lt;num;i++)<br><br>    {<br>        if(c[i][0]==’$’&amp;&amp;c[i][1]==’G’&amp;&amp;c[i][2]==’P’&amp;&amp;c[i][3]==’R’&amp;&amp;c[i][4]==’M’&amp;&amp;c[i][5]==’C’&amp;&amp;c[i][6]!=’\0’)<br>        {<br><br>          sum=0;<br>            for(j=1;c[i][j]!=’<em>‘;j++)<br>            {<br><br>                sum=sum^c[i][j];<br><br>            }<br>            if(c[i][j+1]&gt;=’0’&amp;&amp;c[i][j+1]&lt;=’9’)<br><br>                r=16</em>(c[i][j+1]-‘0’);<br><br>            else r=16<em>(c[i][j+1]-‘A’+10);<br><br>            if(c[i][j+2]&gt;=’0’&amp;&amp;c[i][j+2]&lt;=’9’)<br><br>                r=r+c[i][j+2]-‘0’;<br><br>            else r=r+c[i][j+2]-‘A’+10;<br><br>            for(k=0;!(c[i][k]==’A’||k==’V’);k++)<br><br>            {<br><br>                ;<br><br>            }<br><br>            if(sum==r&amp;&amp;c[i][k]==’A’)<br>            {<br>            time[3]=c[i][9],time[4]=c[i][10],time[6]=c[i][11],time[7]=c[i][12];<br><br>            t=10</em>(c[i][7]-‘0’)+c[i][8]-‘0’;<br><br>            t=(t+8)%24;<br><br>            if(t&lt;10)<br><br>            {<br><br>                time[0]=’0’,time[1]=’0’+t;<br><br>            }<br><br>            else<br><br>            {<br><br>                time[1]=(t%10)+’0’,time[0]=(t-t%10)/10 + ‘0’;<br><br>            }<br><br>            }<br><br>        }<br><br>    }<br><br>    for(i=0;i&lt;8;i++)<br><br>    {<br><br>        printf(“%c”,time[i]);<br><br>    }<br>    return 0;<br><br>}</pre><span style="font-size:18px; color:#ff0000">此题有参考讨论区的朋友做出的解答，在此给予十分的感谢，同时讨论区的同学做出的解答更好些，附上链接</span><br><br>讨论区地址：<br><a href="http://mooc.study.163.com/learn/ZJU-1000002011?tid=1000003007#/learn/forumdetail?pid=1000078086[点击打开链接](http://mooc.study.163.com/learn/ZJU-1000002011?tid=1000003007#/learn/forumdetail?pid=1000078086)" target="_blank" rel="noopener">http://mooc.study.163.com/learn/ZJU-1000002011?tid=1000003007#/learn/forumdetail?pid=1000078086[点击打开链接](http://mooc.study.163.com/learn/ZJU-1000002011?tid=1000003007#/learn/forumdetail?pid=1000078086)</a><br><br></div><br><div class="j-limit f-fc6 limit f-fs0"></div><br></div><br><div class="j-limit f-fc6 limit f-fs0"><span><br><br></span></div><br></div><br></div><br></div><br></div><br><div class="j-previewStatus"></div><br></div><br></div><br></div><br></div><br></div><br></div><br></div><br><br>

<iframe width="0" height="0" id="auto-id-XNBHaEb5tWraXdcz" src="http://www.icourse163.org/h/commonutil.html?63afae78b190afba5dd0fba568ba960b" frameborder="0" style="display: none;"></iframe>

<iframe width="0" height="0" id="auto-id-u4lCRoP23PZTJu33" src="http://www.icourse163.org/h/course/learn.html?2e7cec8fa0c9e63fc0be1bbe31861f10" frameborder="0" style="display: none;"></iframe>

<div><br><div class="loading-mask" id="loadingMask" style="z-index:10051"></div><br><div class="u-loading f-cb" id="loadingPb" style="z-index:10052"></div><br></div>

<iframe width="0" height="0" id="auto-id-tQOEvgl43ho5ypME" src="http://www.icourse163.org/h/course/learn/task.html?fe5e2e9d68e468a45073ff862f8aeeb7" frameborder="0" style="display: none;"></iframe>

<div style="top:807px">﻿﻿</div>
]]></content>
      <categories>
        <category>MOOC</category>
        <category>PAT</category>
        <category>基础</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>pat</tag>
        <tag>c语言</tag>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title>中国大学MOOC-翁恺-C语言程序设计习题集-解答汇总</title>
    <url>/2015/07/12/e4-b8-ad-e5-9b-bd-e5-a4-a7-e5-ad-a6mooc-e7-bf-81-e6-81-ba-c-e8-af-ad-e8-a8-80-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e4-b9-a0-e9-a2-98-e9-9b-86-e8-a7-a3-e7-ad-94-e6-b1-87-e6-80-bb/</url>
    <content><![CDATA[<h1 id="中国大学MOOC-翁恺-C语言程序设计习题集"><a href="#中国大学MOOC-翁恺-C语言程序设计习题集" class="headerlink" title="中国大学MOOC-翁恺-C语言程序设计习题集"></a>中国大学MOOC-翁恺-C语言程序设计习题集</h1><p>PAT 习题集</p>
<h1 id="02-0-整数四则运算-10"><a href="#02-0-整数四则运算-10" class="headerlink" title="02-0. 整数四则运算(10)"></a>02-0. 整数四则运算(10)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">乔林（清华大学）<br><br></div><br></div>

<div id="problemContent"><br>本题要求编写程序，计算2个正整数的和、差、积、商并输出。题目保证输入和输出全部在整型范围内。<br><a id="more"></a><br><strong>输入格式：</strong><br><br>输入在一行中给出2个正整数A和B。<br><br><strong>输出格式：</strong><br><br>在4行中按照格式“A 运算符 B = 结果”顺序输出和、差、积、商。<br><strong>输入样例：</strong><br><pre>3 2<br></pre><br><strong>输出样例：</strong><br><pre>3 + 2 = 5<br>3 - 2 = 1<br>3 <em> 2 = 6<br>3 / 2 = 1<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int A;<br>    int B;<br>    int X, Y, Z, W;<br>    scanf(“%d %d”, &amp;A, &amp;B);<br>    X = A + B;<br>    Y = A - B;<br>    Z = A </pre></em> B;<br>    W = A / B;<br>    printf(“%d + %d = %d\n” ,A, B, X);<br>    printf(“%d - %d = %d\n”, A, B, Y);<br>    printf(“%d * %d = %d\n”, A, B, Z);<br>    printf(“%d / %d = %d\n”, A, B, W);<br><br>    return 0;<br>}</pre><br>&nbsp;<br></div>

<h1 id="02-1-厘米换算英尺英寸-15"><a href="#02-1-厘米换算英尺英寸-15" class="headerlink" title="02-1. 厘米换算英尺英寸(15)"></a>02-1. 厘米换算英尺英寸(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">翁恺（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>如果已知英制长度的英尺foot和英寸inch的值，那么对应的米是(foot+inch/12)<em>0.3048。现在，如果用户输入的是厘米数，那么对应英制长度的英尺和英寸是多少呢？别忘了1英尺等于12英寸。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出1个正整数，单位是厘米。<br><br><strong>输出格式：</strong><br><br>在一行中输出这个厘米数对应英制长度的英尺和英寸的整数值，中间用空格分开。<br><strong>输入样例：</strong><br><pre>170<br></pre><br><strong>输出样例：</strong><br><pre>5 6<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int cm;<br>    scanf(“%d”, &amp;cm);<br>    int foot = cm / 30.48;<br>    int inch = (cm/30.48 - foot) </pre></pre></em> 12;<br>    printf(“%d %d”, foot, inch);<br>    return 0;<br> }<br>&nbsp;<br></div>

<h1 id="02-2-然后是几点-15"><a href="#02-2-然后是几点-15" class="headerlink" title="02-2. 然后是几点(15)"></a>02-2. 然后是几点(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">翁恺（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>有时候人们用四位数字表示一个时间，比如1106表示11点零6分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，即5点30分表示为530。注意，第二个数字表示的分钟数可能超过60，也可能是负数。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出2个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即5点30分表示为530；流逝的分钟数可能超过60，也可能是负数。<br><br><strong>输出格式：</strong><br><br>输出四位数字表示的终止时间。题目保证起始时间和终止时间在同一天内。<br><strong>输入样例：</strong><br><pre>1120 110<br></pre><br><strong>输出样例：</strong><br><pre>1310<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>int main()<br>{<br>    int i, j, x = 0, y, z;<br>    scanf(“%d%d”, &amp;i, &amp;j);<br>    if(i &gt;= 1000)<br>    {<br>           x = i / 1000;<br>           y = (i % 1000) / 100;<br>           z = (i %1000) %100;<br>    }<br>    else<br>    {<br>           y = i / 100;<br>           z = i % 100;<br>    }<br>    int s = (10<em>x + y) </em> 60 + z;<br>    int n = s + j;<br>    i = n / 60 <em>100 + (n - ((n / 60 )</em> 60));<br>    printf(“%d”, i);<br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="02-3-逆序的三位数-10"><a href="#02-3-逆序的三位数-10" class="headerlink" title="02-3. 逆序的三位数(10)"></a>02-3. 逆序的三位数(10)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">翁恺（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>程序每次读入一个正3位数，然后输出按位逆序的数字。注意：当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。<br><br><strong>输入格式：</strong><br><br>每个测试是一个3位的正整数。<br><br><strong>输出格式：</strong><br><br>输出按位逆序的数。<br><strong>输入样例：</strong><br><pre>123<br></pre><br><strong>输出样例：</strong><br><pre>321<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br> {<br>    int i;<br>    scanf(“%d”, &amp;i);<br>    int a = i % 100 %10;<br>    int b = i / 100;<br>    int c = i %100 / 10;<br>    i = a<em>100 + b + c</em>10;<br>    printf(“%d”, i);<br>    return  0;<br> }</pre><br>&nbsp;</pre><br></div>

<h1 id="02-4-BCD解密-10"><a href="#02-4-BCD解密-10" class="headerlink" title="02-4. BCD解密(10)"></a>02-4. BCD解密(10)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">翁恺（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>BCD数是用一个字节来表达两位十进制的数，每四个比特表示一位。所以如果一个BCD数的十六进制是0x12，它表达的就是十进制的12。但是小明没学过BCD，把所有的BCD数都当作二进制数转换成十进制输出了。于是BCD的0x12被输出成了十进制的18了！<br><br>现在，你的程序要读入这个错误的十进制数，然后输出正确的十进制数。提示：你可以把18转换回0x12，然后再转换回12。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出一个[0, 153]范围内的正整数，保证能转换回有效的BCD数，也就是说这个整数转换成十六进制时不会出现A-F的数字。<br><br><strong>输出格式：</strong><br><br>输出对应的十进制数。<br><strong>输入样例：</strong><br><pre>18<br></pre><br><strong>输出样例：</strong><br><pre>12<br><pre name="code" class="cpp"> #include &lt;stdio.h&gt;<br><br>int main()<br> {<br>    int i;<br>    scanf(“%d”, &amp;i);<br>    int t = i % 16 + i / 16 * 10;<br>    printf(“%d”, t);<br>    return 0;<br> }</pre><br>&nbsp;</pre><br></div>

<h1 id="03-0-超速判断-10"><a href="#03-0-超速判断-10" class="headerlink" title="03-0. 超速判断(10)"></a>03-0. 超速判断(10)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">杨起帆（浙江大学城市学院）<br><br></div><br></div>

<div id="problemContent"><br>模拟交通警察的雷达测速仪。输入汽车速度，如果速度超出60 mph，则显示“Speeding”，否则显示“OK”。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出1个不超过500的非负整数，即雷达测到的车速。<br><br><strong>输出格式：</strong><br><br>在一行中输出测速仪显示结果，格式为：“Speed: V - S”，其中V是车速，S或者是Speeding、或者是OK。<br><strong>输入样例1：</strong><br><pre>40<br></pre><br><strong>输出样例1：</strong><br><pre>Speed: 40 - OK<br></pre><br><strong>输入样例2：</strong><br><pre>75<br></pre><br><strong>输出样例2：</strong><br><pre>Speed: 75 - Speeding<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>  int i;<br>  scanf(“%d”, &amp;i);<br>  if(i &lt;= 60)<br>    printf(“Speed: %d - OK”, i);<br>  else<br>    printf(“Speed: %d - Speeding”, i);<br>  return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="03-1-三天打鱼两天晒网-15"><a href="#03-1-三天打鱼两天晒网-15" class="headerlink" title="03-1. 三天打鱼两天晒网(15)"></a>03-1. 三天打鱼两天晒网(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br></div>

<div id="problemContent"><br>中国有句俗语叫“三天打鱼两天晒网”。假设某人从某天起，开始“三天打鱼两天晒网”，问这个人在以后的第N天中是“打鱼”还是“晒网”？<br><br><strong>输入格式：</strong><br><br>输入在一行中给出1个不超过1000的正整数N。<br><br><strong>输出格式：</strong><br><br>在一行中输出此人在第N天中是“Fishing”（即“打鱼”）还是“Drying”（即“晒网”），并且输出“in day N”。<br><strong>输入样例1：</strong><br><pre>103<br></pre><br><strong>输出样例1：</strong><br><pre>Fishing in day 103<br></pre><br><strong>输入样例2：</strong><br><pre>34<br></pre><br><strong>输出样例2：</strong><br><pre>Drying in day 34<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int i;<br>    scanf(“%d”, &amp;i);<br>    if(i%5 &lt;= 3 &amp;&amp; i%5 != 0)<br>         printf(“Fishing in day %d”, i);<br>    else<br>         printf(“Drying in day %d”, i);<br>    return 0;<br>} </pre><br>&nbsp;</pre><br></div>

<h1 id="03-2-用天平找小球-10"><a href="#03-2-用天平找小球-10" class="headerlink" title="03-2. 用天平找小球(10)"></a>03-2. 用天平找小球(10)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br></div>

<div id="problemContent"><br>三个球A、B、C，大小形状相同且其中有一个球与其他球重量不同。要求找出这个不一样的球。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出3个正整数，顺序对应球A、B、C的重量。<br><br><strong>输出格式：</strong><br><br>在一行中输出唯一的那个不一样的球。<br><strong>输入样例：</strong><br><pre>1 1 2<br></pre><br><strong>输出样例：</strong><br><pre>C<br><br><pre name="code" class="cpp"># include &lt;stdio.h&gt;<br><br>int main()<br>{<br>     int A, B, C;<br>     scanf(“%d%d%d”,&amp;A, &amp;B, &amp;C);<br>     if(A != B &amp;&amp; B ==C)<br>           printf(“A”);<br>     else if(B != A &amp;&amp; A == C)<br>           printf(“B”);<br>     else if(C != A &amp;&amp; A == B)<br>           printf(“C”);<br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="03-3-12-24小时制-15"><a href="#03-3-12-24小时制-15" class="headerlink" title="03-3. 12-24小时制(15)"></a>03-3. 12-24小时制(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">翁恺（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>编写一个程序，要求用户输入24小时制的时间，然后显示12小时制的时间。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出带有中间的“:”符号（半角的冒号）的24小时制的时间，如<code>12:34</code>表示12点34分。当小时或分钟数小于10时，均没有前导的零，如<code>5:6</code>表示5点零6分。<br><br><em>提示：在scanf的格式字符串中加入“:”，让scanf来处理这个冒号。</em><br><br><strong>输出格式：</strong><br><br>在一行中输出这个时间对应的12小时制的时间，数字部分格式与输入的相同，然后跟上空格，再跟上表示上午的字符串“AM”或表示下午的字符串“PM”。如“<code>5:6 PM</code>”表示下午5点零6分。注意，在英文的习惯中，中午12点被认为是下午，所以24小时制的<code>12:00</code>就是12小时制的<code>12:0 PM</code>；而0点被认为是第二天的时间，所以是<code>0:0 AM</code>。<br><strong>输入样例：</strong><br><pre>21:11<br></pre><br><strong>输出样例：</strong><br><pre>9:11 PM<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int i, j;<br>    scanf(“%d:%d”, &amp;i, &amp;j);<br>    if(i &gt;= 0 &amp;&amp; i &lt; 12)<br>        printf(“%d:%d AM”, i, j);<br>    else if(i == 12)<br>        printf(“%d:%d PM”, i, j);<br>    else if(i == 24)<br>        printf(“%d:%d AM”, i-24, j);<br>    else<br>        printf(“%d:%d PM”, i-12, j);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="03-4-成绩转换-15"><a href="#03-4-成绩转换-15" class="headerlink" title="03-4. 成绩转换(15)"></a>03-4. 成绩转换(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">沈睿（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>本题要求编写程序将一个百分制成绩转换为五分制成绩。转换规则：<br><br><li>大于等于90分为A；</li><li>小于90且大于等于80为B；</li><li>小于80且大于等于70为C；</li><li>小于70且大于等于60为D；</li><li>小于60为E。<br><strong>输入格式：</strong><br><br>输入在一行中给出1个整数的百分制成绩。<br><br><strong>输出格式：</strong><br><br>在一行中输出对应的五分制成绩。<br><strong>输入样例：</strong><br><pre>90<br></pre><br><strong>输出样例：</strong><br><pre>A</pre><br></li><li><br><pre><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>  int i;<br>  scanf(“%d”, &amp;i);<br>  if(i &gt;= 90)<br>    printf(“A”);<br>  else if(i &lt; 90 &amp;&amp; i &gt;= 80)<br>    printf(“B”);<br>  else if(i &lt; 80 &amp;&amp; i &gt;= 70)<br>    printf(“C”);<br>  else if(i &lt; 70 &amp;&amp; i &gt;= 60)<br>    printf(“D”);<br>  else if(i &lt; 60)<br>    printf(“E”);<br><br>  return 0;<br>}</pre><br>&nbsp;</pre><br></li></div>

<h1 id="04-0-求符合给定条件的整数集-15"><a href="#04-0-求符合给定条件的整数集-15" class="headerlink" title="04-0. 求符合给定条件的整数集(15)"></a>04-0. 求符合给定条件的整数集(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">徐镜春（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>给定不超过6的正整数A，考虑从A开始的连续4个数字。请输出所有由它们组成的无重复数字的3位数。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出A。<br><br><strong>输出格式：</strong><br><br>输出满足条件的的3位数，要求从小到大，每行6个整数。整数间以空格分隔，但行末不能有多余空格。<br><strong>输入样例：</strong><br><pre>2<br></pre><br><strong>输出样例：</strong><br><pre>234 235 243 245 253 254<br>324 325 342 345 352 354<br>423 425 432 435 452 453<br>523 524 532 534 542 543<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int A, i, j, k, p = 0;<br>    scanf(“%d”, &amp;A);<br>    for(i=A; i&lt;A+4; ++i)<br>        for(j=A; j&lt;A+4; ++j)<br>            for(k=A; k&lt;A+4; ++k)<br>            {<br>                if(i != j &amp;&amp; i != k &amp;&amp; j != k)<br>                {<br><br>                    printf(“%d”, i<em>100+10</em>j+k);<br>                    p++;<br>                    if(p%6 == 0)<br>                        printf(“\n”);<br>                    else<br>                        printf(“ “);<br>                }<br>            }<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="04-1-水仙花数-20"><a href="#04-1-水仙花数-20" class="headerlink" title="04-1. 水仙花数(20)"></a>04-1. 水仙花数(20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">2000 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">徐镜春（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>水仙花数是指一个N位正整数（N&gt;=3），它的每个位上的数字的N次幂之和等于它本身。例如：153 = 1<sup>3</sup> + 5<sup>3</sup>+ 3<sup>3</sup>。本题要求编写程序,计算所有N位水仙花数。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出一个正整数N（3&lt;=N&lt;=7）。<br><br><strong>输出格式：</strong><br><br>按递增顺序输出所有N位水仙花数，每个数字占一行。<br><strong>输入样例：</strong><br><pre>3<br></pre><br><strong>输出样例：</strong><br><pre>153<br>370<br>371<br>407<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int n = 0, m = 0, l = 0, k = 0, roll = 0;<br>    int min = 1, t = 0, sum = 0, sum1 = 0;<br>    scanf(“%d”, &amp;n);<br>    m=n;<br>    while(m &gt; 1)   //built the minimum for n digit<br>    {<br>        min<em>=10;<br>        m–;<br>    }<br>    t=min;<br>    while(t &lt; 10</em>min)  //all the number for n digit<br>    {<br>        roll = t;<br>        m = n;<br>        sum = 1;<br>        while(m &gt; 0)<br>        {<br>            sum = sum<em>(roll%10);<br>            m–;<br>        }<br>        l = n;<br>        while(l &gt; 0)<br>        {<br>            roll = roll / 10;<br>            k = roll % 10;<br>            m = n;<br>            sum1 = 1;<br>            while(m &gt; 0)<br>            {<br>                sum1 = sum1 </em> k;<br>                m–;<br>            }<br>            sum = sum + sum1;<br>            l–;<br>        }<br>        if(t == sum)<br>        {<br>            printf(“%d\n”, t);<br>        }<br>        t++;<br>    }<br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="04-2-打印九九口诀表-15"><a href="#04-2-打印九九口诀表-15" class="headerlink" title="04-2. 打印九九口诀表(15)"></a>04-2. 打印九九口诀表(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">徐镜春（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>下面是一个完整的下三角九九口诀表：<br><pre>1<em>1=1<br>1</em>2=2   2<em>2=4<br>1</em>3=3   2<em>3=6   3</em>3=9<br>1<em>4=4   2</em>4=8   3<em>4=12  4</em>4=16<br>1<em>5=5   2</em>5=10  3<em>5=15  4</em>5=20  5<em>5=25<br>1</em>6=6   2<em>6=12  3</em>6=18  4<em>6=24  5</em>6=30  6<em>6=36<br>1</em>7=7   2<em>7=14  3</em>7=21  4<em>7=28  5</em>7=35  6<em>7=42  7</em>7=49<br>1<em>8=8   2</em>8=16  3<em>8=24  4</em>8=32  5<em>8=40  6</em>8=48  7<em>8=56  8</em>8=64<br>1<em>9=9   2</em>9=18  3<em>9=27  4</em>9=36  5<em>9=45  6</em>9=54  7<em>9=63  8</em>9=72  9<em>9=81<br></em></pre><br>本题要求对任意给定的1位正整数N，输出从11到N<em>N的部分口诀表。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出一个正整数N（1&lt;=N&lt;=9）。<br><br><strong>输出格式：</strong><br><br>输出下三角N</em>N部分口诀表，其中等号右边数字占4位、左对齐。<br><strong>输入样例：</strong><br><pre>4<br></pre><br><strong>输出样例：</strong><br><pre>1<em>1=1<br>1</em>2=2   2<em>2=4<br>1</em>3=3   2<em>3=6   3</em>3=9<br>1<em>4=4   2</em>4=8   3<em>4=12  4</em>4=16<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main(void)<br>{<br>    int n;<br>    scanf(“%d”, &amp;n);<br>    int i, j;<br>    for (i=1; i&lt;=n; i++)<br>    {<br>        for (j=1; j&lt;=i; j++)<br>            printf(“%d<em>%d=%-4d”, j, i, i</em>j);<br>        puts(“”);<br>    }<br><br>    return 0;<br>}</pre><br> </pre><br></div>

<h1 id="04-3-统计素数并求和-20"><a href="#04-3-统计素数并求和-20" class="headerlink" title="04-3. 统计素数并求和(20)"></a>04-3. 统计素数并求和(20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">张彤彧（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>本题要求统计给定整数M和N区间内素数的个数并对它们求和。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出2个正整数M和N（1&lt;=M&lt;=N&lt;=500）。<br><br><strong>输出格式：</strong><br><br>在一行中顺序输出M和N区间内素数的个数以及它们的和，数字间以空格分隔。<br><strong>输入样例：</strong><br><pre>10 31<br></pre><br><strong>输出样例：</strong><br><pre>7 143<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;stdbool.h&gt;<br>int nums(int x)<br>{<br>    int i;<br>    if(x ==1 ){<br>        return 0;<br>    }<br>    for(i=2; i*i&lt;=x; i++){<br>        if(x%i == 0){<br>            return 0;<br>        }<br>    }<br>    return 1;<br>}<br>int main()<br>{<br>    int m,n;<br>    int j;<br>    scanf(“%d %d”, &amp;m, &amp;n);<br>    int count = 0;<br>    int sum = 0;<br>    for(j=m; j&lt;=n; j++)<br>    {<br>        if(nums(j) == 1)<br>        {<br>            count++;<br>            sum += j;<br>        }<br>    }<br>    printf(“%d %d”, count, sum);<br><br>    return 0;<br>}<br></pre><br>&nbsp;</pre><br></div>

<h1 id="04-4-猜数字游戏-15"><a href="#04-4-猜数字游戏-15" class="headerlink" title="04-4. 猜数字游戏(15)"></a>04-4. 猜数字游戏(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br></div>

<div id="problemContent"><br>猜数字游戏是令系统随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（&gt;3）次以内（包括第N次）猜到该数，则提示“Good Guess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“Game<br> Over”，并结束程序。<br><br><strong>输入格式：</strong><br><br>输入第一行中给出2个不超过100的正整数，分别是系统产生的随机数、以及猜测的最大次数N。随后每行给出一个用户的输入，直到出现负数为止。<br><br><strong>输出格式：</strong><br><br>在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。<br><strong>输入样例：</strong><br><pre>58 4<br>70<br>50<br>56<br>58<br>60<br>-2<br></pre><br><strong>输出样例：</strong><br><pre>Too big<br>Too small<br>Too small<br>Good Guess!<br><br><pre name="code" class="cpp"> #include &lt;stdio.h&gt;<br><br> int main()<br> {<br>    int n, times;<br>    int i, t = 0;<br>    scanf(“%d %d”, &amp;n, ×);<br>    while(1)<br>    {<br>        scanf(“%d”, &amp;i);<br>        ++t;<br>        if(i == n &amp;&amp; t == 1)<br>        {<br>            printf(“Bingo!\n”);<br>            break;<br>        }<br>        else if(i &lt; 0 || t &gt; times )<br>        {<br>            printf(“Game Over”);<br>            break;<br>        }<br>        else if(i == n &amp;&amp; t &gt; 1 &amp;&amp; t &lt;= 3 &amp;&amp; t &lt;= times)<br>        {<br>            printf(“Lucky You!\n”);<br>            break;<br>        }<br>        else if(i &gt; n)<br>        {<br>            printf(“Too big\n”);<br>        }<br>        else if(i &lt; n &amp;&amp; i &gt; 0)<br>        {<br>            printf(“Too small\n”);<br>        }<br>        else if(i == n &amp;&amp; t &gt; 3 &amp;&amp; t &lt;= times)<br>        {<br>            printf(“Good Guess!\n”);<br>            break;<br>        }<br>    }<br><br>    return 0;<br>}<br></pre><br>&nbsp;</pre><br></div>

<h1 id="05-0-求序列前N项和-15"><a href="#05-0-求序列前N项和-15" class="headerlink" title="05-0. 求序列前N项和(15)"></a>05-0. 求序列前N项和(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">张彤彧（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>本题要求编写程序,计算序列 2/1+3/2+5/3+8/5+… 的前N项之和。注意该序列从第2项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出一个正整数N。<br><br><strong>输出格式：</strong><br><br>在一行中输出部分和的值，精确到小数点后2位。题目保证计算结果不超过双精度范围。<br><strong>输入样例：</strong><br><pre>20<br></pre><br><strong>输出样例：</strong><br><pre>32.66<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int n = 1, i;<br>    double a = 2, b = 1, t, s = 0;<br>    scanf(“%d”, &amp;n);<br>    for(i=1; i&lt;=n; ++i)<br>    {<br>        t = a;<br>        s += a/b;<br>        a += b;<br>        b = t;<br>    }<br>    printf(“%.2lf”, s);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="05-1-约分最简分式-15"><a href="#05-1-约分最简分式-15" class="headerlink" title="05-1. 约分最简分式(15)"></a>05-1. 约分最简分式(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">翁恺（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>分数可以表示为“分子/分母”的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出一个分数，分子和分母中间以斜杠“/”分隔，如：<code>12/34</code>表示34分之12。分子和分母都是正整数（不包含0，如果不清楚正整数的定义的话）。<br><br><em>提示：在scanf的格式字符串中加入“/”，让scanf来处理这个斜杠。</em><br><br><strong>输出格式：</strong><br><br>在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用“分子/分母”的形式表示分数。如<code>5/6</code>表示6分之5。<br><strong>输入样例：</strong><br><pre>60/120<br></pre><br><strong>输出样例：</strong><br><pre>1/2<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int i, j, n, k;<br>    scanf(“%d/%d”, &amp;i, &amp;j);<br>    loop:<br>        if(i &gt;= j)<br>            n = j;<br>        else<br>            n = i;<br>        for(k=2; k&lt;=n; ++k)<br>        {<br>            if(j % k == 0 &amp;&amp; i % k == 0)<br>            {<br>                j /= k;<br>                i /= k;<br>                goto loop;<br>            }<br>        }<br>    printf(“%d/%d”, i, j);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="05-2-念数字-15"><a href="#05-2-念数字-15" class="headerlink" title="05-2. 念数字(15)"></a>05-2. 念数字(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">翁恺（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出“fu”字。十个数字对应的拼音如下：<br><pre>0: ling<br>1: yi<br>2: er<br>3: san<br>4: si<br>5: wu<br>6: liu<br>7: qi<br>8: ba<br>9: jiu<br></pre><br><strong>输入格式：</strong><br><br>输入在一行中给出一个整数，如：<code>1234</code>。<br><br><em>提示：整数包括负数、零和正数。</em><br><br><strong>输出格式：</strong><br><br>在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如<code>yi er san si</code>。<br><strong>输入样例：</strong><br><pre>-600<br></pre><br><strong>输出样例：</strong><br><pre>fu liu ling ling<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>char str[20];<br>const char *num[] = {“ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu”};<br><br>int main()<br>{<br>    int i, k;<br>    scanf(“%s”, str);<br>    k = strlen(str);<br>    if ( str[0] == ‘-‘) printf(“fu”);<br>    else<br>        printf(“%s”, num[str[0]-‘0’]);<br>    for ( i=1; i&lt;k; i++ )<br>    {<br>        printf(“ %s”, num[str[i]-‘0’]);<br>    }<br>    printf(“\n”);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="05-3-求a的连续和-15"><a href="#05-3-求a的连续和-15" class="headerlink" title="05-3. 求a的连续和(15)"></a>05-3. 求a的连续和(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">翁恺（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>输入两个整数a和n，a的范围是[0,9]，n的范围是[1,8]，求数列之和S = a+aa+aaa+…+aaa…a（n个a）。如a为2、n为8时输出的是2+22+222+…+22222222的和。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出两个整数，先后表示a和n。<br><br><strong>输出格式：</strong><br><br>在一行中输出要求的数列之和。<br><strong>输入样例：</strong><br><pre>2 4<br></pre><br><strong>输出样例：</strong><br><pre>2468<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;<br><br>int main()<br>{<br>    int a, n, i, s = 0;<br>    scanf(“%d%d”, &amp;a, &amp;n);<br>    for(i=1; i&lt;=n; ++i)<br>    {<br>        s += (pow(10.0,i)-1) * a / 9;<br>    }<br>    printf(“%d”, s);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="06-0-混合类型数据格式化输入-5"><a href="#06-0-混合类型数据格式化输入-5" class="headerlink" title="06-0. 混合类型数据格式化输入(5)"></a>06-0. 混合类型数据格式化输入(5)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">乔林（清华大学）<br><br></div><br></div>

<div id="problemContent"><br>本题要求编写程序，顺序读入浮点数1、整数、字符、浮点数2，再按照字符、整数、浮点数1、浮点数2的顺序输出。<br><br><strong>输入格式：</strong><br><br>输入在一行中顺序给出浮点数1、整数、字符、浮点数2，其间以1个空格分隔。<br><br><strong>输出格式：</strong><br><br>在一行中按照字符、整数、浮点数1、浮点数2的顺序输出，其中浮点数保留小数点后2位。<br><strong>输入样例：</strong><br><pre>2.12 88 c 4.7<br></pre><br><strong>输出样例：</strong><br><pre>c 88 2.12 4.70<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>  float f1, f2;<br>  char ch;<br>  int i;<br>  scanf(“%f %d %c %f”, &amp;f1, &amp;i, &amp;ch, &amp;f2);<br>  printf(“%c %d %.2f %.2f”, ch, i, f1, f2);<br><br>  return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="06-1-简单计算器-20"><a href="#06-1-简单计算器-20" class="headerlink" title="06-1. 简单计算器(20)"></a>06-1. 简单计算器(20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">张彤彧（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数，4种运算符的优先级相同，按从左到右的顺序计算。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出一个四则运算算式，没有空格，且至少有一个操作数。遇等号”=”说明输入结束。<br><br><strong>输出格式：</strong><br><br>在一行中输出算式的运算结果，或者如果除法分母为0或有非法运算符，则输出错误信息“ERROR”。<br><strong>输入样例：</strong><br><pre>1+2<em>10-10/2=<br></em></pre><br><strong>输出样例：</strong><br><pre>10<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    char ch = ‘0’;<br>    int result, i, flag = 0;<br>    scanf(“%d”, &amp;result);<br>    while( ch != ‘=’ )<br>    {<br>        scanf(“%c”, &amp;ch);<br>        if(ch == ‘=’)<br>            break;<br>        scanf(“%d”, &amp;i);<br>        if( ch == ‘+’ )<br>            result += i;<br>        else if( ch == ‘-‘ )<br>            result -= i;<br>        else if( ch == ‘‘ )<br>            result *= i;<br>        else if( ch == ‘/‘ )<br>        {<br>            if( i != 0 )<br>                result /= i;<br>            else<br>                flag = 1;<br>        }<br>        else<br>            flag = 1;<br>    }<br>    if(flag)<br>        printf(“ERROR\n”);<br>    else<br>        printf(“%d”, result);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="06-2-字符串字母大小写转换-10"><a href="#06-2-字符串字母大小写转换-10" class="headerlink" title="06-2. 字符串字母大小写转换(10)"></a>06-2. 字符串字母大小写转换(10)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">张彤彧（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>输入一个以#结束的字符串，本题要求将小写字母全部转换成大写字母，把大写字母全部转换成小写字母，其它字符不变。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出一个长度不超过40的、以#结束的非空字符串。<br><br><strong>输出格式：</strong><br><br>在一行中按照要求输出转换后的字符串。<br><strong>输入样例：</strong><br><pre>Hello World! 123#<br></pre><br><strong>输出样例：</strong><br><pre>hELLO wORLD! 123<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    char c;<br>    c = getchar();<br>    while(c != ‘#’)<br>    {<br>        if(c &gt;= ‘a’ &amp;&amp; c &lt;= ‘z’)<br>        {<br>            c -= 32;<br>        }<br>        else if(c &gt;= ‘A’ &amp;&amp; c &lt;= ‘Z’)<br>        {<br>            c += 32;<br>        }<br>        printf(“%c”, c);<br>        c = getchar();<br>    }<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="06-3-单词长度-15"><a href="#06-3-单词长度-15" class="headerlink" title="06-3. 单词长度(15)"></a>06-3. 单词长度(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">翁恺（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>你的程序要读入一行文本，其中以空格分隔为若干个单词，以‘.’结束。你要输出每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如“it’s”算一个单词，长度为4。注意，行中可能出现连续的空格；最后的‘.’不计算在内。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出一行文本，以‘.’结束。<br><br><em>提示：用<code>scanf(&quot;%c&quot;,...);</code>来读入一个字符，直到读到‘.’为止。</em><br><br><strong>输出格式：</strong><br><br>在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。<br><br><strong>输入样例：</strong><br><pre>It’s great to see you here.<br></pre><br><strong>输出样例：</strong><br><pre>4 5 2 3 3 4<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    char s[100];<br>    int i = 0;<br>    do<br>    {<br>        scanf(“%c”, &amp;s[i]);<br>        i++;<br>    } while(s[i-1] != ‘.’);<br>    int j;<br>    int cnt = 0;<br>    int k = 0;<br>    for(j=0; j&lt;i; j++)<br>    {<br>        if(s[j] != ‘ ‘)<br>        {<br>            cnt++;<br>            if(k != 0 &amp;&amp; s[j] != ‘.’)<br>            {<br>                printf(“ “);<br>                k = 0;<br>            }<br>            if(s[j] == ‘.’ &amp;&amp; s[j - 1] != ‘ ‘ &amp;&amp; cnt != 1)<br>            {<br>                printf(“%d”, cnt-1);<br>            }<br>        }<br>        else if(cnt != 0)<br>        {<br>            printf(“%d”, cnt);<br>            cnt = 0;<br>            k = 1;<br>        }<br>    }<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="07-0-写出这个数-20"><a href="#07-0-写出这个数-20" class="headerlink" title="07-0. 写出这个数 (20)"></a>07-0. 写出这个数 (20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">CHEN, Yue<br><br></div><br></div>

<div id="problemContent"><br>读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。<br><br><strong>输入格式：</strong>每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10<sup>100</sup>。<br><br><strong>输出格式：</strong>在一行内输出n的各位数字之和的每一位，拼音数字间有1空格，但一行中最后一个拼音数字后没有空格。<br><strong>输入样例：</strong><br><pre>1234567890987654321123456789<br></pre><br><strong>输出样例：</strong><br><pre>yi san wu<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>const char *num[] = {“ling”, “yi”, “er”, “san”, “si”, “wu”, “liu”, “qi”, “ba”, “jiu”};<br><br>int main()<br>{<br>    char ch, number[10];<br>    int s = 0, i;<br>    while( (ch = getchar()) != ‘\n’ )<br>    {<br>        s += ch-‘0’;<br>    }<br>    sprintf(number, “%d”, s);<br>    printf(“%s”, num[number[0]-‘0’]);<br>    for ( i=1; i&lt;strlen(number); i++ )<br>    {<br>        printf(“ %s”, num[number[i]-‘0’]);<br>    }<br>    printf(“\n”);<br><br>    return 0;<br>}</pre><br><br>&nbsp;</pre><br></div>

<h1 id="07-1-换个格式输出整数-15"><a href="#07-1-换个格式输出整数-15" class="headerlink" title="07-1. 换个格式输出整数 (15)"></a>07-1. 换个格式输出整数 (15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">CHEN, Yue<br><br></div><br></div>

<div id="problemContent"><br>让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。<br><br><strong>输入格式：</strong>每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。<br><br><strong>输出格式：</strong>每个测试用例的输出占一行，用规定的格式输出n。<br><strong>输入样例1：</strong><br><pre>234<br></pre><br><strong>输出样例1：</strong><br><pre>BBSSS1234<br></pre><br><strong>输入样例2：</strong><br><pre>23<br></pre><br><strong>输出样例2：</strong><br><pre>SS123<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int i, j, B, S;<br>    scanf(“%d”, &amp;i);<br>    if(i &gt;= 1 &amp;&amp; i &lt; 1000)<br>    {<br>        if(i &gt;= 1 &amp;&amp; i &lt; 10)<br>        {<br>            for(j=1; j&lt;=i; ++j)<br>            {<br>                printf(“%d”, j);<br>            }<br>        }<br>        if(i &gt;= 10 &amp;&amp; i &lt; 100)<br>        {<br>            S = i / 10;<br>            for(j=1; j&lt;=S; ++j)<br>            {<br>                printf(“S”);<br>            }<br>            i = i % 10;<br>            for(j=1; j&lt;=i; ++j)<br>            {<br>                printf(“%d”, j);<br>            }<br>        }<br>        if(i &gt;= 100 &amp;&amp; i &lt; 1000)<br>        {<br>            B = i / 100;<br>            for(j=1; j&lt;=B; ++j)<br>            {<br>                printf(“B”);<br>            }<br>            S = i /10 % 10;<br>            for(j=1; j&lt;=S; ++j)<br>            {<br>                printf(“S”);<br>            }<br>            i = i % 10;<br>            for(j=1; j&lt;=i; ++j)<br>            {<br>                printf(“%d”, j);<br>            }<br>        }<br>    }<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="07-2-A-B和C-15"><a href="#07-2-A-B和C-15" class="headerlink" title="07-2. A+B和C (15)"></a>07-2. A+B和C (15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">50 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">HOU, Qiming<br><br></div><br></div>

<div id="problemContent"><br>给定区间[-2<sup>31</sup>, 2<sup>31</sup>]内的3个整数A、B和C，请判断A+B是否大于C。<br><br><strong>输入格式：</strong><br><br>输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。<br><br><strong>输出格式：</strong><br><br>对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。<br><strong>输入样例：</strong><br><pre>4<br>1 2 3<br>2 3 4<br>2147483647 0 2147483646<br>0 -2147483648 -2147483647<br></pre><br><strong>输出样例：</strong><br><pre>Case #1: false<br>Case #2: true<br>Case #3: true<br>Case #4: false<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>    int t, i;<br>    long a, j, k;<br>    scanf(“%d”, &amp;t);<br>    if(t &gt;= 1 &amp;&amp; t &lt;= 10)<br>    {<br>        for(i=1; i&lt;=t; ++i)<br>        {<br>            scanf(“%ld%ld%ld”, &amp;a, &amp;j, &amp;k);<br>            if(a + j &gt; k)<br>            {<br>                printf(“Case #%d: true\n”, i);<br>            }<br>            else<br>            {<br>                printf(“Case #%d: false\n”, i);<br>            }<br>        }<br>    }<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="07-3-数素数-20"><a href="#07-3-数素数-20" class="headerlink" title="07-3. 数素数 (20)"></a>07-3. 数素数 (20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">100 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">CHEN, Yue<br><br></div><br></div>

<div id="problemContent"><br>令P<sub>i</sub>表示第i个素数。现任给两个正整数M &lt;= N &lt;= 10<sup>4</sup>，请输出P<sub>M</sub>到P<sub>N</sub>的所有素数。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出M和N，其间以空格分隔。<br><br><strong>输出格式：</strong><br><br>输出从P<sub>M</sub>到P<sub>N</sub>的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。<br><strong>输入样例：</strong><br><pre>5 27<br></pre><br><strong>输出样例：</strong><br><pre>11 13 17 19 23 29 31 37 41 43<br>47 53 59 61 67 71 73 79 83 89<br>97 101 103<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int a[10001];<br><br>int main()<br>{<br>    int i, c = 0, j, p, m, n;<br>    a[0] = 2;<br>    for ( i=3; ;i+=2 )<br>    {<br>        p = 1;<br>        for ( j=2; j*j&lt;=i; j++ )<br>        {<br>            if ( i % j == 0 )<br>            {<br>                p = 0;<br>                break;<br>            }<br>        }<br>        if ( p )<br>        {<br>            a[++c] = i;<br>        }<br>        if ( c == 10000 ) break;<br>    }<br>    c = 0;<br>    scanf(“%d %d”, &amp;m, &amp;n);<br>    for ( i=m; i&lt;=n; i++ )<br>    {<br>        c++;<br>        printf(“%d”, a[i-1]);<br>        if ( c % 10 == 0 )<br>            printf(“\n”);<br>        else if ( i &lt; n )<br>            printf(“ “);<br>    }<br>    if ( c % 5 != 0 )<br>        printf(“\n”);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="08-0-查找整数-10"><a href="#08-0-查找整数-10" class="headerlink" title="08-0. 查找整数(10)"></a>08-0. 查找整数(10)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">杨起帆（浙江大学城市学院）<br><br></div><br></div>

<div id="problemContent"><br>本题要求从输入的N个整数中查找给定的X。如果找到，输出X的位置（从0开始数）；如果没有找到，输出“Not Found”。<br><br><strong>输入格式：</strong><br><br>输入在第1行中给出2个正整数N（&lt;=20）和X，第2行给出N个整数。数字均不超过长整型，其间以空格分隔。<br><br><strong>输出格式：</strong><br><br>在一行中输出X的位置，或者“Not Found”。<br><strong>输入样例1：</strong><br><pre>5 7<br>3 5 7 1 9<br></pre><br><strong>输出样例1：</strong><br><pre>2<br></pre><br><strong>输入样例2：</strong><br><pre>5 7<br>3 5 8 1 9<br></pre><br><strong>输出样例2：</strong><br><pre>Not Found<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#define N 1000<br><br>int a[N];<br><br>int main()<br>{<br>    int n, key, i;<br>    scanf(“%d%d”, &amp;n, &amp;key);<br>    for ( i=0; i&lt;n; i++ )<br>    {<br>        scanf(“%d”, &amp;a[i]);<br>    }<br>    for ( i=0; i&lt;n; i++ )<br>    {<br>        if ( a[i] == key )<br>        {<br>            printf(“%d\n”, i);<br>            break;<br>        }<br>    }<br>    if ( i == n )<br>    {<br>        printf(“Not Found\n”);<br>    }<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="08-1-求一批整数中出现最多的个位数字-20"><a href="#08-1-求一批整数中出现最多的个位数字-20" class="headerlink" title="08-1. 求一批整数中出现最多的个位数字(20)"></a>08-1. 求一批整数中出现最多的个位数字(20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">徐镜春（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>给定一批整数，分析每个整数的每一位数字，求出现次数最多的个位数字。例如给定3个整数1234、2345、3456，其中出现最多次数的数字是3和4，均出现了3次。<br><br><strong>输入格式：</strong><br><br>输入在第1行中给出正整数N（&lt;=1000），在第2行中给出N个不超过整型范围的正整数，数字间以空格分隔。<br><br><strong>输出格式：</strong><br><br>在一行中按格式“M: n1 n2 …”输出，其中M是最大次数，n1、n2、……为出现次数最多的个位数字，按从小到大的顺序排列。数字间以空格分隔，但末尾不得有多余空格。<br><strong>输入样例：</strong><br><pre>3<br>1234 2345 3456<br></pre><br><strong>输出样例：</strong><br><pre>3: 3 4<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>int a[1002];<br><br>int main()<br>{<br>    int t, i, max = 0;<br>    int count[10];<br>    scanf(“%d”, &amp;t);<br>    for ( i=0; i&lt;10; i++ )<br>    {<br>        count[i] = 0;<br>    }<br>    for ( i=0; i&lt;t; i++ )<br>    {<br>        scanf(“%d”, &amp;a[i]);<br>    }<br>    for ( i=0; i&lt;t; i++ )<br>    {<br>        while (a[i])<br>        {<br>            count[a[i]%10]++;<br>            a[i] /= 10;<br>        }<br>    }<br>    for ( i=0; i&lt;10; i++ )<br>    {<br>        if ( max &lt; count[i] )<br>        {<br>            max = count[i];<br>        }<br>    }<br>    printf(“%d:”, max);<br>    for ( i=0; i&lt;10; i++ )<br>    {<br>        if ( count[i] == max )<br>        {<br>            printf(“ %d”, i);<br>        }<br>    }<br>    printf(“\n”);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="08-2-求矩阵的局部极大值-15"><a href="#08-2-求矩阵的局部极大值-15" class="headerlink" title="08-2. 求矩阵的局部极大值(15)"></a>08-2. 求矩阵的局部极大值(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">徐镜春（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>给定M行N列的整数矩阵A，如果A的非边界元素A[i][j]大于相邻的上下左右4个元素，那么就称元素A[i][j]是矩阵的局部极大值。本题要求给定矩阵的全部局部极大值及其所在的位置。<br><br><strong>输入格式：</strong><br><br>输入在第1行中给出矩阵A的行数M和列数N（3&lt;=M,N&lt;=20）；最后M行，每行给出A在该行的N个元素的值。数字间以空格分隔。<br><br><strong>输出格式：</strong><br><br>每行按照“元素值 行号 列号”的格式输出一个局部极大值，其中行、列编号从1开始。要求按照行号递增输出；若同行有超过1个局部极大值，则该行按列号递增输出。若没有局部极大值，则输出“None 总行数 总列数”。<br><strong>输入样例1：</strong><br><pre>4 5<br>1 1 1 1 1<br>1 3 9 3 1<br>1 5 3 5 1<br>1 1 1 1 1<br></pre><br><strong>输出样例1：</strong><br><pre>9 2 3<br>5 3 2<br>5 3 4<br></pre><br><strong>输入样例2：</strong><br><pre>3 5<br>1 1 1 1 1<br>9 3 9 9 1<br>1 5 3 5 1<br></pre><br><strong>输出样例2：</strong><br><pre>None 3 5<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int a[21][21];<br><br>int main()<br>{<br>    int m, n, i, j, p = 0;<br>    scanf(“%d %d”, &amp;m, &amp;n);<br>    for ( i=0; i&lt;m; i++ )<br>    {<br>        for ( j=0; j&lt;n; j++ )<br>        {<br>            scanf(“%d”, &amp;a[i][j]);<br>        }<br>    }<br>    for ( i=1; i&lt;m-1; i++ )<br>    {<br>        for ( j=1; j&lt;n-1; j++ )<br>        {<br>            if ( a[i][j] &gt; a[i][j+1] &amp;&amp; a[i][j] &gt; a[i][j-1] &amp;&amp;<br>                a[i][j] &gt; a[i+1][j] &amp;&amp; a[i][j] &gt; a[i-1][j] )<br>            {<br>                printf(“%d %d %d\n”, a[i][j], i+1, j+1);<br>                p = 1;<br>            }<br>        }<br>    }<br>    if ( !p )<br>    {<br>        printf(“None %d %d\n”, m, n);<br>    }<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="08-3-组个最小数-20"><a href="#08-3-组个最小数-20" class="headerlink" title="08-3. 组个最小数 (20)"></a>08-3. 组个最小数 (20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">100 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">CAO, Peng<br><br></div><br></div>

<div id="problemContent"><br>给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。<br><br>现给定数字，请编写程序输出能够组成的最小的数。<br><br><strong>输入格式：</strong><br><br>每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。<br><br><strong>输出格式：</strong><br><br>在一行中输出能够组成的最小的数。<br><strong>输入样例：</strong><br><pre>2 2 0 0 0 3 0 0 1 0<br></pre><br><strong>输出样例：</strong><br><pre>10015558<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br><br>int b[10];<br><br>int main()<br>{<br>    int i, j;<br>    for ( i=0; i&lt;10; i++ )<br>    {<br>        b[i] = 0;<br>    }<br>    for ( i=0; i&lt;10; i++ )<br>    {<br>        scanf(“%d”, &amp;b[i]);<br>    }<br>    for ( i=1; i&lt;10; i++ )<br>    {<br>        if (b[i])<br>        {<br>            printf(“%d”, i);<br>            b[i]–;<br>            break;<br>        }<br>    }<br>    for ( i=0; i&lt;10; i++ )<br>    {<br>        for ( j=0; j&lt;b[i]; j++ )<br>        {<br>            printf(“%d”, i);<br>        }<br>    }<br>    printf(“\n”);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="10-0-说反话-20"><a href="#10-0-说反话-20" class="headerlink" title="10-0. 说反话 (20)"></a>10-0. 说反话 (20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">CHEN, Yue<br><br></div><br></div>

<div id="problemContent"><br>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。<br><br><strong>输入格式：</strong>测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。<br><br><strong>输出格式：</strong>每个测试用例的输出占一行，输出倒序后的句子。<br><strong>输入样例：</strong><br><pre>Hello World Here I Come<br></pre><br><strong>输出样例：</strong><br><pre>Come I Here World Hello<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>char str[81];<br><br>int main()<br>{<br>    int i, k;<br>    char <em>p;<br>    gets(str);<br>    k = strlen(str);<br>    p = str + k;<br>    while (1)<br>    {<br>        if ( p == str )<br>        {<br>            printf(“%s\n”, p);<br>            break;<br>        }<br>        if (</em>p == ‘ ‘ &amp;&amp; <em>(p+1) != ‘ ‘)<br>        {
            </em>p = ‘\0’;<br>            printf(“%s “, p+1);<br>        }<br>        p–;<br>    }<br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="10-1-在字符串中查找指定字符-15"><a href="#10-1-在字符串中查找指定字符-15" class="headerlink" title="10-1. 在字符串中查找指定字符(15)"></a>10-1. 在字符串中查找指定字符(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">白洪欢（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>输入一个字符串S，再输入一个字符c，要求在字符串S中查找字符c。如果找不到则输出“Not found”；若找到则输出字符串S中从c开始的所有字符。<br><br><strong>输入格式：</strong><br><br>输入在第1行中给出一个不超过80个字符长度的、以回车结束的非空字符串；在第2行中给出一个字符。<br><br><strong>输出格式：</strong><br><br>在一行中按照题目要求输出结果。<br><strong>输入样例1：</strong><br><pre>It is a black box<br>b<br></pre><br><strong>输出样例1：</strong><br><pre>black box<br></pre><br><strong>输入样例2：</strong><br><pre>It is a black box<br>B<br></pre><br><strong>输出样例2：</strong><br><pre>Not found<br><br><pre name="code" class="cpp">#include &lt;string.h&gt;<br>#include &lt;stdio.h&gt;<br><br>char str[180];<br><br>int main()<br>{<br>    char ch;<br>    int i, k, p = 0;<br>    gets(str);<br>    k = strlen(str);<br>    scanf(“%c”, &amp;ch);<br>    for ( i=0; i&lt;k; i++ )<br>    {<br>        if ( str[i] == ch )<br>        {<br>            p = 1;<br>        }<br>        if ( p )<br>        {<br>            printf(“%c”, str[i]);<br>        }<br>    }<br>    if ( !p )<br>    {<br>        printf(“Not found\n”);<br>    }<br>    else<br>    {<br>        printf(“\n”);<br>    }<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="10-2-删除字符串中的子串-20"><a href="#10-2-删除字符串中的子串-20" class="headerlink" title="10-2. 删除字符串中的子串(20)"></a>10-2. 删除字符串中的子串(20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">白洪欢（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。<br><br><strong>输入格式：</strong><br><br>输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。<br><br><strong>输出格式：</strong><br><br>在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。<br><strong>输入样例：</strong><br><pre>Tomcat is a male ccatat<br>cat<br></pre><br><strong>输出样例：</strong><br><pre>Tom is a male<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>char s1[81], s2[81];<br><br>int main()<br>{<br>    int i, k;<br>    gets(s1);<br>    gets(s2);<br>    char <em>p = strstr(s1, s2);<br>    while(1)<br>    {<br>        char </em>p = strstr(s1, s2);<br>        if ( p )<br>        {<br>            for ( i=0; i&lt;strlen(p) - strlen(s2); i++ )<br>            {<br>                p[i] = p[strlen(s2) + i];<br>            }<br>            p[i] = ‘\0’;<br>        }<br>        else<br>        {<br>            puts(s1);<br>            break;<br>        }<br>    }<br><br>    return 0;<br>}</pre><br></pre><br></div>

<h1 id="10-3-字符串逆序-15"><a href="#10-3-字符串逆序-15" class="headerlink" title="10-3. 字符串逆序(15)"></a>10-3. 字符串逆序(15)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">白洪欢（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>输入一个字符串，对该字符串进行逆序，输出逆序后的字符串。<br><br><strong>输入格式：</strong><br><br>输入在一行中给出一个不超过80个字符长度的、以回车结束的非空字符串。<br><br><strong>输出格式：</strong><br><br>在一行中输出逆序后的字符串。<br><strong>输入样例：</strong><br><pre>Hello World!<br></pre><br><strong>输出样例：</strong><br><pre>!dlroW olleH<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>int main()<br>{<br>    char str[81];<br>    int k;<br>    gets(str);<br>    k = strlen(str);<br>    k -= 1;<br>    for ( k; k&gt;=0; k– )<br>    {<br>        printf(“%c”, str[k]);<br>    }<br>    printf(“\n”);<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="10-4-字符串循环左移-20"><a href="#10-4-字符串循环左移-20" class="headerlink" title="10-4. 字符串循环左移(20)"></a>10-4. 字符串循环左移(20)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">白洪欢（浙江大学）<br><br></div><br></div>

<div id="problemContent"><br>输入一个字符串和一个非负整数N，要求将字符串循环左移N次。<br><br><strong>输入格式：</strong><br><br>输入在第1行中给出一个不超过100个字符长度的、以回车结束的非空字符串；第2行给出非负整数N。<br><br><strong>输出格式：</strong><br><br>在一行中输出循环左移N次后的字符串。<br><strong>输入样例：</strong><br><pre>Hello World!<br>2<br></pre><br><strong>输出样例：</strong><br><pre>llo World!He<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>char str[103];<br><br>int main()<br>{<br>    int i, k, n;<br>    gets(str);<br>    k = strlen(str);<br>    scanf(“%d”, &amp;n);<br>    if ( n % k == 0 )<br>        puts(str);<br>    else<br>    {<br>        for ( i=n%k; i&lt;k; i++ )<br>        {<br>            printf(“%c”, str[i]);<br>        }<br>        for ( i=0; i&lt;n%k; i++ )<br>        {<br>            printf(“%c”, str[i]);<br>        }<br>        printf(“\n”);<br>    }<br><br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="11-0-平面向量加法-10"><a href="#11-0-平面向量加法-10" class="headerlink" title="11-0. 平面向量加法(10)"></a>11-0. 平面向量加法(10)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">乔林（清华大学）<br><br></div><br></div>

<div id="problemContent"><br>本题要求编写程序，计算两个二维平面向量的和向量。<br><br><strong>输入格式：</strong><br><br>输入在一行中按照“x1 y1 x2 y2”的格式给出两个二维平面向量V1=(x1, y1)和V2=(x2, y2)的分量。<br><br><strong>输出格式：</strong><br><br>在一行中按照“(x, y)”的格式输出和向量，坐标输出小数点后1位（注意不能输出-0.0）。<br><strong>输入样例：</strong><br><pre>3.5 -2.7 -13.9 8.7<br></pre><br><strong>输出样例：</strong><br><pre>(-10.4, 6.0)<br><br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;<br>#define EPSILON 0.05<br><br>struct Vector {<br>    double x;<br>    double y;<br>};<br><br>int main(void)<br>{<br>    struct Vector v1, v2, v3;<br>    scanf(“%lf%lf%lf%lf”, &amp;v1.x, &amp;v1.y, &amp;v2.x, &amp;v2.y);<br>    v3.x = v1.x + v2.x;<br>    v3.y = v1.y + v2.y;<br>    if(fabs(v3.x) &lt; EPSILON)<br>        v3.x = fabs(v3.x);<br>    if(fabs(v3.y) &lt; EPSILON)<br>        v3.y = fabs(v3.y);<br>    printf(“(%.1f, %.1f)\n”, v3.x, v3.y);<br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="11-1-通讯录的录入与显示-10"><a href="#11-1-通讯录的录入与显示-10" class="headerlink" title="11-1. 通讯录的录入与显示(10)"></a>11-1. 通讯录的录入与显示(10)</h1><div id="problemInfo" class="rfloat"><br><div class="limit"><br><div class="key">时间限制 </div><br><div class="value">400 ms<br><br></div><br></div><br><div class="limit"><br><div class="key">内存限制 </div><br><div class="value">65536 kB<br><br></div><br></div><br><div class="limit"><br><div class="key">代码长度限制 </div><br><div class="value">8000 B<br><br></div><br></div><br><div class="checker"><br><div class="key">判题程序 </div><br><div class="value"><span title="纯文本对比">Standard</span> </div><br></div><br><div class="key">作者 </div><br><div class="value">乔林（清华大学）<br><br></div><br></div>

<div id="problemContent"><br>通讯录中的一条记录包含下述基本信息：朋友的姓名、出生日期、性别、固定电话号码、移动电话号码。本题要求编写程序，录入N条记录，并且根据要求显示任意某条记录。<br><br><strong>输入格式：</strong><br><br>输入在第1行给出正整数N（&lt;=10）；随后N行，每行按照格式“姓名 生日 性别 固话 手机”给出一条记录。其中“姓名”是不超过10个字符、不包含空格的非空字符串；生日按“yyyy/mm/dd”的格式给出年月日；性别用“M”表示“男”、“F”表示“女”；“固话”和“手机”均为不超过15位的连续数字，前面有可能出现“+”。<br><br>在通讯录记录输入完成后，最后一行给出正整数K，并且随后给出K个整数，表示要查询的记录编号（从0到N-1顺序编号）。数字间以空格分隔。<br><br><strong>输出格式：</strong><br><br>对每一条要查询的记录编号，在一行中按照“姓名 固话 手机 性别 生日”的格式输出该记录。若要查询的记录不存在，则输出“Not Found”。<br><strong>输入样例：</strong><br><pre>3<br>Chris 1984/03/10 F +86181779452 13707010007<br>LaoLao 1967/11/30 F 057187951100 +8618618623333<br>QiaoLin 1980/01/01 M 84172333 10086<br>2 1 7<br></pre><br><strong>输出样例：</strong><br><pre>LaoLao 057187951100 +8618618623333 F 1967/11/30<br>Not Found<br><pre name="code" class="cpp">#include &lt;stdio.h&gt;<br>#define N 10<br><br>struct Person {<br>    char name[11];<br>    char birthday[11];<br>    char sex;<br>    char fixed[17];<br>    char mobile[17];<br>};<br><br>int main(void)<br>{<br>    struct Person p[N];<br>    int num[N];<br>    int i, n, k;<br>    scanf(“%d”, &amp;n);<br>    for(i = 0; i &lt; n; ++i)<br>        scanf(“%s %s %c %s %s”, p[i].name, p[i].birthday,<br>              &amp;p[i].sex, p[i].fixed, p[i].mobile);<br>    scanf(“%d”, &amp;k);<br>    for(i = 0; i &lt; k; ++i)<br>        scanf(“%d”, &amp;num[i]);<br>    for(i = 0; i &lt; k; ++i) {<br>        if(num[i] &gt;= 0 &amp;&amp; num[i] &lt; n)<br>            printf(“%s %s %s %c %s\n”, p[num[i]].name,<br>                   p[num[i]].fixed, p[num[i]].mobile, p[num[i]].sex, p[num[i]].birthday);<br>        else<br>            printf(“Not Found\n”);<br>    }<br>    return 0;<br>}</pre><br>&nbsp;</pre><br></div>

<h1 id="此汇总由http-blog-csdn-net-fjinhao编辑整理，转载请注明来源，代码书写有不规范或有错误之处，欢迎批评指教，有任何问题请联系fjinhao-qq-com。"><a href="#此汇总由http-blog-csdn-net-fjinhao编辑整理，转载请注明来源，代码书写有不规范或有错误之处，欢迎批评指教，有任何问题请联系fjinhao-qq-com。" class="headerlink" title="此汇总由http://blog.csdn.net/fjinhao编辑整理，转载请注明来源，代码书写有不规范或有错误之处，欢迎批评指教，有任何问题请联系fjinhao@qq.com。"></a><span style="color:#FF0000"><span style="font-family:KaiTi_GB2312">此汇总由<a href="http://blog.csdn.net/fjinhao编辑整理，转载请注明来源，代码书写有不规范或有错误之处，欢迎批评指教，有任何问题请联系fjinhao@qq.com。" target="_blank" rel="noopener">http://blog.csdn.net/fjinhao编辑整理，转载请注明来源，代码书写有不规范或有错误之处，欢迎批评指教，有任何问题请联系fjinhao@qq.com。</a></span></span></h1>]]></content>
      <categories>
        <category>MOOC</category>
        <category>PAT</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>pat</tag>
        <tag>acm</tag>
        <tag>mooc</tag>
      </tags>
  </entry>
</search>
